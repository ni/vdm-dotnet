//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2019, National Instruments Corp.

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:

// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Diagnostics;
using System.Globalization;
using NationalInstruments.Vision.Internal;
using NationalInstruments.Vision.Analysis.Internal;

namespace NationalInstruments.Vision.Analysis
{
    //==============================================================================================
    /// <summary>
    /// Defines the interpolation method used.
    /// </summary>

    public enum InterpolationMethod
    {
        //==========================================================================================
        /// <summary>
        /// The method uses an interpolation method that interpolates new pixel values using the nearest valid neighboring pixel. 
        /// </summary>

        ZeroOrder = 0,
        //==========================================================================================
        /// <summary>
        /// The method uses an interpolation method that interpolates new pixel values using a bidirectional average of the neighboring pixels. 
        /// </summary>

        Bilinear = 1,
        //==========================================================================================
        /// <summary>
        /// The method uses an interpolation method that interpolates new pixel values using a quadratic approximating polynomial. 
        /// </summary>

        Quadratic = 2,
        //==========================================================================================
        /// <summary>
        /// The method uses an interpolation method that interpolates new pixel values by fitting them to a cubic spline curve, where the curve is based on known pixel values from the image. 
        /// </summary>

        CubicSpline = 3,
        //==========================================================================================
        /// <summary>
        /// The method uses an interpolation method that interpolates new pixel values using a bidirectional average of the neighboring pixels. The function makes the averaging calculations using fixed-point mathematics, which increases the performance of the interpolation but reduces the accuracy. 
        /// </summary>

        BilinearFixed = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method registers the golden template and the image under inspection.
    /// </summary>

    public enum RegistrationMethod
    {
        //==========================================================================================
        /// <summary>
        /// No registration occurs. 
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Adjusts the image to correct for minor variations in alignment or perspective. 
        /// </summary>

        Perspective = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method normalizes the template image relative to the inspection image.
    /// </summary>

    public enum NormalizationMethod
    {
        //==========================================================================================
        /// <summary>
        /// No normalization occurs.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Adjusts the image so its histogram is similar to the golden template's histogram. 
        /// </summary>

        HistogramMatching = 1,
        //==========================================================================================
        /// <summary>
        /// Adjusts the image so its mean pixel value equals the golden template's mean pixel value.
        /// </summary>

        AverageMatching = 2
    }

    //==============================================================================================
    /// <summary>
    /// Defines which of the surrounding pixels of a given pixel constitute its neighborhood.
    /// </summary>

    public enum Connectivity
    {
        //==========================================================================================
        /// <summary>
        /// Only pixels adjacent in the horizontal and vertical directions are considered neighbors.
        /// </summary>

        Connectivity4 = 0,
        //==========================================================================================
        /// <summary>
        /// All adjacent pixels are considered as neighbors.
        /// </summary>

        Connectivity8 = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies whether a match occurs inside or outside the criteria range in 
    /// <see cref="NationalInstruments.Vision.Analysis.ParticleFilterCriteria.Range" crefType="PartiallyQualified"/>.
    /// </summary>

    public enum RangeType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that a match occurs when the measurement is inside the range of
        /// <see cref="NationalInstruments.Vision.Analysis.ParticleFilterCriteria.Range" crefType="PartiallyQualified"/>.
        /// </summary>

        InsideRange = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that a match occurs when the measurement is outside the range of
        /// <see cref="NationalInstruments.Vision.Analysis.ParticleFilterCriteria.Range" crefType="PartiallyQualified"/>.
        /// </summary>

        OutsideRange = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of measurement to perform on particles.
    /// </summary>

    public enum MeasurementType
    {
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the point representing the average position of the total particle mass assuming every point in the particle has a constant density. 
        /// </summary>

        CenterOfMassX = 0,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of the point representing the average position of the total particle mass assuming every point in the particle has a constant density. 
        /// </summary>

        CenterOfMassY = 1,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the highest, leftmost particle pixel. 
        /// </summary>

        FirstPixelX = 2,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of the highest, leftmost particle pixel. 
        /// </summary>

        FirstPixelY = 3,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the leftmost particle point. 
        /// </summary>

        BoundingRectLeft = 4,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of highest particle point. 
        /// </summary>

        BoundingRectTop = 5,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the rightmost particle point. 
        /// </summary>

        BoundingRectRight = 6,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of the lowest particle point. 
        /// </summary>

        BoundingRectBottom = 7,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the start of the line segment connecting the two perimeter points that are the furthest apart.
        /// </summary>

        MaxFeretDiameterStartX = 8,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of the start of the line segment connecting the two perimeter points that are the furthest apart.
        /// </summary>

        MaxFeretDiameterStartY = 9,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the end of the line segment connecting the two perimeter points that are the furthest apart.
        /// </summary>

        MaxFeretDiameterEndX = 10,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of the end of the line segment connecting the two perimeter points that are the furthest apart.
        /// </summary>

        MaxFeretDiameterEndY = 11,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the leftmost pixel in the longest row of contiguous pixels in the particle. 
        /// </summary>

        MaxHorizontalSegmentLengthLeft = 12,
        //==========================================================================================
        /// <summary>
        /// X-coordinate of the rightmost pixel in the longest row of contiguous pixels in the particle. 
        /// </summary>

        MaxHorizontalSegmentLengthRight = 13,
        //==========================================================================================
        /// <summary>
        /// Y-coordinate of all of the pixels in the longest row of contiguous pixels in the particle.
        /// </summary>

        MaxHorizontalSegmentLengthRow = 14,
        //==========================================================================================
        /// <summary>
        /// Distance between the x-coordinate of the leftmost particle point and the x-coordinate of the rightmost particle point. 
        /// </summary>

        BoundingRectWidth = 16,
        //==========================================================================================
        /// <summary>
        /// Distance between the y-coordinate of highest particle point and the y-coordinate of the lowest particle point. 
        /// </summary>

        BoundingRectHeight = 17,
        //==========================================================================================
        /// <summary>
        /// Distance between opposite corners of the bounding rectangle. 
        /// </summary>

        BoundingRectDiagonal = 18,
        //==========================================================================================
        /// <summary>
        /// Sum of the perimeters of each hole in the particle. 
        /// </summary>

        Perimeter = 19,
        //==========================================================================================
        /// <summary>
        /// Perimeter of the smallest convex polygon containing all points in the particle. 
        /// </summary>

        ConvexHullPerimeter = 20,
        //==========================================================================================
        /// <summary>
        /// Sum of the perimeters of each hole in the particle. 
        /// </summary>

        HolesPerimeter = 21,
        //==========================================================================================
        /// <summary>
        /// Distance between the start and end of the line segment connecting the two perimeter points that are the furthest apart.
        /// </summary>

        MaxFeretDiameter = 22,
        //==========================================================================================
        /// <summary>
        /// Length of the major axis of the ellipse with the same perimeter and area as the particle. 
        /// </summary>

        EquivalentEllipseMajorAxis = 23,
        //==========================================================================================
        /// <summary>
        /// Length of the minor axis of the ellipse with the same perimeter and area as the particle. 
        /// </summary>

        EquivalentEllipseMinorAxis = 24,
        //==========================================================================================
        /// <summary>
        /// Length of the minor axis of the ellipse with the same area as the particle, and Major Axis equal in length to 
        /// the MaxFeretDiameter.
        /// </summary>

        EquivalentEllipseMinorAxisFeret = 25,
        //==========================================================================================
        /// <summary>
        /// Longest side of the rectangle with the same perimeter and area as the particle. 
        /// </summary>

        EquivalentRectLongSide = 26,
        //==========================================================================================
        /// <summary>
        /// Shortest side of the rectangle with the same perimeter and area as the particle. 
        /// </summary>

        EquivalentRectShortSide = 27,
        //==========================================================================================
        /// <summary>
        /// Distance between opposite corners of the rectangle with the same perimeter and area as the particle. 
        /// </summary>

        EquivalentRectDiagonal = 28,
        //==========================================================================================
        /// <summary>
        /// Shortest side of the rectangle with the same area as the particle, and longest side equal in length to the MaxFeretDiameter. 
        /// </summary>

        EquivalentRectShortSideFeret = 29,
        //==========================================================================================
        /// <summary>
        /// Average length of a horizontal segment in the particle. 
        /// </summary>

        AverageHorizontalSegmentLength = 30,
        //==========================================================================================
        /// <summary>
        /// Average length of a vertical segment in the particle. 
        /// </summary>

        AverageVerticalSegmentLength = 31,
        //==========================================================================================
        /// <summary>
        /// The particle Area divided by the particle Perimeter.
        /// </summary>

        HydraulicRadius = 32,
        //==========================================================================================
        /// <summary>
        /// Diameter of a disk with the same area as the particle.
        /// </summary>

        WaddelDiskDiameter = 33,
        //==========================================================================================
        /// <summary>
        /// Area of the particle.
        /// </summary>

        Area = 35,
        //==========================================================================================
        /// <summary>
        /// Sum of the areas of each hole in the particle. 
        /// </summary>

        HolesArea = 36,
        //==========================================================================================
        /// <summary>
        /// Percentage of the particle Area in relation to its Particle and Holes' Area. 
        /// </summary>

        ParticleAndHolesArea = 37,
        //==========================================================================================
        /// <summary>
        /// Area of the smallest convex polygon containing all points in the particle. 
        /// </summary>

        ConvexHullArea = 38,
        //==========================================================================================
        /// <summary>
        /// Area of the image. 
        /// </summary>

        ImageArea = 39,
        //==========================================================================================
        /// <summary>
        /// Number of holes in the particle.
        /// </summary>

        NumberOfHoles = 41,
        //==========================================================================================
        /// <summary>
        /// Number of horizontal segments in the particle. 
        /// </summary>

        NumberOfHorizontalSegments = 42,
        //==========================================================================================
        /// <summary>
        /// Number of vertical segments in the particle.
        /// </summary>

        NumberOfVerticalSegments = 43,
        //==========================================================================================
        /// <summary>
        /// The angle of the line that passes through the particle Center of Mass about which the particle has the lowest moment of inertia.
        /// </summary>

        Orientation = 45,
        //==========================================================================================
        /// <summary>
        /// The angle of the line segment connecting the two perimeter points that are the furthest apart. 
        /// </summary>

        MaxFeretDiameterOrientation = 46,
        //==========================================================================================
        /// <summary>
        /// Percentage of the particle Area covering the Image Area.
        /// </summary>

        AreaByImageArea = 48,
        //==========================================================================================
        /// <summary>
        /// Percentage of the particle Area in relation to its Particle and Holes' Area. 
        /// </summary>

        AreaByParticleAndHolesArea = 49,
        //==========================================================================================
        /// <summary>
        /// EquivalentEllipseMajorAxis divided by EquivalentEllipseMinorAxis. 
        /// </summary>

        RatioOfEquivalentEllipseAxes = 50,
        //==========================================================================================
        /// <summary>
        /// EquivalentRectLongSide divided by EquivalentRectShortSide.
        /// </summary>

        RatioOfEquivalentRectSides = 51,
        //==========================================================================================
        /// <summary>
        /// MaxFeretDiameter divided by EquivalentRectShortSideFeret. 
        /// </summary>

        ElongationFactor = 53,
        //==========================================================================================
        /// <summary>
        /// Area divided by the product of BoundingRectWidth and BoundingRectHeight. 
        /// </summary>

        CompactnessFactor = 54,
        //==========================================================================================
        /// <summary>
        /// Perimeter divided by the circumference of a circle with the same area. 
        /// </summary>

        HeywoodCircularityFactor = 55,
        //==========================================================================================
        /// <summary>
        /// Factor relating area to moment of inertia. 
        /// </summary>

        TypeFactor = 56,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates in the particle.
        /// </summary>

        SumX = 58,
        //==========================================================================================
        /// <summary>
        /// The sum of all y-coordinates in the particle.
        /// </summary>

        SumY = 59,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates squared in the particle.
        /// </summary>

        SumXX = 60,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates times y-coordinates in the particle. 
        /// </summary>

        SumXY = 61,
        //==========================================================================================
        /// <summary>
        /// The sum of all y-coordinates squared in the particle.
        /// </summary>

        SumYY = 62,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates cubed in the particle.
        /// </summary>

        SumXXX = 63,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates squared times y-coordinates in the particle. 
        /// </summary>

        SumXXY = 64,
        //==========================================================================================
        /// <summary>
        /// The sum of all x-coordinates times y-coordinates squared in the particle. 
        /// </summary>

        SumXYY = 65,
        //==========================================================================================
        /// <summary>
        /// The sum of all y-coordinates cubed in the particle.
        /// </summary>

        SumYYY = 66,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the x-direction twice. 
        /// </summary>

        MomentOfInertiaXX = 68,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the x- and y-directions.
        /// </summary>

        MomentOfInertiaXY = 69,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the y-direction twice.
        /// </summary>

        MomentOfInertiaYY = 70,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the x-direction three times. 
        /// </summary>

        MomentOfInertiaXXX = 71,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the x-direction twice and the y-direction once.
        /// </summary>

        MomentOfInertiaXXY = 72,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the x-direction once and the y-direction twice. 
        /// </summary>

        MomentOfInertiaXYY = 73,
        //==========================================================================================
        /// <summary>
        /// The moment of inertia in the y-direction three times. 
        /// </summary>

        MomentOfInertiaYYY = 74,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the x-direction twice.
        /// </summary>

        NormalizedMomentOfInertiaXX = 75,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the x- and y-directions.
        /// </summary>

        NormalizedMomentOfInertiaXY = 76,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the y-direction twice. 
        /// </summary>

        NormalizedMomentOfInertiaYY = 77,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the x-direction three times.
        /// </summary>

        NormalizedMomentOfInertiaXXX = 78,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the x-direction twice and the y-direction once.
        /// </summary>

        NormalizedMomentOfInertiaXXY = 79,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the x-direction once and the y-direction twice. 
        /// </summary>

        NormalizedMomentOfInertiaXYY = 80,
        //==========================================================================================
        /// <summary>
        /// The normalized moment of inertia in the y-direction three times.
        /// </summary>

        NormalizedMomentOfInertiaYYY = 81,
        //==========================================================================================
        /// <summary>
        /// The first Hu moment.
        /// </summary>

        HuMoment1 = 82,
        //==========================================================================================
        /// <summary>
        /// The second Hu moment.
        /// </summary>

        HuMoment2 = 83,
        //==========================================================================================
        /// <summary>
        /// The third Hu moment.
        /// </summary>

        HuMoment3 = 84,
        //==========================================================================================
        /// <summary>
        /// The fourth Hu moment. 
        /// </summary>

        HuMoment4 = 85,
        //==========================================================================================
        /// <summary>
        /// The fifth Hu moment.
        /// </summary>

        HuMoment5 = 86,
        //==========================================================================================
        /// <summary>
        /// The sixth Hu moment. 
        /// </summary>

        HuMoment6 = 87,
        //==========================================================================================
        /// <summary>
        /// The seventh Hu moment. 
        /// </summary>

        HuMoment7 = 88,
    }

    //==============================================================================================
    /// <summary>
    /// Specifies what OCR information is read.
    /// </summary>

    public enum OcrReadMode
    {
        //==========================================================================================
        /// <summary>
        /// Reads both the character set data and the session properties from file. 
        /// </summary>

        All = 0,
        //==========================================================================================
        /// <summary>
        /// Reads only the character set data from file. 
        /// </summary>

        CharacterSetOnly = 1,
        //==========================================================================================
        /// <summary>
        /// Reads only the session properties from file. 
        /// </summary>

        PropertiesOnly = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the level of checking that NI Vision performs when it reads text and analyzes it to 
    /// determine if the read objects match trained characters. 
    /// </summary>

    public enum OcrReadStrategy
    {
        //==========================================================================================
        /// <summary>
        /// Configures NI Vision to perform fewer checks when analyzing objects to determine if they match 
        /// trained characters. This option increases performance by 20 percent, but might result in inaccurate 
        /// reads. You can successfully use the aggressive strategy for most cases. Use the aggressive strategy 
        /// unless the character set or image quality requires more stringent analysis. 
        /// </summary>

        Aggressive = 0,
        //==========================================================================================
        /// <summary>
        /// Configures NI Vision to perform more checks to determine if an object matches a trained character. 
        /// This strategy is slower than the aggressive strategy, but it is more accurate and results in fewer 
        /// mismatches. 
        /// </summary>

        Conservative = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the resolution the 
    /// <see cref="NationalInstruments.Vision.Analysis.OcrSession.ReadText" crefType="Unqualified"/> method uses to 
    /// read characters. Refer to the <format type="italics">NI OCR Training Interface Help</format> 
    /// for more information.
    /// </summary>

    public enum OcrReadResolution
    {
        //==========================================================================================
        /// <summary>
        /// Configures NI Vision to use low resolution during the read process. 
        /// </summary>

        LowResolution = 0,
        //==========================================================================================
        /// <summary>
        /// Configures NI Vision to use medium resolution during the read process. 
        /// </summary>

        MediumResolution = 1,
        //==========================================================================================
        /// <summary>
        /// Configures NI Vision to use high resolution during the read process. 
        /// </summary>

        HighResolution = 2
    }

    public enum LineSeparatorType
    {
        EndOfLineConstant = 0,        // Inserts \n\r as line separator for multiline read string and uses \n\r to count the lines from multiline string to be trained
        LineFeed          = 1,        // Inserts \n as line separator for multiline read string and uses \n\r to count the lines from multiline string to be trained
        CarriageReturn    = 2,        // Inserts \r as line separator for multiline read string and uses \n\r to count the lines from multiline string to be trained
    }

    public enum OCRThresholdType
    {
        GlobalThreshold = 0,             //Performs global threshold depending on the mode selected from ThresholdMode
        LocalThreshold  = 1,             //The function performs background correction first to eliminate non-uniform lighting effects, then performs thresholding using the Otsu thresholding algorithm.
        ColorThreshold  = 2,             //Applies threshold to the threes planes of a RGB, HSL, HSV or HSI plane
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how NI Vision calculates the threshold method you want to use to analyze an image. 
    /// </summary>

    public enum OcrThresholdMode
    {
        //==========================================================================================
        /// <summary>
        /// Performs no automatic calculations. You manually set the threshold value. This mode provides the fastest thresholding method. 
        /// </summary>

        FixedRange = 0,
        //==========================================================================================
        /// <summary>
        /// Calculates a single threshold value for the entire ROI.
        /// </summary>

        ComputedUniform = 1,
        //==========================================================================================
        /// <summary>
        /// Calculates a value on the left side of the ROI, calculates a value on the right size of the ROI, and 
        /// then linearly fills the middle values from left to right. The size of the steps from which to 
        /// calculate the left and right values is based on the value of 
        /// <see cref="NationalInstruments.Vision.Analysis.OcrProcessingOptions.BlockCount" crefType="PartiallyQualified"/>.
        /// Use this mode when the light intensity varies uniformly across the ROI. 
        /// </summary>

        ComputedLinear = 2,
        //==========================================================================================
        /// <summary>
        /// Divides the ROI into the number of blocks specified by 
        /// <see cref="NationalInstruments.Vision.Analysis.OcrProcessingOptions.BlockCount" crefType="PartiallyQualified"/>, 
        /// calculates a threshold value for each block, and then uses the value to extract pixel data. 
        /// </summary>

        ComputedNonlinear = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the predefined characters for the corresponding character position.
    /// </summary>

    public enum OcrPredefinedCharacters
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that any character is valid for the corresponding position.
        /// </summary>

        AnyCharacter = 0,
        //==========================================================================================
        /// <summary>
        /// Indicates that the valid characters for this position are specified by a user-defined character string. 
        /// </summary>

        UserDefinedCharacters = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only alphabetical characters. 
        /// </summary>

        Alphabetic = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position contains alphabetic characters and the 
        /// numerical characters 0 to 9.
        /// </summary>

        AlphaNumeric = 3,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only uppercase alphabetical characters. 
        /// </summary>

        UppercaseLetters = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only lowercase alphabetical characters. 
        /// </summary>

        LowercaseLetters = 5,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only numerical characters from 0 to 9. 
        /// </summary>

        DecimalDigits = 6,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only hexadecimal numerical characters, 
        /// which includes 0 to 9 and A to F. 
        /// </summary>

        HexadecimalDigits = 7,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position can contain only a pattern. 
        /// </summary>

        Pattern = 8,
        //==========================================================================================
        /// <summary>
        /// Specifies that the corresponding position is ignored and is replaced by a space in the output string. 
        /// </summary>

        ForceSpace = 9
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the number of samples to obtain from a pixel. For example, a subpixel accuracy of one-fourth specifies that each pixel is split into four subpixels.
    /// </summary>

    public enum SubPixelAccuracy {
        //==========================================================================================
        /// <summary>
        /// Does not split pixels.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 2 subpixels.
        /// </summary>

        OneHalf = 1,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 3 subpixels.
        /// </summary>

        OneThird = 2,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 4 subpixels.
        /// </summary>

        OneFourth = 3,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 5 subpixels.
        /// </summary>

        OneFifth = 4,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 6 subpixels.
        /// </summary>

        OneSixth = 5,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 7 subpixels.
        /// </summary>

        OneSeventh = 6,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 8 subpixels.
        /// </summary>

        OneEighth = 7,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 9 subpixels.
        /// </summary>

        OneNinth = 8,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 10 subpixels.
        /// </summary>

        OneTenth = 9,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 11 subpixels.
        /// </summary>

        OneEleventh = 10,
        //==========================================================================================
        /// <summary>
        /// Splits each pixel into 12 subpixels.
        /// </summary>

        OneTwelfth = 11
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the features of the image are used during the search phase. Use the search strategy 
    /// parameter to optimize the speed of the pattern matching algorithm by allowing the algorithm to 
    /// inspect less data from the image.
    /// </summary>

    public enum SearchStrategy
    {
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to use the largest possible amount of information from the image at the expense of slowing down the speed of the algorithm. 
        /// </summary>

        Conservative = 1,
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to balance the amount of information from the image it uses with the speed of the algorithm.
        /// </summary>

        Balanced = 2,
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to use a lower amount of information from the image, which allows the algorithm to run quickly but at the expense of accuracy. 
        /// </summary>

        Aggressive = 3,
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to use the smallest possible amount of information from the image, which allows the algorithm to run at the highest speed possible but at the expense of accuracy. 
        /// </summary>

        VeryAggressive = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the features of the image are used during the search phase. Use the search strategy parameter to 
    /// optimize the speed of the pattern matching algorithm by allowing the algorithm to inspect less data from the image. 
    /// </summary>

    public enum GeometricMatchingSearchStrategy
    {
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to use the largest possible amount of information from the 
        /// image at the expense of slowing down the speed of the algorithm. 
        /// </summary>

        Conservative = 0,
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to balance the amount of information from the image 
        /// it uses with the speed of the algorithm. 
        /// </summary>

        Balanced = 1,
        //==========================================================================================
        /// <summary>
        /// Instructs the pattern matching algorithm to use a lower amount of information from the image, which allows the 
        /// algorithm to run quickly but at the expense of accuracy. 
        /// </summary>

        Aggressive = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies whether to search for matches with the same contrast or reverse contrast as 
    /// the template.
    /// </summary>

    public enum ContrastMode
    {
        //==========================================================================================
        /// <summary>
        /// Searches for matches with the same contrast as the template.
        /// </summary>

        Original = 0,
        //==========================================================================================
        /// <summary>
        /// Searches for matches with the inverse contrast of the template.
        /// </summary>

        Reversed = 1,
        //==========================================================================================
        /// <summary>
        /// Searches for matches with the same contrast and inverse contrast.
        /// </summary>

        Both = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the invariance mode the method uses when learning the pattern.
    /// </summary>

    public enum LearnMode
    {
        //==========================================================================================
        /// <summary>
        /// The method extracts information for shift- and rotation-invariant matching. 
        /// </summary>

        All = 0,
        //==========================================================================================
        /// <summary>
        /// The method extracts information for shift-invariant matching. 
        /// </summary>

        ShiftInformation = 1,
        //==========================================================================================
        /// <summary>
        /// The method extracts information for rotation-invariant matching. 
        /// </summary>

        RotationInformation = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how to look for the pattern in the image.
    /// </summary>

    public enum MatchMode
    {
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the template image anywhere in the searchRect, assuming that the pattern is not rotated more than plus or minus 4 degrees. 
        /// </summary>

        ShiftInvariant = 1,
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the pattern in the image with no restriction on the rotation of the pattern. 
        /// </summary>

        RotationInvariant = 2
    }	   

    //==============================================================================================
    /// <summary>
    /// Specifies the types of objects that a classifier can classify.
    /// </summary>

    public enum ClassifierType
    {
        //==========================================================================================
        /// <summary>
        /// The classifier session classifies vectors of doubles. 
        /// </summary>

        Custom = 0,
        //==========================================================================================
        /// <summary>
        /// The classifier session classifies particles in binary images. 
        /// </summary>

        Particle = 1,
        //==========================================================================================
        /// <summary>
        /// The classifier session classifies particles based on color. 
        /// </summary>

        Color = 2,
        //==========================================================================================
        /// <summary>
        /// The classifier session classifies particles based on Texture Defect. 
        /// </summary>

        TextureDefect = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies what information to write to a classifier file.
    /// </summary>

    public enum WriteClassifierFileMode
    {
        //==========================================================================================
        /// <summary>
        /// Writes all information to the classifier file. 
        /// </summary>

        All = 0,
        //==========================================================================================
        /// <summary>
        /// Write only the information needed to classify to the classifier file. 
        /// </summary>

        ClassifyOnly = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of information to read from a classifier file.
    /// </summary>

    public enum ReadClassifierFileMode
    {
        //==========================================================================================
        /// <summary>
        /// Reads all data, including samples and properties.
        /// </summary>

        All = 0,
        //==========================================================================================
        /// <summary>
        /// Reads just the samples.
        /// </summary>

        Samples = 1,
        //==========================================================================================
        /// <summary>
        /// Reads just the properties.
        /// </summary>

        Properties = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of an engine on a classifier session.
    /// </summary>

    public enum ClassifierEngineType
    {
        //==========================================================================================
        /// <summary>
        /// This classifier has not been trained yet, and so has no engine.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// This classifier has been trained with the Nearest Neighbor engine.
        /// </summary>

        NearestNeighbor = 1,
        //==========================================================================================
        /// <summary>
        /// This classifier has been trained with the SVM engine.
        /// </summary>

        SupportVectorMachine = 2,
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the methods to use with the Nearest Neighbor algorithm.
    /// </summary>

    public enum NearestNeighborMethod
    {
        //==========================================================================================
        /// <summary>
        /// The minimum mean distance method.
        /// </summary>

        MinimumMeanDistance = 0,
        //==========================================================================================
        /// <summary>
        /// The k-nearest neighbor method. 
        /// </summary>

        KNearestNeighbor = 1,
        //==========================================================================================
        /// <summary>
        /// The nearest prototype method.
        /// </summary>

        NearestPrototype = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the metrics to use with the Nearest Neighbor algorithm.
    /// </summary>

    public enum NearestNeighborMetric
    {
        //==========================================================================================
        /// <summary>
        /// The maximum metric. 
        /// </summary>

        Maximum = 0,
        //==========================================================================================
        /// <summary>
        /// The sum metric. 
        /// </summary>

        Sum = 1,
        //==========================================================================================
        /// <summary>
        /// The Euclidean metric. 
        /// </summary>

        Euclidean = 2
    }

    //==============================================================================================
    /// <summary>
    /// Defines how a method uses binary thresholding. For information about automatic 
    /// thresholding methods, refer to the <format type="italics">Thresholding</format> section of 
    /// the <format type="italics">NI Vision Concepts Help</format>.
    /// </summary>

    public enum ThresholdMethod
    {
        //==========================================================================================
        /// <summary>
        /// Sorts the histogram of the image within a discrete number of classes corresponding to the number of phases perceived in an image. 
        /// </summary>

        Clustering = 0,
        //==========================================================================================
        /// <summary>
        /// Best for detecting particles that are present in minuscule proportions on the image. 
        /// </summary>

        Entropy = 1,
        //==========================================================================================
        /// <summary>
        /// Calculates an optimal threshold value using the surfaces representing the initial gray scale. Well-suited for images in which classes are not too disproportionate.
        /// </summary>

        Metric = 2,
        //==========================================================================================
        /// <summary>
        /// Well-suited for images that have poor contrast.
        /// </summary>

        Moments = 3,
        //==========================================================================================
        /// <summary>
        /// Determines an optimal threshold by maximizing the between-class variation with respect to the threshold. 
        /// Well-suited for images in which classes have well separated pixel value distributions.
        /// </summary>

        InterclassVariance = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of thresholding to use.
    /// </summary>

    public enum ThresholdType
    {
        //==========================================================================================
        /// <summary>
        /// Uses manual thresholding. Manual thresholding is usesful if all the objects of interest in a grayscale
        /// image fall within a continuous range of intensities and you can specify the threshold range manually.
        /// </summary>

        Manual = 0,
        //==========================================================================================
        /// <summary>
        /// Uses automatic thresholding. Automatic thresholding is well-suited for conditions in which the 
        /// light intensity varies from image to image.
        /// </summary>

        Auto = 1,
        //==========================================================================================
        /// <summary>
        /// Uses local thresholding. Use local thresholding to isolate objects of interest from the background in
        /// images that exhibit nonuniform lighting changes.
        /// </summary>

        Local = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the color resolution of feature vectors.
    /// </summary>

    public enum ColorClassifierResolution
    {
        //==========================================================================================
        /// <summary>
        /// Sets the color resolution to High, which enables 512 elements of feature vectors.
        /// </summary>

        High = 0,
        //==========================================================================================
        /// <summary>
        /// Sets the color resolution to Medium, which enables 128 elements of feature vectors.
        /// </summary>

        Medium = 1,
        //==========================================================================================
        /// <summary>
        /// Sets the color resolution to Low, which enables 64 elements of feature vectors.
        /// </summary>

        Low = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies what kind of particles to search for.
    /// </summary>

    public enum ParticleType
    {
        //==========================================================================================
        /// <summary>
        /// Searches for bright particles.
        /// </summary>

        Bright = 0,
        //==========================================================================================
        /// <summary>
        /// Searches for dark particles. 
        /// </summary>

        Dark = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the family of the kernel matrix. For more information about kernels, refer to the <format type="italics">Image Processing</format> topic of the <format type="italics">NI Vision Concepts Help</format>.
    /// </summary>

    public enum KernelFamily
    {
        //==========================================================================================
        /// <summary>
        /// The kernel is in the gradient family. Gradient kernels highlight the variations of light intensity along a specific direction, which has the effect of outlining edges and revealing texture. 
        /// </summary>

        Gradient = 0,
        //==========================================================================================
        /// <summary>
        /// The kernel is in the Laplacian family. Laplacian kernels highlight the variation of the light intensity surrounding a pixel. 
        /// </summary>

        Laplacian = 1,
        //==========================================================================================
        /// <summary>
        /// The kernel is in the smoothing family. Smoothing kernels attenuate the variations of light intensity in the neighborhood of a pixel. 
        /// </summary>

        Smoothing = 2,
        //==========================================================================================
        /// <summary>
        /// The kernel is in the Gaussian family. Gaussian kernels attenuate the variations of light 
        /// intensity in the neighborhood of a pixel. A Gaussian kernel is similar to a smoothing filter, 
        /// but its blurring effect is more subdued. 
        /// </summary>

        Gaussian = 3
    }

    //==============================================================================================
    /// <summary>
    /// Determines the size of the particles the method keeps after the erosion.
    /// </summary>

    public enum SizeToKeep
    {
        //==========================================================================================
        /// <summary>
        /// The method keeps large particles remaining after the erosion. 
        /// </summary>

        KeepLarge = 0,
        //==========================================================================================
        /// <summary>
        /// The method keeps small particles eliminated by the erosion. 
        /// </summary>

        KeepSmall = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the shape of the structuring element. For more information on structuring elements, refer to
    /// the <format type="italics">Binary Morphology</format> section in 
    /// the <format type="italics">NI Vision Concepts Help</format>.
    /// </summary>

    public enum StructuringElementShape
    {
        //==========================================================================================
        /// <summary>
        /// Sets the strucuturing element to square.
        /// </summary>

        Square = 0,
        //==========================================================================================
        /// <summary>
        /// Sets the strucuturing element to hexagon.
        /// </summary>

        Hexagon = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of a barcode.
    /// </summary>

    [Flags]
    public enum BarcodeTypes
    {
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Codabar. 
        /// </summary>

        Codabar = 0x1,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Code 39. 
        /// </summary>

        Code39 = 0x2,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Code 93. 
        /// </summary>

        Code93 = 0x4,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Code 128. 
        /// </summary>

        Code128 = 0x8,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type EAN 8. 
        /// </summary>

        Ean8 = 0x10,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type EAN 13. 
        /// </summary>

        Ean13 = 0x20,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Code 25. 
        /// </summary>

        I2Of5 = 0x40,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type MSI code. 
        /// </summary>

        Msi = 0x80,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type UPC A. 
        /// </summary>

        UpcA = 0x100,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type Pharmacode. 
        /// </summary>

        Pharmacode = 0x200,
        //==========================================================================================
        /// <summary>
        /// The barcode is of type GS1 DataBar. 
        /// </summary>

        RssLimited = 0x400,
        //==========================================================================================
        /// <summary>
        /// The type of barcode is unknown.
        /// </summary>

        Unknown = unchecked((int)0xFFFFFFFF)
    }

    //==============================================================================================
    /// <summary>
    /// Specifies whether the method searches for one barcode or multiple barcodes.
    /// </summary>

    public enum Pdf417SearchMode
    {
        //==========================================================================================
        /// <summary>
        /// The method searches for multiple barcodes. 
        /// </summary>

        Multiple = 0,
        //==========================================================================================
        /// <summary>
        /// The function searches for barcodes, stopping after locating one valid barcode. 
        /// </summary>

        Single = 1,
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the dimensions of the QR code.
    /// </summary>

    public enum QRDimension
    {
        //==========================================================================================
        /// <summary>
        /// The method should automatically detect the dimensions of the QR code.
        /// </summary>

        AutoDetect = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 11 x 11.
        /// </summary>

        Size11x11 = 11,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 13 x 13.
        /// </summary>

        Size13x13 = 13,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 15 x 15.
        /// </summary>

        Size15x15 = 15,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 17 x 17.
        /// </summary>

        Size17x17 = 17,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 21 x 21.
        /// </summary>

        Size21x21 = 21,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 25 x 25.
        /// </summary>

        Size25x25 = 25,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 29 x 29.
        /// </summary>

        Size29x29 = 29,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 33 x 33.
        /// </summary>

        Size33x33 = 33,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 37 x 37.
        /// </summary>

        Size37x37 = 37,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 41 x 41.
        /// </summary>

        Size41x41 = 41,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 45 x 45.
        /// </summary>

        Size45x45 = 45,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 49 x 49.
        /// </summary>

        Size49x49 = 49,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 53 x 53.
        /// </summary>

        Size53x53 = 53,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 57 x 57.
        /// </summary>

        Size57x57 = 57,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 61 x 61.
        /// </summary>

        Size61x61 = 61,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 65 x 65.
        /// </summary>

        Size65x65 = 65,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 69 x 69.
        /// </summary>

        Size69x69 = 69,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 73 x 73.
        /// </summary>

        Size73x73 = 73,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 77 x 77.
        /// </summary>

        Size77x77 = 77,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 81 x 81.
        /// </summary>

        Size81x81 = 81,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 85 x 85.
        /// </summary>

        Size85x85 = 85,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 89 x 89.
        /// </summary>

        Size89x89 = 89,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 93 x 93.
        /// </summary>

        Size93x93 = 93,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 97 x 97.
        /// </summary>

        Size97x97 = 97,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 101 x 101.
        /// </summary>

        Size101x101 = 101,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 105 x 105.
        /// </summary>

        Size105x105 = 105,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 109 x 109.
        /// </summary>

        Size109x109 = 109,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 113 x 113.
        /// </summary>

        Size113x113 = 113,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 117 x 117.
        /// </summary>

        Size117x117 = 117,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 121 x 121.
        /// </summary>

        Size121x121 = 121,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 125 x 125.
        /// </summary>

        Size125x125 = 125,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 129 x 129.
        /// </summary>

        Size129x129 = 129,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 133 x 133.
        /// </summary>

        Size133x133 = 133,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 137 x 137.
        /// </summary>

        Size137x137 = 137,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 141 x 141.
        /// </summary>

        Size141x141 = 141,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 145 x 145.
        /// </summary>

        Size145x145 = 145,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 149 x 149.
        /// </summary>

        Size149x149 = 149,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 153 x 153.
        /// </summary>

        Size153x153 = 153,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 157 x 157.
        /// </summary>

        Size157x157 = 157,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 161 x 161.
        /// </summary>

        Size161x161 = 161,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 165 x 165.
        /// </summary>

        Size165x165 = 165,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 169 x 169.
        /// </summary>

        Size169x169 = 169,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 173 x 173.
        /// </summary>

        Size173x173 = 173,
        //==========================================================================================
        /// <summary>
        /// Specifies the dimensions of the QR code as 177 x 177.
        /// </summary>

        Size177x177 = 177
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the polarity of the QR code to search for.
    /// </summary>

    public enum QRPolarity
    {
        //==========================================================================================
        /// <summary>
        /// The method should determine the polarity of the QR code.
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method should search for a QR code with dark data on a bright background.
        /// </summary>

        BlackOnWhite = 0,
        //==========================================================================================
        /// <summary>
        /// The method should search for a QR code with bright data on a dark background.
        /// </summary>

        WhiteOnBlack = 1,
    }

    //==============================================================================================
    /// <summary>
    /// Specifies if the QR code appears normally in the image of if the code appears mirrored in the image.
    /// </summary>

    public enum QRMirrorMode
    {
        //==========================================================================================
        /// <summary>
        /// The method should determine if the QR code appears normal or mirrored.
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method should expect the QR code to appear normal.
        /// </summary>

        Normal = 0,
        //==========================================================================================
        /// <summary>
        /// The method should expect the QR code to appear mirrored.
        /// </summary>

        Mirrored = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies what type of QR code the detector will search for.
    /// </summary>

    public enum QRModelType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the method will auto-detect what type of matrix the QR code is. 
        /// </summary>

        AutoDetect = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the QR code is of a micro type. Micro QR codes have a single target in the top left of the code. 
        /// </summary>

        Micro = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the QR code is of a model1 type. This means the code has target patterns in the top left, top right, bottom left, and no alignment patterns in the data.
        /// </summary>

        Model1 = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies the QR code is of a model2 type. This is most common type of QR code. 
        /// </summary>

        Model2 = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the amount of QR code rotation the method should allow for.
    /// </summary>

    public enum QRRotationMode
    {
        //==========================================================================================
        /// <summary>
        /// The method allows for unlimited rotation.
        /// </summary>

        Unlimited = 0,
        //==========================================================================================
        /// <summary>
        /// The method allows for 5 degrees of rotation.
        /// </summary>

        Degrees0 = 1,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 85 and 95 degrees of rotation.
        /// </summary>

        Degrees90 = 2,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 175 and 185 degrees of rotation.
        /// </summary>

        Degrees180 = 3,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 265 and 275 degrees of rotation.
        /// </summary>

        Degrees270 = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the mode the method should use to demodulate (determine which cells are "on" or "off") the QR code.
    /// </summary>

    public enum QRDemodulationMode
    {
        //==========================================================================================
        /// <summary>
        /// The method will try each demodulation mode and use the one which decodes the QR code within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method uses a histogram of all of the QR cells to calculate a threshold. This threshold determines if a cell is on or off. This is the fastest mode, but requires images with consistent levels of contrast.
        /// </summary>

        Histogram = 0,
        //==========================================================================================
        /// <summary>
        /// The method examines each of the cell's neighbors to determine if the cell is on or off. This mode is slower, but works with images that have inconsistent levels of contrast. 
        /// </summary>

        LocalContrast = 1,
        //==========================================================================================
        /// <summary>
        /// The method uses the histogram of the QR code to calculate a threshold. For cells with pixel 
        /// values that are sufficiently below or above this threshold, the method will use the threshold 
        /// to determine if the cell is on or off. If the cell pixel values are close to the threshold, 
        /// the method will use the LocalContrast mode to determine if the cell is on or off. This mode is 
        /// slower, but works with images that contain a QR code with extremely low cell fill percentages 
        /// or gross print growth errors.
        /// </summary>

        Combined = 2,
        //==========================================================================================
        /// <summary>
        /// The method tries Histogram, then LocalContrast, and then Combined, stopping once one mode is successful.
        /// </summary>

        All = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the sample size, in pixels, the method should take to determine if each cell is on or off.
    /// </summary>

    public enum QRCellSampleSize
    {
        //==========================================================================================
        /// <summary>
        /// The method will try each sample size and use the one which decodes the QR code within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method will use a 1x1 sized sample from each cell.
        /// </summary>

        Size1x1 = 1,
        //==========================================================================================
        /// <summary>
        /// The method will use a 2x2 sized sample from each cell.
        /// </summary>

        Size2x2 = 2,
        //==========================================================================================
        /// <summary>
        /// The method will use a 3x3 sized sample from each cell.
        /// </summary>

        Size3x3 = 3,
        //==========================================================================================
        /// <summary>
        /// The method will use a 4x4 sized sample from each cell.
        /// </summary>

        Size4x4 = 4,
        //==========================================================================================
        /// <summary>
        /// The method will use a 5x5 sized sample from each cell.
        /// </summary>

        Size5x5 = 5,
        //==========================================================================================
        /// <summary>
        /// The method will use a 6x6 sized sample from each cell.
        /// </summary>

        Size6x6 = 6,
        //==========================================================================================
        /// <summary>
        /// The method will use a 7x7 sized sample from each cell.
        /// </summary>

        Size7x7 = 7
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the mode used to determine the pixel value for each cell.
    /// </summary>

    public enum QRCellFilterMode
    {
        //==========================================================================================
        /// <summary>
        /// The method will try all filter modes and uses the one that decodes the QR code within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average of the sampled pixels. 
        /// </summary>

        Average = 0,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the median of the sampled pixels. 
        /// </summary>

        Median = 1,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average of the pixels in the center of the cell sample. 
        /// </summary>

        CentralAverage = 2,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values. 
        /// </summary>

        HighAverage = 3,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average value of the half of the sampled pixels with the lowest pixel values.
        /// </summary>

        LowAverage = 4,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values.
        /// </summary>

        VeryHighAverage = 5,
        //==========================================================================================
        /// <summary>
        /// The method sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the lowest pixel values.
        /// </summary>

        VeryLowAverage = 6,
        //==========================================================================================
        /// <summary>
        /// The method tries each filter mode, starting with Average and ending with VeryLowAverage, stopping once a filter mode decodes correctly.
        /// </summary>

        All = 8
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the format of the data encoded in the stream. 
    /// </summary>

    public enum QRStreamMode
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the data was encoded using numeric mode.
        /// </summary>

        Numeric = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data is encoded using alpha-numeric mode.
        /// </summary>

        Alphanumeric = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data was not encoded but is only raw binary bytes, or encoded in JIS-8. 
        /// </summary>

        RawByte = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data has a special meaning represented by the application ID. 
        /// The application ID is located in the tokenized data stream.
        /// </summary>

        Ean128Token = 3,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data has a special meaning represented by the application ID.
        /// </summary>

        Ean128Data = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data is meant to be read using the language represented in the language ID. 
        /// </summary>

        Eci = 5,
        //==========================================================================================
        /// <summary>
        /// Specifies that the data is encoded in Shift-JIS8 Japanese.
        /// </summary>

        Kanji = 6
    }

    //==============================================================================================
    /// <summary>
    /// Define what calculations the method makes to prepare to grade the Data Matrix barcode.
    /// </summary>

    public enum DataMatrixGradingMode
    {
        //==========================================================================================
        /// <summary>
        /// The method does not make any preparatory calculations. Attempts to grade this Data Matrix barcode will generate an error.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// The method prepares the image for grading using the AIM Print Quality metrics.
        /// </summary>

        PrepareForAim = 1
    }

    public enum MatchingAlgorithm
    { 
        MatchAllAlgorithms      =   0,
        MatchLowDiscrepancy     =   1,
        MatchGrayValuePyramid   =   2,
        MatchGradientPyramid    =   3
    }

    public enum LearnSetupOption
    {
        // Old PM options
        LoadDiscrepancySearchStrategy           =   0,
        LoadDiscrepancyInitialStepSize          =   1,
        LoadDiscrepancyInitialSampleSize        =   2,
        LoadDiscrepancyInitialSampleSizeFactor  =   3,
        LoadDiscrepancyInitialAngularAccuracy   =   4,
        LoadDiscrepancyFinalSampleSize          =   5,
        LoadDiscrepancyFinalSampleSizeFactor    =   6,
        LoadDiscrepancyFinalAngularAccuracy     =   7,
        LoadDiscrepancySubpixelSampleSize       =   8,
        LoadDiscrepancySubpixelSampleSizeFactor =   9,
        LoadDiscrepancyMatchOffsetXPosition     =   10,
        LoadDiscrepancyMatchOffsetYPosition     =   11,
        LoadDiscrepancyMatchOffsetAngle         =   12,
        // New PM options
        PyramidSubpixelSampleSize               =   100,
        PyramidSubpixelSampleSizeFactor         =   101,
        PyramidMatchOffsetXPosition             =   102,
        PyramidMatchOffsetYPosition             =   103,
        PyramidMatchOffsetAngle                 =   104,
        PyramidMaxPyramidLevelToStoreData       =   105
    }

    public enum MatchSetupOption
    {
        LoadDiscrepancyMinimumContrast              =   0,
        LoadDiscrepancyEnableSubpixelAccuracy       =   1,
        LoadDiscrepancySearchStrategy               =   2,
        LoadDiscrepancySubpixelIterations           =   3,
        LoadDiscrepancySubpixelTolerance            =   4,
        LoadDiscrepancyInitialMatchListLength       =   5,
        LoadDiscrepancyMatchListReductionFactor     =   6,
        LoadDiscrepancyInitialStepSize              =   7,
        LoadDiscrepancyIntermediateAngularAccuracy  =   8,
        // Pyramid Matching Options
        PyramidMaxPyramidLevel                      =   100,
        PyramidEnableSpiralSearch                   =   101,
        PyramidMinimumContrast                      =   102,
        PyramidEnableSubpixelAccuracy               =   103,
        PyramidSubpixelIterations                   =   104,
        PyramidSubpixelTolerance                    =   105,
        PyramidInitialMatchListLength               =   106,
        PyramidMatchListReductionFactor             =   107,
        PyramidIntermediateAngularAccuracy          =   108,
        PyramidProcessBorderMatches                 =   109,
        PyramidFastMatchMode                        =   110,
        PyramidMinMatchSeparationDistance           =   111,
        PyramidMinMatchSeparationAngle              =   112,
        PyramidMaxMatchOverlap                      =   113,
        PyramidMaxCacheSizeInMegabytes              =   114,
        PyramidClearCacheOnEveryMatch               =   115
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the ECC used for the Data Matrix barcode in the image.
    /// </summary>

    public enum DataMatrixEcc
    {
        //==========================================================================================
        /// <summary>
        /// Sets the method to determine the Data Matrix barcode ECC automatically. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 000 only. 
        /// </summary>

        Ecc000 = 0,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 050 only. 
        /// </summary>

        Ecc050 = 50,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 080 only.
        /// </summary>

        Ecc080 = 80,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 100 only. 
        /// </summary>

        Ecc100 = 100,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 140 only. 
        /// </summary>

        Ecc140 = 140,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 000, ECC 050, ECC 080, ECC 100, and ECC 140 only. 
        /// </summary>

        Ecc000To140 = 190,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes of ECC 200 only. 
        /// </summary>

        Ecc200 = 200
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the data-to-background contrast for the Data Matrix barcode.
    /// </summary>

    public enum DataMatrixPolarity
    {
        //==========================================================================================
        /// <summary>
        /// Sets the method to determine the Data Matrix barcode polarity automatically. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes with dark data on a bright background. 
        /// </summary>

        BlackDataOnWhiteBackground = 0,
        //==========================================================================================
        /// <summary>
        /// Sets the method to read Data Matrix barcodes with bright data on a dark background. 
        /// </summary>

        WhiteDataOnBlackBackground = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the fill percentage for a cell that is in the "on" state.
    /// </summary>

    public enum DataMatrixCellFillMode
    {
        //==========================================================================================
        /// <summary>
        /// Sets the function to determine the Data Matrix barcode cell fill percentage automatically. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// Sets the function to read Data Matrix barcodes with a cell fill percentage of less than 30 percent. 
        /// </summary>

        Low = 0,
        //==========================================================================================
        /// <summary>
        /// Sets the function to read Data Matrix barcodes with a cell fill percentage greater than or equal to 30 percent. 
        /// </summary>

        Normal = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies if the Data Matrix barcode appears normally in the image or if the Data Matrix barcode appears mirrored in the image.
    /// </summary>

    public enum DataMatrixMirrorMode
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the method should determine if the Data Matrix barcode is mirrored. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method should expect the Data Matrix barcode to appear normal. 
        /// </summary>

        Normal = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method should expect the Data Matrix barcode to appear mirrored. 
        /// </summary>

        Mirrored = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the amount of Data Matrix barcode rotation the method should allow for.
    /// </summary>

    public enum DataMatrixRotationMode
    {
        //==========================================================================================
        /// <summary>
        /// The method allows for unlimited rotation.
        /// </summary>

        Unlimited = 0,
        //==========================================================================================
        /// <summary>
        /// The method allows for between -5 and 5 degrees of rotation. 
        /// </summary>

        Degrees0 = 1,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 85 and 95 degrees of rotation.
        /// </summary>

        Degrees90 = 2,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 175 and 185 degrees of rotation. 
        /// </summary>

        Degrees180 = 3,
        //==========================================================================================
        /// <summary>
        /// The method allows for between 265 and 275 degrees of rotation.
        /// </summary>

        Degrees270 = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the mode the method should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode.
    /// </summary>

    public enum DataMatrixDemodulationMode
    {
        //==========================================================================================
        /// <summary>
        /// The method will try each demodulation mode and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The method uses a histogram of all of the Data Matrix cells to calculate a threshold. This threshold determines if a cell is on or off. This is the fastest mode, but requires images with consistent levels of contrast. 
        /// </summary>

        Histogram = 0,
        //==========================================================================================
        /// <summary>
        /// The method examines each of the cell's neighbors to determine if the cell is on or off. This mode is slower, but works with images that have inconsistent levels of contrast. 
        /// </summary>

        LocalContrast = 1,
        //==========================================================================================
        /// <summary>
        /// The function uses the histogram of the Data Matrix barcode to calculate a threshold. For cells with pixel values 
        /// that are sufficiently below or above this threshold, the function will use the threshold to determine if the cell 
        /// is on or off. If the cell pixel values are close to the threshold, the function will use the LocalContrast mode to 
        /// determine if the cell is on or off. This mode is slower, but works with images that contain a Data Matrix barcode 
        /// with extremely low cell fill percentages or gross print growth errors. 
        /// </summary>

        Combined = 2,
        //==========================================================================================
        /// <summary>
        /// The method tries Histogram, then LocalContrast and then Combined, stopping once one mode is successful. 
        /// </summary>

        All = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the sample size, in pixels, the function should take to determine if each cell is on or off.
    /// </summary>

    public enum DataMatrixCellSampleSize
    {
        //==========================================================================================
        /// <summary>
        /// The function will try each sample size and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The function will use a 1 x 1 sized sample from each cell. 
        /// </summary>

        Size1x1 = 1,
        //==========================================================================================
        /// <summary>
        /// The function will use a 2 x 2 sized sample from each cell. 
        /// </summary>

        Size2x2 = 2,
        //==========================================================================================
        /// <summary>
        /// The function will use a 3 x 3 sized sample from each cell. 
        /// </summary>

        Size3x3 = 3,
        //==========================================================================================
        /// <summary>
        /// The function will use a 4 x 4 sized sample from each cell. 
        /// </summary>

        Size4x4 = 4,
        //==========================================================================================
        /// <summary>
        /// The function will use a 5 x 5 sized sample from each cell. 
        /// </summary>

        Size5x5 = 5,
        //==========================================================================================
        /// <summary>
        /// The function will use a 6 x 6 sized sample from each cell. 
        /// </summary>

        Size6x6 = 6,
        //==========================================================================================
        /// <summary>
        /// The function will use a 7 x 7 sized sample from each cell. 
        /// </summary>

        Size7x7 = 7
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the mode the function uses to determine the pixel value for each cell.
    /// </summary>

    public enum DataMatrixCellFilterMode
    {
        //==========================================================================================
        /// <summary>
        /// The function will try all filter modes and uses the one that decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </summary>

        AutoDetect = -2,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average of the sampled pixels. 
        /// </summary>

        Average = 0,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the median of the sampled pixels. 
        /// </summary>

        Median = 1,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average of the pixels in the center of the cell sample. 
        /// </summary>

        CentralAverage = 2,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the highest pixel values. 
        /// </summary>

        HighAverage = 3,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the lowest pixel values. 
        /// </summary>

        LowAverage = 4,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values. 
        /// </summary>

        VeryHighAverage = 5,
        //==========================================================================================
        /// <summary>
        /// The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the lowest pixel values. 
        /// </summary>

        VeryLowAverage = 6,
        //==========================================================================================
        /// <summary>
        /// The function tries each filter mode, starting with Average and ending with VeryLowAverage, stopping once a filter mode decodes correctly. 
        /// </summary>

        All = 8
    }

    /// <summary>
    /// Specifies the mode to use to determine the pixel value for each cell.
    /// </summary>

    public enum DataMatrixAdvancedProcessing
    {
        StartOfProcessing = -1,
        /// <summary>
        /// Enables the line detection algorithm. Use LineDetection if the image has a cluttered background.
        /// </summary>

        LineDetection = 0,
        /// <summary>
        /// Enables the highlight filter. Use the Highlight Filter if the image is blurry or has low contrast.
        /// </summary>

        HighlightFilter = 1,
        /// <summary>
        /// Enables aggressive reading. Aggressive reading returns the decoded code immediately without minimizing detected errors.
        /// </summary>

        AggressiveProcessing = 2,
        /// <summary>
        /// Enables decoding of FNC1 characters. Use this option if the data matrix code is GS1 compliant and encoded with FNC1 and Group Separators.
        /// </summary>

        EnableFNC1 = 3,
        /// <summary>
        /// Enables refining the location of the bounding box. Use this option for a more consistent and accurate location.
        /// </summary>

        RefineBoundingBox = 4,
        EndOfProcessing = 5,
        MAKE_SURE_AdvancedProcessing_IS_AN_INT = 2147483647  /* maximum (signed) int value */
    }

    //==============================================================================================
    /// <summary>
    /// Describes the letter grade assigned to a Data Matrix barcode based on the AIM Print Quality standard, 
    /// where A represents the best grade and F represents the worst grade.
    /// </summary>

    public enum AimGrade
    {
        //==========================================================================================
        /// <summary>
        /// Assigns the Data Matrix barcode a grade of F.
        /// </summary>

        F = 0,
        //==========================================================================================
        /// <summary>
        /// Assigns the Data Matrix barcode a grade of D.
        /// </summary>

        D = 1,
        //==========================================================================================
        /// <summary>
        /// Assigns the Data Matrix barcode a grade of C.
        /// </summary>

        C = 2,
        //==========================================================================================
        /// <summary>
        /// Assigns the Data Matrix barcode a grade of B.
        /// </summary>

        B = 3,
        //==========================================================================================
        /// <summary>
        /// Assigns the Data Matrix barcode a grade of A.
        /// </summary>

        A = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the direction in which the method searches for edges along the search lines.
    /// </summary>

    public enum ConcentricRakeDirection
    {
        //==========================================================================================
        /// <summary>
        /// Searches for edges in a counter-clockwise direction.
        /// </summary>

        CounterClockwise = 0,
        //==========================================================================================
        /// <summary>
        /// Searches for edges in a clockwise direction.
        /// </summary>

        Clockwise = 1
    }

    //==============================================================================================
    /// <summary>
    /// Defines the edges for which the method looks.
    /// </summary>

    public enum EdgeProcess
    {
        //==========================================================================================
        /// <summary>
        /// The method looks for the first edge. 
        /// </summary>

        First = 0,
        //==========================================================================================
        /// <summary>
        /// The method looks for the first and last edge. 
        /// </summary>

        FirstAndLast = 1,
        //==========================================================================================
        /// <summary>
        /// The method looks for all edges. 
        /// </summary>

        All = 2,
        //==========================================================================================
        /// <summary>
        /// The method looks for the best edge. 
        /// </summary>

        Best = 3
    }

    //==============================================================================================
    /// <summary>
    /// Determines the polarity of edges to search for.
    /// </summary>

    public enum EdgePolaritySearchMode
    {
        //==========================================================================================
        /// <summary>
        /// Searches for all edges. 
        /// </summary>

        All = 0,
        //==========================================================================================
        /// <summary>
        /// Searches for rising edges only. 
        /// </summary>

        Rising = 1,
        //==========================================================================================
        /// <summary>
        /// Searches for falling edges only. 
        /// </summary>

        Falling = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the polarity of an edge.
    /// </summary>

    public enum EdgePolarity
    {
        //==========================================================================================
        /// <summary>
        /// The edge is a falling edge.
        /// </summary>

        Falling = 0,
        //==========================================================================================
        /// <summary>
        /// The edge is a rising edge.
        /// </summary>

        Rising = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method processes the data extracted for edge detection.
    /// </summary>

    public enum ColumnProcessingMode
    {
        //==========================================================================================
        /// <summary>
        /// Averages the data extracted for edge detection. 
        /// </summary>

        Average = 0,
        //==========================================================================================
        /// <summary>
        /// Takes the median of the data extracted for edge detection. 
        /// </summary>

        Median = 1
    }

    //==============================================================================================
    /// <summary>
    /// Defines the way the method performs the local threshold.
    /// </summary>

    public enum LocalThresholdMethod
    {
        //==========================================================================================
        /// <summary>
        /// The method computes thresholds for each pixel based on its local statistics using the Niblack local thresholding algorithm. 
        /// </summary>

        NiBlack = 0,
        //==========================================================================================
        /// <summary>
        /// The method performs background correction first to eliminate non-uniform lighting effects, then performs thresholding using the Otsu thresholding algorithm. 
        /// </summary>

        BackgroundCorrection = 1
    }

    //==============================================================================================
    /// <summary>
    /// The morphological transformation the function applies. For more information about 
    /// morphological transformations, refer to the <format type="italics">Binary Morphology</format> topic 
    /// in the <format type="italics">NI Vision Concepts Help</format>.
    /// </summary>

    public enum MorphologyMethod
    {
        //==========================================================================================
        /// <summary>
        /// Uses dual combinations of openings and closings to generate simpler particles that have fewer details.
        /// </summary>

        AutoMedian = 0,
        //==========================================================================================
        /// <summary>
        /// A dilation followed by an erosion.
        /// </summary>

        Close = 1,
        //==========================================================================================
        /// <summary>
        /// Eliminates tiny holes isolated in particles and expands the contour of the particles.
        /// </summary>

        Dilate = 2,
        //==========================================================================================
        /// <summary>
        /// Eliminates isolated background pixels.
        /// </summary>

        Erode = 3,
        //==========================================================================================
        /// <summary>
        /// Extracts inner and outer contours of particles.
        /// </summary>

        Gradient = 4,
        //==========================================================================================
        /// <summary>
        /// Extracts the outer contours of particles.
        /// </summary>

        GradientOut = 5,
        //==========================================================================================
        /// <summary>
        /// Extracts the inner contours of particles.
        /// </summary>

        GradientIn = 6,
        //==========================================================================================
        /// <summary>
        /// Eliminates pixels that do not have the same pattern as the structuring element.
        /// </summary>

        HitMiss = 7,
        //==========================================================================================
        /// <summary>
        /// An erosion followed by a dilation.
        /// </summary>

        Open = 8,
        //==========================================================================================
        /// <summary>
        /// A succession of seven closings and openings.
        /// </summary>

        PClose = 9,
        //==========================================================================================
        /// <summary>
        /// A succession of seven openings and closings.
        /// </summary>

        POpen = 10,
        //==========================================================================================
        /// <summary>
        /// Activates all pixels that match the pattern in the structuring element.
        /// </summary>

        Thick = 11,
        //==========================================================================================
        /// <summary>
        /// Deactivates all pixels that matches the pattern in the structuring element.
        /// </summary>

        Thin = 12
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method calculates the skeleton. For more information about skeleton functions, refer to 
    /// the <format type="italics">Binary Morphology</format> section in 
    /// the <format type="italics">NI Vision Concepts Help</format>.
    /// </summary>

    public enum SkeletonMethod
    {
        //==========================================================================================
        /// <summary>
        /// Uses an L-shaped structuring element in the skeleton function. 
        /// </summary>

        L = 0,
        //==========================================================================================
        /// <summary>
        /// Uses an M-shaped structuring element in the skeleton function. 
        /// </summary>

        M = 1,
        //==========================================================================================
        /// <summary>
        /// Uses an L-shaped structuring element on an inverse of the image in the skeleton function. 
        /// </summary>

        Inverse = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method identifies the locations of the curves in the image.
    /// </summary>

    public enum ExtractionMode
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the method makes no assumptions about the uniformity of objects in the image or the image background. 
        /// </summary>

        NormalImage = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method assumes that either the objects in the image or the image background consists of 
        /// uniform pixel values. This allows the method to more accurately calculate the external curves of the objects. 
        /// </summary>

        UniformRegions = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the width of the edge filter the function uses to identify curves in the image.
    /// </summary>

    public enum EdgeFilterSize
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the method uses a fine, or narrow, edge filter.
        /// </summary>

        Fine = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method uses a normal edge filter.
        /// </summary>

        Normal = 1,
        //==========================================================================================
        /// <summary>
        /// Sets the Edge Filter Size to contour tracing, which provides the best results for contour extraction but increases the time required to process the image.
        /// </summary>

        ContourTracing = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies which mean line profiles the method calculates. Use bitwise-OR to combine two or more values in order to calculate multiple mean line profiles with one function call.
    /// </summary>

    [Flags]
    public enum LinearAveragesModes
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculate no mean line profiles.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculates the mean pixel value of each column.
        /// </summary>

        ColumnAverages = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculates the mean pixel value of each row.
        /// </summary>

        RowAverages = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculates the mean pixel value of each diagonal running from the lower left to the upper right of the inspected area of the image.
        /// </summary>

        RisingDiagonalAverages = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculates the mean pixel value of each diagonal running 
        /// from the upper left to the lower right of the inspected area of the image.
        /// </summary>

        FallingDiagonalAverages = 8,
        //==========================================================================================
        /// <summary>
        /// Specifies that the method calculates all four linear mean pixel values. 
        /// </summary>

        AllLinearAverages = 15
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the type of symmetry to use.
    /// </summary>

    public enum SymmetryOperation
    {
        //==========================================================================================
        /// <summary>
        /// Flips the image over the central horizontal axis.
        /// </summary>

        Horizontal = 0,
        //==========================================================================================
        /// <summary>
        /// Flips the image over the central vertical axis.
        /// </summary>

        Vertical = 1,
        //==========================================================================================
        /// <summary>
        /// Flips the image over both the central vertical and central horizontal axes.
        /// </summary>

        Central = 2,
        //==========================================================================================
        /// <summary>
        /// Flips the image over an axis from the upper left corner to lower right corner.
        /// </summary>

        DiagonalLeftToRight = 3,
        //==========================================================================================
        /// <summary>
        /// Flips the image over an axis from the upper right corner to lower left corner.
        /// </summary>

        DiagonalRightToLeft = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the orientation of a resulting rectangular image relative to an annulus.
    /// </summary>

    public enum RectangleOrientation
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the base of the rectangular image lies along the inside edge of the annulus. 
        /// </summary>

        BaseInside = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the base of the rectangular image lies along the outside edge of the annulus. 
        /// </summary>

        BaseOutside = 1
    }

    //==============================================================================================
    /// <summary>
    /// Defines the 3D orientation.
    /// </summary>

    public enum Direction3D
    {
        //==========================================================================================
        /// <summary>
        /// The viewing angle for the 3D image is from the northwest. 
        /// </summary>

        NorthWest = 0,
        //==========================================================================================
        /// <summary>
        /// The viewing angle for the 3D image is from the southwest. 
        /// </summary>

        SouthWest = 1,
        //==========================================================================================
        /// <summary>
        /// The viewing angle for the 3D image is from the southeast. 
        /// </summary>

        SouthEast = 2,
        //==========================================================================================
        /// <summary>
        /// The viewing angle for the 3D image is from the northeast. 
        /// </summary>

        NorthEast = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the view a method uses to show complex images.
    /// </summary>

    public enum Plane3D
    {
        //==========================================================================================
        /// <summary>
        /// The method shows the real part of complex images. 
        /// </summary>

        Real = 0,
        //==========================================================================================
        /// <summary>
        /// The method shows the imaginary part of complex images. 
        /// </summary>

        Imaginary = 1,
        //==========================================================================================
        /// <summary>
        /// The method shows the magnitude part of complex images. 
        /// </summary>

        Magnitude = 2,
        //==========================================================================================
        /// <summary>
        /// The method shows the phase part of complex images. 
        /// </summary>

        Phase = 3
    }

    //==============================================================================================
    /// <summary>
    /// The transform function a method uses.
    /// </summary>

    public enum MathLookupOperator
    {
        //==========================================================================================
        /// <summary>
        /// The method uses linear remapping.
        /// </summary>

        Linear = 0,
        //==========================================================================================
        /// <summary>
        /// The method uses logarithmic remapping. Enhances contrast for small pixel values and reduces contrast for large pixel values. 
        /// </summary>

        Log = 1,
        //==========================================================================================
        /// <summary>
        /// The method uses exponential remapping. Enhances contrast for large pixel values and reduces contrast for small pixel values. 
        /// </summary>

        Exp = 2,
        //==========================================================================================
        /// <summary>
        /// The method uses square remapping. Similar to exponential remapping but with a more gradual effect. 
        /// </summary>

        Square = 3,
        //==========================================================================================
        /// <summary>
        /// The method uses square root remapping. Similar to logarithmic remapping but with a more gradual effect. 
        /// </summary>

        SquareRoot = 4,
        //==========================================================================================
        /// <summary>
        /// The method uses power X remapping. Causes variable effect depending on power. 
        /// </summary>

        PowX = 5,
        //==========================================================================================
        /// <summary>
        /// The method uses power 1/X remapping. Causes variable effects depending on power. 
        /// </summary>

        Pow1X = 6
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method compares images.
    /// </summary>

    public enum ComparisonFunction
    {
        //==========================================================================================
        /// <summary>
        /// The comparison is true if the source pixel value is less than the comparison image pixel value. 
        /// </summary>

        ClearLess = 0,
        //==========================================================================================
        /// <summary>
        /// The comparison is true if the source pixel value is less than or equal to the comparison image pixel value. 
        /// </summary>

        ClearLessOrEqual = 1,
        //==========================================================================================
        /// <summary>
        /// The comparison is true if the source pixel value is equal to the comparison image pixel value. 
        /// </summary>

        ClearEqual = 2,
        //==========================================================================================
        /// <summary>
        /// The comparison is true if the source pixel value is greater than or equal to the comparison image pixel value. 
        /// </summary>

        ClearGreaterOrEqual = 3,
        //==========================================================================================
        /// <summary>
        /// The comparison is true if the source pixel value is greater than the comparison image pixel value. 
        /// </summary>

        ClearGreater = 4
    }

    //==============================================================================================
    /// <summary>
    /// Determines if the method detects peaks or detects valleys.
    /// </summary>

    public enum PeakOrValley
    {
        //==========================================================================================
        /// <summary>
        /// The method searches for peaks.
        /// </summary>

        Peaks = 0,
        //==========================================================================================
        /// <summary>
        /// The method searches for valleys.
        /// </summary>

        Valleys = 1,
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the direction the method follows to search for edges along the search lines. 
    /// </summary>

    public enum RakeDirection
    {
        //==========================================================================================
        /// <summary>
        /// The method searches from the left side of the search area to the right side of the search area. 
        /// </summary>

        LeftToRight = 0,
        //==========================================================================================
        /// <summary>
        /// The method searches from the right side of the search area to the left side of the search area. 
        /// </summary>

        RightToLeft = 1,
        //==========================================================================================
        /// <summary>
        /// The method searches from the top side of the search area to the bottom side of the search area. 
        /// </summary>

        TopToBottom = 2,
        //==========================================================================================
        /// <summary>
        /// The method searches from the bottom side of the search area to the top side of the search area. 
        /// </summary>

        BottomToTop = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options that are used to detect straight edges.
    /// </summary>

    public enum StraightEdgeSearchMode
    {
        //==========================================================================================
        /// <summary>
        /// Fits a straight edge on the first points detected using a rake. 
        /// </summary>

        FirstRakeEdges = 0,
        //==========================================================================================
        /// <summary>
        /// Fits a straight edge on the best points detected using a rake. 
        /// </summary>

        BestRakeEdges = 1,
        //==========================================================================================
        /// <summary>
        /// Finds the strongest straight edge using all points detected on a rake. 
        /// </summary>

        BestHoughLine = 2,
        //==========================================================================================
        /// <summary>
        /// Uses the location of the first projected edge as the straight edge. 
        /// </summary>

        FirstProjectionEdge = 3,
        //==========================================================================================
        /// <summary>
        /// Finds the strongest projected edge location to determine the straight edge. 
        /// </summary>

        BestProjectionEdge = 4
    }

    //==============================================================================================
    /// <summary>
    /// The direction to search for the primary axis and the expected orientation of the primary axis.
    /// </summary>

    public enum FindReferenceDirection
    {
        //==========================================================================================
        /// <summary>
        /// Searches from the left side of the search area to the right side of the search area for a direct axis. 
        /// </summary>

        LeftToRightDirect = 0,
        //==========================================================================================
        /// <summary>
        /// Searches from the left side of the search area to the right side of the search area for an indirect axis. 
        /// </summary>

        LeftToRightIndirect = 1,
        //==========================================================================================
        /// <summary>
        /// Searches from the top of the search area to the bottom of the search area for a direct axis. 
        /// </summary>

        TopToBottomDirect = 2,
        //==========================================================================================
        /// <summary>
        /// Searches from the top of the search area to the bottom of the search area for an indirect axis. 
        /// </summary>

        TopToBottomIndirect = 3,
        //==========================================================================================
        /// <summary>
        /// Searches from the right side of the search area to the left side of the search area for a direct axis. 
        /// </summary>

        RightToLeftDirect = 4,
        //==========================================================================================
        /// <summary>
        /// Searches from the right side of the search area to the left side of the search area for an indirect axis. 
        /// </summary>

        RightToLeftIndirect = 5,
        //==========================================================================================
        /// <summary>
        /// Searches from the bottom of the search area to the top of the search area for a direct axis. 
        /// </summary>

        BottomToTopDirect = 6,
        //==========================================================================================
        /// <summary>
        /// Searches from the bottom of the search area to the top of the search area for an indirect axis. 
        /// </summary>

        BottomToTopIndirect = 7
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how a function updates a coordinate transform.
    /// </summary>

    public enum FindTransformMode
    {
        //==========================================================================================
        /// <summary>
        /// Update both parts of the coordinate system. 
        /// </summary>

        FindReference = 0,
        //==========================================================================================
        /// <summary>
        /// Update only the new reference system. 
        /// </summary>

        UpdateTransform = 1
    }

    //==============================================================================================
    /// <summary>
    /// Determines how the method evaluates the threshold and hysteresis values.
    /// </summary>

    public enum LevelType
    {
        //==========================================================================================
        /// <summary>
        /// The method evaluates the threshold and hysteresis values as absolute values. 
        /// </summary>

        Absolute = 0,
        //==========================================================================================
        /// <summary>
        /// The method evaluates the threshold and hysteresis values relative to the dynamic range of the given path. 
        /// </summary>

        Relative = 1
    }

    //==============================================================================================
    /// <summary>
    /// Determines the direction in which the Region of Interest (ROI) is examined when edge detection is performed.
    /// </summary>

    public enum SearchDirection
    {
        //==========================================================================================
        /// <summary>
        /// Searches from the left of the ROI to the right.
        /// </summary>

        LeftToRight = 0,
        //==========================================================================================
        /// <summary>
        /// Searches from the right of the ROI to the left.
        /// </summary>

        RightToLeft = 1,
        //==========================================================================================
        /// <summary>
        /// Searches from the top of the ROI to the bottom.
        /// </summary>

        TopToBottom = 2,
        //==========================================================================================
        /// <summary>
        /// Searches from the bottom of the ROI to the top.
        /// </summary>

        BottomToTop = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the direction the method follows to search for edges along the search lines.
    /// </summary>

    public enum SpokeDirection
    {
        //==========================================================================================
        /// <summary>
        /// The method searches from the outside of the search area to the inside of the search area. 
        /// </summary>

        OutsideToInside = 0,
        //==========================================================================================
        /// <summary>
        /// The method searches from the inside of the search area to the outside of the search area. 
        /// </summary>

        InsideToOutside = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the Rake Process type the Edge Detection functions can use.
    /// </summary>

    public enum RakeProcessType
    {
        //==========================================================================================
        /// <summary>
        /// Get First Edges process type. 
        /// </summary>

        GetFirstEdges = 0,
        //==========================================================================================
        /// <summary>
        /// Get First and Last Edges process type. 
        /// </summary>

        GetFirstAndLastEdges = 1,
        //==========================================================================================
        /// <summary>
        /// Get All Edges process type. 
        /// </summary>

        GetAllEdges = 2,
        //==========================================================================================
        /// <summary>
        /// Get Best Edges process type. 
        /// </summary>

        GetBestEdges = 3
    }

    //==============================================================================================
    /// <summary>
    /// Controls which frequencies a function attenuates.
    /// </summary>

    public enum AttenuateMode
    {
        //==========================================================================================
        /// <summary>
        /// The function attenuates low frequencies. 
        /// </summary>

        Low = 0,
        //==========================================================================================
        /// <summary>
        /// The function attenuates high frequencies. 
        /// </summary>

        High = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies which frequencies the method truncates.
    /// </summary>

    public enum TruncateMode
    {
        //==========================================================================================
        /// <summary>
        /// The method truncates low frequencies. 
        /// </summary>

        Low = 0,
        //==========================================================================================
        /// <summary>
        /// The method truncates high frequencies. 
        /// </summary>

        High = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the complexity of the color information in the image. In most cases, set this parameter to 
    /// Low. However, set this parameter to High to use more information and better distinguish colors in highly 
    /// complex images. As complexity increases, so does sensitivity. Two similar colors that may be identified 
    /// as being the same with Low may be identified as different colors with High. Refer to the 
    /// <format type="italics">NI Vision Concepts Help</format> for more information about color sensitivity.
    /// </summary>

    public enum ColorSensitivity
    {
        //==========================================================================================
        /// <summary>
        /// Instructs the algorithm to divide the hue plane into a low number of sectors, allowing for simple color analysis. 
        /// </summary>

        Low = 0,
        //==========================================================================================
        /// <summary>
        /// Instructs the algorithm to divide the hue plane into a medium number of sectors, allowing for color analysis that balances sensitivity and complexity. 
        /// </summary>

        Medium = 1,
        //==========================================================================================
        /// <summary>
        /// Instructs the algorithm to divide the hue plane into a high number of sectors, allowing for complex, sensitive color analysis. 
        /// </summary>

        High = 2
    }

    //==============================================================================================
    /// <summary>
    /// Sets the color of the font.
    /// </summary>

    public enum FontColor
    {
        //==========================================================================================
        /// <summary>
        /// Draws text in white. 
        /// </summary>

        White = 0,
        //==========================================================================================
        /// <summary>
        /// Draws text in black. 
        /// </summary>

        Black = 1,
        //==========================================================================================
        /// <summary>
        /// Inverts the text pixels. 
        /// </summary>

        Invert = 2,
        //==========================================================================================
        /// <summary>
        /// Draws text in black with a white background. 
        /// </summary>

        BlackOnWhite = 3,
        //==========================================================================================
        /// <summary>
        /// Draws text in white with a black background. 
        /// </summary>

        WhiteOnBlack = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how the method outlines edges.
    /// </summary>

    public enum OutlineMethod
    {
        //==========================================================================================
        /// <summary>
        /// Produces continuous contours by highlighting each pixel where an intensity variation occurs between itself and its three upper-left neighbors. 
        /// </summary>

        Difference = 0,
        //==========================================================================================
        /// <summary>
        /// Outlines contours where an intensity variation occurs along the vertical axis. 
        /// </summary>

        Gradient = 1,
        //==========================================================================================
        /// <summary>
        /// Extracts the outer contours of objects. 
        /// </summary>

        Prewitt = 2,
        //==========================================================================================
        /// <summary>
        /// Outlines the contours that highlight pixels where an intensity variation occurs along the diagonal axes. 
        /// </summary>

        Roberts = 3,
        //==========================================================================================
        /// <summary>
        /// Outlines contours and details by setting pixels to the mean value found in their neighborhood, if their deviation from this value is not significant. 
        /// </summary>

        Sigma = 4,
        //==========================================================================================
        /// <summary>
        /// Extracts the outer contours of objects. As opposed to the Prewitt filter, the Sobel filter assigns a higher weight to the horizontal and vertical neighbors of the central pixel. 
        /// </summary>

        Sobel = 5
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the color of the meter background and needle.
    /// </summary>

    public enum MeterNeedleColor
    {
        //==========================================================================================
        /// <summary>
        /// The meter has a dark-colored needle on a light background.
        /// </summary>

        DarkOnLight = 0,
        //==========================================================================================
        /// <summary>
        /// The meter has a light-colored needle on a dark background.
        /// </summary>

        LightOnDark = 1
    }

    //==============================================================================================
    /// <summary>
    /// Specifies which features from the color pattern the method uses.
    /// </summary>

    public enum ImageFeatureMode
    {
        //==========================================================================================
        /// <summary>
        /// Instructs the method to use the color and the shape features of the color pattern. 
        /// </summary>

        ColorAndShape = 0,
        //==========================================================================================
        /// <summary>
        /// Instructs the method to use the color features of the color pattern. 
        /// </summary>

        Color = 1,
        //==========================================================================================
        /// <summary>
        /// Instructs the method to use the shape features of the color pattern. 
        /// </summary>

        Shape = 2
    }

    //==============================================================================================
    /// <summary>
    /// Specifies whether the function excludes certain colors from the color features of the template image. Any color the function excludes during the learning process is also excluded in the match phase.
    /// </summary>

    public enum ColorIgnoreMode
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the function does not ignore any pixels. 
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the function ignores black pixels. 
        /// </summary>

        Black = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies that the function ignores white pixels. 
        /// </summary>

        White = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the function ignores black pixels and white pixels. 
        /// </summary>

        BlackAndWhite = 3
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the search mode the method uses to look for the template image in the image.
    /// </summary>

    [Flags]
    public enum GeometricMatchModes
    {
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the template image in the inspection image, assuming that the template image is not rotated more than  5 degrees.
        /// </summary>

        ShiftInvariant = 0,
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the template image in the inspection image with reduced restriction on the rotation of the template image.
        /// </summary>

        RotationInvariant = 1,
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the template image in the inspection image with reduced restriction on the size of the template image.
        /// </summary>

        ScaleInvariant = 2,
        //==========================================================================================
        /// <summary>
        /// Searches for occurrences of the template image in the inspection image, allowing for a specified percentage of the template image to be occluded.
        /// </summary>

        OcclusionInvariant = 4
    }

    //==============================================================================================
    /// <summary>
    /// Specifies whether to take pixel measurements or calibrated measurements on a particle.
    /// </summary>

    public enum ParticleMeasurementsCalibrationMode
    {
        //==========================================================================================
        /// <summary>
        /// Takes pixel measurements on the particle.
        /// </summary>

        Pixel = 0,
        //==========================================================================================
        /// <summary>
        /// Takes calibrated measurements on the particle.
        /// </summary>

        Calibrated = 1,
        //==========================================================================================
        /// <summary>
        /// Takes pixel measurements and calibrated measurements on the particle.
        /// </summary>

        Both = 2
    }

    //==============================================================================================
    /// <summary>
    /// Describes the type of geometric feature.
    /// </summary>

    public enum GeometricFeatureType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature was not found.
        /// </summary>

        None = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.CircleFeature" crefType="Unqualified"/>.
        /// </summary>

        Circle = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.EllipseFeature" crefType="Unqualified"/>.
        /// </summary>

        Ellipse = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.ConstCurveFeature" crefType="Unqualified"/>.
        /// </summary>

        ConstCurve = 3,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.RectangleFeature" crefType="Unqualified"/>.
        /// </summary>

        Rectangle = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.LegFeature" crefType="Unqualified"/>.
        /// </summary>

        Leg = 5,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.CornerFeature" crefType="Unqualified"/>.
        /// </summary>

        Corner = 6,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.ParallelLinePairFeature" crefType="Unqualified"/>.
        /// </summary>

        ParallelLinePair = 7,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.PairOfParallelLinePairsFeature" crefType="Unqualified"/>.
        /// </summary>

        PairOfParallelLinePairs = 8,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.LineFeature" crefType="Unqualified"/>.
        /// </summary>

        Line = 9,
        //==========================================================================================
        /// <summary>
        /// Specifies that the feature data should be cast to a <see cref="NationalInstruments.Vision.Analysis.ClosedCurveFeature" crefType="Unqualified"/>.
        /// </summary>

        ClosedCurve = 10
    }

    //==========================================================================================
    /// <summary>
    /// Specifies the Wavelet Type
    /// </summary>

    public enum WaveletType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB02
        /// </summary>

        DB02 = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB03
        /// </summary>

        DB03 = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB04
        /// </summary>

        DB04 = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB05
        /// </summary>

        DB05 = 3,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB06
        /// </summary>

        DB06 = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB07
        /// </summary>

        DB07 = 5,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB08
        /// </summary>

        DB08 = 6,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB09
        /// </summary>

        DB09 = 7,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB10
        /// </summary>

        DB10 = 8,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB11
        /// </summary>

        DB11 = 9,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB12
        /// </summary>

        DB12 = 10,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB13
        /// </summary>

        DB13 = 11,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type DB14
        /// </summary>

        DB14 = 12,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Haar
        /// </summary>

        Haar = 13,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior1_3
        /// </summary>

        Bior1_3 = 14,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior1_5
        /// </summary>

        Bior1_5 = 15,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior2_2
        /// </summary>

        Bior2_2 = 16,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior2_4
        /// </summary>

        Bior2_4 = 17,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior2_6
        /// </summary>

        Bior2_6 = 18,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior2_8
        /// </summary>

        Bior2_8 = 19,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior3_1
        /// </summary>

        Bior3_1 = 20,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior3_3
        /// </summary>

        Bior3_3 = 21,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior3_5
        /// </summary>

        Bior3_5 = 22,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior3_7
        /// </summary>

        Bior3_7 = 23,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior3_9
        /// </summary>

        Bior3_9 = 24,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior4_4
        /// </summary>

        Bior4_4 = 25,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Coif1
        /// </summary>

        Coif1 = 26,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Coif2
        /// </summary>

        Coif2 = 27,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Coif3
        /// </summary>

        Coif3 = 28,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Coif4
        /// </summary>

        Coif4 = 29,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Coif5
        /// </summary>

        Coif5 = 30,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym2
        /// </summary>

        Sym2 = 31,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym3
        /// </summary>

        Sym3 = 32,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym4
        /// </summary>

        Sym4 = 33,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym5
        /// </summary>

        Sym5 = 34,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym6
        /// </summary>

        Sym6 = 35,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym7
        /// </summary>

        Sym7 = 36,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Sym8
        /// </summary>

        Sym8 = 37,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior5_5
        /// </summary>

        Bior5_5 = 38,
        //==========================================================================================
        /// <summary>
        /// Specifies the Wavelet Type Bior6_8
        /// </summary>

        Bior6_8 = 39
    }

    //==========================================================================================
    /// <summary>
    /// Specifies the Cooccurrence Feature
    /// </summary>

    public enum CooccurrenceFeature
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the dissimilarity feature
        /// </summary>

        FeatureDissimilarity,
        //==========================================================================================
        /// <summary>
        /// Specifies the contrast feature
        /// </summary>

        FeatureContrast,
        //==========================================================================================
        /// <summary>
        /// Specifies the entropy feature
        /// </summary>

        FeatureEntropy,
        //==========================================================================================
        /// <summary>
        /// Specifies the homogeneity feature
        /// </summary>

        FeatureHomogeneity,
        //==========================================================================================
        /// <summary>
        /// Specifies the correlation feature
        /// </summary>

        FeatureCorrelation,
        //==========================================================================================
        /// <summary>
        /// Specifies the energy feature
        /// </summary>

        FeatureEnergy,
        //==========================================================================================
        /// <summary>
        /// Specifies the peak feature
        /// </summary>

           FeaturePeak,
    }

	//==========================================================================================
    /// <summary>
    /// Specifies the Morphological reconstruction operation
    /// </summary>

    public enum MorphologyReconstructOperation
    {
        //==========================================================================================
        /// <summary>
        /// Reconstruction by dilation
        /// </summary>

        DilateReconstruct,
        //==========================================================================================
        /// <summary>
        /// Reconstruction by erosion
        /// </summary>

        ErodeReconstruct,
    }

    //==========================================================================================
    /// <summary>
    /// Specifies the direction in which the Region of Interest (ROI) is examined
    /// </summary>

    public enum ExtractContourDirection
    {
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from left to right
        /// </summary>

        RectLeftRight = 0,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from right to left
        /// </summary>

        RectRightLeft = 1,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from top to bottom.
        /// </summary>

        RectTopBottom = 2,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from bottom to top
        /// </summary>

        RectBottomTop = 3,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from the inner radius to the outer radius
        /// </summary>

        AnnulusInnerOuter = 4,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from the outer radius to the inner radius
        /// </summary>

        AnnulusOuterInner = 5,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from start angle to end angle
        /// </summary>

        AnnulusStartStop = 6,
        //==========================================================================================
        /// <summary>
        /// Searches the ROI from end angle to start angle
        /// </summary>

        AnnulusStopStart = 7,
    }

    //==========================================================================================
    /// <summary>
    /// Contour Selection selects an extracted contour based on the property you choose
    /// </summary>

    public enum ExtractContourSelection
    {
        //==========================================================================================
        /// <summary>
        /// Selects the curve closest to the ROI
        /// </summary>

        Closest = 0,
        //==========================================================================================
        /// <summary>
        /// Selects the curve with maximum length
        /// </summary>

        Longest = 1,
        //==========================================================================================
        /// <summary>
        /// Selects the curve with the highest edge strength averaged from each point on the curve
        /// </summary>

        Strongest = 2,
    }

    //==========================================================================================
    /// <summary>
    /// Type of connection constraint during contour extraction
    /// </summary>

    public enum ConnectionConstraintType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the distance, in pixels, within which the end points of two curves must lie in order to be considered part of a contour
        /// </summary>

        Distance = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the range, in degrees, within which the difference between the angle of two curves, measured at the end points, must lie in order for the two curves to be considered part of a contour
        /// </summary>

        Angle = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the distance, in pixels, within which a line extended from the end point of a curve must pass the end point of another curve in order for the two curves to be considered part of a contour
        /// </summary>

        Connectivity = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies the range, in degrees, within which the gradient angles of two curves, measured at the end points, must lie in order for the two curves to be considered part of a contour
        /// </summary>

        Gradient = 3,
    }

    //==========================================================================================
    /// <summary>
    /// Specifies the match option whose values you want to constrain by the given range
    /// </summary>

    public enum SettingType
    {
        //==========================================================================================
        /// <summary>
        /// Set a range for this option to specify the angles at which you expect the Function to find template matches in the inspection image
        /// </summary>

        RotationAngle = 0,
        //==========================================================================================
        /// <summary>
        /// Set a range for this option to specify the sizes at which you expect the Function to find template matches in the inspection image.
        /// </summary>

        Scale = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the distance, in pixels, within which a line extended from the end point of a curve must pass the end point of another curve in order for the two curves to be considered part of a contour
        /// </summary>

        Occlusion = 2,
    }
    //==========================================================================================
    /// <summary>
    /// Determines the option you want to use during the matching phase
    /// </summary>

    public enum GeometricSetupData
    {
        //==========================================================================================
        /// <summary>
        /// Specifies how the function identifies curves in the image. 
        /// </summary>

        CurveExtractionMode = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the minimum contrast an edge pixel must have for it to be considered part of a curve.
        /// </summary>

        CurveEdgeThreshold = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the width of the edge filter that the function uses to identify curves in the image. 
        /// </summary>

        CurveEdgeFilter = 2,
        //==========================================================================================
        /// <summary>
        /// Specifies the length, in pixels, of the smallest curve that you want the function to identify. 
        /// </summary>

        MinimumCurveLength = 3,
        //==========================================================================================
        /// <summary>
        /// Specifies the distance, in the y direction, between the image rows that the algorithm inspects for curve seed points. 
        /// </summary>

        CurveRowSearchStepSize = 4,
        //==========================================================================================
        /// <summary>
        /// Specifies the distance, in the x direction, between the image columns that the algorithm inspects for curve seed points. 
        /// Valid values range from 1 to 255. The default value is 15. 
        /// </summary>

        CurveColSearchStepSize = 5,
        //==========================================================================================
        /// <summary>
        /// Specifies the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve. 
        /// </summary>

        CurveMaxEndPointGap = 6,
        //==========================================================================================
        /// <summary>
        /// Specifies whether to identify only closed curves in the image. 
        /// </summary>

        ExtractClosedCurves = 7,
        //==========================================================================================
        /// <summary>
        /// The function ignores this option.
        /// </summary>

        EnableSubpixelCurveExtraction = 8,
        //==========================================================================================
        /// <summary>
        /// Specifies that the function should calculate the Correlation Score and return it for each match result. 
        /// </summary>

        EnableCorrelationScore = 9,
        //==========================================================================================
        /// <summary>
        /// Determines whether to return the match results with subpixel accuracy. 
        /// </summary>

        EnableSubpixelAccuracy = 10,
        //==========================================================================================
        /// <summary>
        /// Specifies the maximum number of incremental improvements used to refine matches using subpixel information.
        /// </summary>

        SubpixelIterations = 11,
        //==========================================================================================
        /// <summary>
        /// Specifies the maximum amount of change, in pixels, between consecutive incremental improvements in the 
        /// match position before the function stops refining the match position.
        /// </summary>

        SubpixelTolerance = 12,
        //==========================================================================================
        /// <summary>
        /// Specifies the maximum size of the match list. 
        /// </summary>

        InitialMatchListLength = 13,
        //==========================================================================================
        /// <summary>
        /// Specifies whether the function should calculate the match curve to template curve score and 
        /// return it for each match result.
        /// </summary>

        EnableTargetTemplateCurveScore = 14,
        //==========================================================================================
        /// <summary>
        /// Specifies the minimum separation distance, in pixels, between the origins of two matches that have unique positions.
        /// </summary>

        MinimumMatchSeparationDistance = 15,
        //==========================================================================================
        /// <summary>
        /// Specifies the minimum angular difference, in degrees, between two matches that have unique angles.
        /// </summary>

        MinimumMatchSeparationAngle = 16,
        //==========================================================================================
        /// <summary>
        /// Specifies the minimum difference in scale, expressed as a percentage, between two matches that have unique scales.
        /// </summary>

        MinimumMatchSeparationScale = 17,
        //==========================================================================================
        /// <summary>
        /// Specifies whether you want the algorithm to spend less time accurately estimating the location of a match.
        /// </summary>

        MaximumMatchOverlap = 18,
        //==========================================================================================
        /// <summary>
        /// Specifies whether you want the algorithm to spend less time accurately estimating the location of a match.
        /// </summary>

        EnableCoarseResult = 19,
        //==========================================================================================
        /// <summary>
        /// Specifies whether or not the algorithm treat the inspection image as a calibrated image.
        /// </summary>

        EnableCalibrationSupport = 20,
        //==========================================================================================
        /// <summary>
        /// Specifies the contrast of the matches to search for.
        /// </summary>

        EnableContrastReversal = 21,
        //==========================================================================================
        /// <summary>
        /// Specifies the aggressiveness of the strategy used to find matches in the image.
        /// </summary>

        SearchStrategy = 22,
        //==========================================================================================
        /// <summary>
        /// Specifies the factor applied to the number of matches requested to determine how many matches are refined in the pyramid stage.
        /// </summary>

        RefinementMatchFactor = 23,
        //==========================================================================================
        /// <summary>
        /// Specifies the factor applied to the number for matches requested to determine how many matches are used for the final (subpixel) stage.
        /// </summary>

        SubpixelMatchFactor = 24,
        //==========================================================================================
        /// <summary>
        /// Specifies maximum refinement iteration.
        /// </summary>

        MaxRefinementIterations = 25
    } 

    //==========================================================================================
    /// <summary>
    /// Specifies the Segmentation Distance Level
    /// </summary>

    public enum SegmentationDistanceLevel
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the Conservative Level
        /// </summary>

        Conservative = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the Conservative Level
        /// </summary>

        Aggressive = 1
    }
    //==========================================================================================
    /// <summary>
    /// Specifies the Calibration Thumbnail Type.
    /// </summary>

    public enum CalibrationThumbnailType
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the Camera model
        /// </summary>

        CameraModelType = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the Perspective model
        /// </summary>

        PerspectiveType = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the Microplane model
        /// </summary>

        MicroPlaneType = 2
    }
    
    //==========================================================================================
    /// <summary>
    /// Specifies the Type of Learned Distortion Model.
    /// </summary>

    public enum DistortionModel
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the Polynomial model
        /// </summary>

        PolynomialModel = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the Division model
        /// </summary>

        DivisionModel = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the Non distortion model
        /// </summary>

        NoDistortionModel = -1
    }
    //==========================================================================================
    /// <summary>
    /// Specifies the Radial Coefficients of Polynomial Model.
    /// </summary>

    public enum RadialCoefficients
    {
        //==========================================================================================
        /// <summary>
        /// Specifies the Coefficient k1
        /// </summary>

        CoeffK1 = 0,
        //==========================================================================================
        /// <summary>
        /// Specifies the Coefficient k1, k2, k3
        /// </summary>

        CoeffK1K2K3 = 1,
        //==========================================================================================
        /// <summary>
        /// Specifies the Coefficient k1, k2, k3, k4, k5
        /// </summary>

        CoeffK1K2K3K4K5 = 2
    }
    //==============================================================================================
    /// <summary>
    /// Provides the location within an image where the golden template is located.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class InspectionAlignment : IEquatable<InspectionAlignment>
    {
        private PointContour _position;
        private double _rotation;
        private double _scale;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the percentage of the size of the area under inspection compared to the size of the golden template.
        /// </summary>
        /// <value>The default value is 100.0.
        /// </value>

        public double Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle of the golden template in the image under inspection.
        /// </summary>
        /// <value>The default value is 0.0.
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the golden template in the image under inspection.
        /// </summary>
        /// <value>The default value is (0,0).
        /// </value>

        public PointContour Position
        {
            get { return _position; }
            set { _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Creates and returns an InspectionAlignment object.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="position">The location of the center of the golden template in the image under inspection.
        /// </param>

        public InspectionAlignment(PointContour position)
            : this(position, 0.0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Creates and returns an InspectionAlignment object.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="position">The location of the center of the golden template in the image under inspection.
        /// </param>
        /// <param name="rotation">The angle of the golden template in the image under inspection.
        /// </param>

        public InspectionAlignment(PointContour position, double rotation)
            : this(position, rotation, 100.0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Creates and returns an InspectionAlignment object.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="position">The location of the center of the golden template in the image under inspection.
        /// </param>
        /// <param name="rotation">The angle of the golden template in the image under inspection.
        /// </param>
        /// <param name="scale">The percentage of the size of the area under inspection compared to the size of the golden template.
        /// </param>

        public InspectionAlignment(PointContour position, double rotation, double scale)
        {
            _position = position;
            _rotation = rotation;
            _scale = scale;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InspectionAlignment.
        /// </summary>
        /// <param name="other">
        /// A InspectionAlignment instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(InspectionAlignment other)
        {
            return other != null && Object.Equals(_position, other._position) && _rotation == other._rotation && _scale == other._scale;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InspectionAlignment.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of InspectionAlignment and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            InspectionAlignment other = (InspectionAlignment)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _scale.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "InspectionAlignment: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture) + ", Scale=" + _scale.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the options used by CompareGoldenTemplate.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class InspectionOptions : IEquatable<InspectionOptions>
    {
        private RegistrationMethod _registrationMethod;
        private NormalizationMethod _normalizationMethod;
        private Int32 _edgeThicknessToIgnore;
        private double _brightThreshold;
        private double _darkThreshold;
        private bool _binary;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InspectionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public InspectionOptions()
            : this(NormalizationMethod.None)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InspectionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="normalizationMethod">Indicates how the function normalizes the golden template to the inspection image.
        /// </param>

        public InspectionOptions(NormalizationMethod normalizationMethod)
            : this(normalizationMethod, RegistrationMethod.None)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InspectionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="normalizationMethod">Indicates how the function normalizes the golden template to the inspection image.
        /// </param>
        /// <param name="registrationMethod">The manner in which the function registers the golden template and the inspection image.
        /// </param>

        public InspectionOptions(NormalizationMethod normalizationMethod, RegistrationMethod registrationMethod)
            : this(normalizationMethod, registrationMethod, 0, 30, 30, true)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InspectionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="normalizationMethod">Indicates how the function normalizes the golden template to the inspection image.
        /// </param>
        /// <param name="registrationMethod">The manner in which the function registers the golden template and the inspection image.
        /// </param>
        /// <param name="edgeThicknessToIgnore">the desired thickness of edges to be ignored. 
        /// </param>
        /// <param name="brightThreshold">Indicates whether the threshold for areas where the inspection image is brighter than the template.
        /// </param>
        /// <param name="darkThreshold">Indicates whether the threshold for areas where the inspection image is darker than the template.
        /// </param>
        /// <param name="binary">Indicates whether the method should return a binary image giving the location of defects or a grayscale image giving the intensity of defects.
        /// </param>

        public InspectionOptions(NormalizationMethod normalizationMethod, RegistrationMethod registrationMethod, Int32 edgeThicknessToIgnore, double brightThreshold, double darkThreshold, bool binary)
        {
            _registrationMethod = registrationMethod;
            _normalizationMethod = normalizationMethod;
            _edgeThicknessToIgnore = edgeThicknessToIgnore;
            _brightThreshold = brightThreshold;
            _darkThreshold = darkThreshold;
            _binary = binary;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should return a binary image giving the location of defects or a grayscale image giving the intensity of defects.
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// Set this property to <see langword="true"/> to return a binary image that specifies the location of the defects. Set this property to <see langword="false"/>  to return a grayscale image that specifies the location and intensity of defects.
        /// </remarks>

        public bool Binary
        {
            get { return _binary; }
            set { _binary = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the threshold for areas where the inspection image is darker than the template.
        /// </summary>
        /// <value>The default value is 30.
        /// </value>

        public double DarkThreshold
        {
            get { return _darkThreshold; }
            set { _darkThreshold = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the threshold for areas where the inspection image is brighter than the template.
        /// </summary>
        /// <value>The default value is 30.
        /// </value>

        public double BrightThreshold
        {
            get { return _brightThreshold; }
            set { _brightThreshold = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the desired thickness of edges to be ignored. 
        /// </summary>
        /// <value>The default value is 0.
        /// </value>
        /// <remarks>
        /// A value of 0 specifies that the algorithm will not ignore edges.
        /// </remarks>

        public Int32 EdgeThicknessToIgnore
        {
            get { return _edgeThicknessToIgnore; }
            set { _edgeThicknessToIgnore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets how the function normalizes the golden template to the inspection image.
        /// </summary>
        /// <value>The default value is None.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// AverageMatchingNormalize image by shifting intensities by the difference in the mean values.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// HistogramMatchingNormalize image using histogram matching.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// NoneNo normalization.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public NormalizationMethod NormalizationMethod
        {
            get { return _normalizationMethod; }
            set { _normalizationMethod = value; }
        }
        //==========================================================================================
        /// <summary>Gets or sets the manner in which the function registers the golden template and the inspection image.
        /// </summary>
        /// <value>The default value is None.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// NoneNo registration.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// PerspectiveRegistrationUse perspective correction registration.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public RegistrationMethod RegistrationMethod
        {
            get { return _registrationMethod; }
            set { _registrationMethod = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InspectionOptions.
        /// </summary>
        /// <param name="other">
        /// A InspectionOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(InspectionOptions other)
        {
            return other != null && _registrationMethod == other._registrationMethod && _normalizationMethod == other._normalizationMethod && _edgeThicknessToIgnore == other._edgeThicknessToIgnore && _brightThreshold == other._brightThreshold && _darkThreshold == other._darkThreshold && _binary == other._binary;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InspectionOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of InspectionOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            InspectionOptions other = (InspectionOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _registrationMethod.GetHashCode() ^ _normalizationMethod.GetHashCode() ^ _edgeThicknessToIgnore.GetHashCode() ^ _darkThreshold.GetHashCode() ^ _brightThreshold.GetHashCode() ^ _binary.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "InspectionOptions: RegistrationMethod=" + _registrationMethod + ", NormalizationMethod=" + _normalizationMethod;
        }
    }

    //==============================================================================================
    /// <summary>
    /// The options to use for subpixel measurements.
    /// </summary>

    [Serializable]
    public sealed class SubPixelOptions : IEquatable<SubPixelOptions>
    {
        private SubPixelAccuracy _accuracy;
        private InterpolationMethod _type;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of samples to obtain from a pixel.
        /// </summary>
        /// <value>
        /// The default is None.
        /// </value>

        public SubPixelAccuracy Accuracy
        {
            get { return _accuracy; }
            set { _accuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the interpolation method.
        /// </summary>
        /// <value>
        /// The default is Quadratic.
        /// </value>

        public InterpolationMethod Type
        {
            get { return _type; }
            set { _type = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SubPixelOptions class.
        /// </summary>

        public SubPixelOptions()
            : this(SubPixelAccuracy.None)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SubPixelOptions class.
        /// </summary>
        /// <param name="accuracy">
        /// Specifies the number of samples to obtain from a pixel.
        /// </param>

        public SubPixelOptions(SubPixelAccuracy accuracy) : this(accuracy, InterpolationMethod.Quadratic)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SubPixelOptions class.
        /// </summary>
        /// <param name="accuracy">
        /// Specifies the number of samples to obtain from a pixel.
        /// </param>
        /// <param name="type">
        /// Specifies the interpolation method to use.
        /// </param>

        public SubPixelOptions(SubPixelAccuracy accuracy, InterpolationMethod type)
        {
            _accuracy = accuracy;
            _type = type;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SubPixelOptions.
        /// </summary>
        /// <param name="other">
        /// A SubPixelOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SubPixelOptions other)
        {
            return other != null && _accuracy == other._accuracy && _type == other._type;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SubPixelOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SubPixelOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SubPixelOptions other = (SubPixelOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _accuracy.GetHashCode() ^ _type.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SubPixelOptions: Accuracy=" + _accuracy + ", Type=" + _type;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains parameters that specify the result of a histogram operation.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class HistogramReport : IEquatable<HistogramReport>
    {
        private Int32 _numPixels;
        private Collection<Int32> _histogram;
        private double _width;
        private double _mean;
        private Range _pixelRange;
        private double _start;
        private double _standardDeviation;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of pixels classified. 
        /// </summary>
        /// <value>
        /// </value>

        public Int32 NumberOfPixels
        {
            get { return _numPixels; }
            set { _numPixels = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets an array that describes the number of pixels in each class.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<Int32> Histogram
        {
            get { return _histogram; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _histogram = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of each class. 
        /// </summary>
        /// <value>
        /// </value>

        public double Width
        {
            get { return _width; }
            set { _width = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the mean value of the classified pixels.
        /// </summary>
        /// <value>
        /// </value>

        public double Mean
        {
            get { return _mean; }
            set { _mean = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of pixel values used in calculating the histogram.
        /// </summary>
        /// <value>
        /// </value>

        public Range PixelRange
        {
            get { return _pixelRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _pixelRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the smallest pixel value in the first class. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// The smallest pixel value may be smaller than <see cref="NationalInstruments.Vision.Analysis.HistogramReport.PixelRange" crefType="PartiallyQualified"/>.
        /// </remarks>

        public double Start
        {
            get { return _start; }
            set { _start = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the standard deviation of the classified pixels.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// The higher this value, the better the distribution of the values in the histogram and the corresponding image.
        /// </remarks>

        public double StandardDeviation
        {
            get { return _standardDeviation; }
            set { _standardDeviation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the HistogramReport class.
        /// </summary>

        public HistogramReport()
        {
            _pixelRange = new Range();
            _histogram = new Collection<int>();
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified HistogramReport.
        /// </summary>
        /// <param name="other">
        /// A HistogramReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(HistogramReport other)
        {
            return other != null && _numPixels == other._numPixels && Utilities.CollectionsEqual(_histogram, other._histogram) && _width == other._width && _mean == other._mean && Object.Equals(_pixelRange, other._pixelRange) && _start == other._start && _standardDeviation == other._standardDeviation;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified HistogramReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of HistogramReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            HistogramReport other = (HistogramReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _numPixels.GetHashCode() ^ _histogram.GetHashCode() ^ _width.GetHashCode() ^ _mean.GetHashCode() ^ _pixelRange.GetHashCode() ^ _start.GetHashCode() ^ _standardDeviation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "HistogramReport: NumberOfPixels=" + _numPixels;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides a report describing the classification of each plane of a color image. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ColorHistogramReport : IEquatable<ColorHistogramReport>
    {
        private HistogramReport _plane1;
        private HistogramReport _plane2;
        private HistogramReport _plane3;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the histogram report of the first color plane. 
        /// </summary>
        /// <value>
        /// </value>

        public HistogramReport Plane1
        {
            get { return _plane1; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _plane1 = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the histogram report of the second color plane. 
        /// </summary>
        /// <value>
        /// </value>

        public HistogramReport Plane2
        {
            get { return _plane2; }
            set { if (value == null) { throw new ArgumentNullException("value"); }_plane2 = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the histogram report of the third color plane. 
        /// </summary>
        /// <value>
        /// </value>

        public HistogramReport Plane3
        {
            get { return _plane3; }
            set { if (value == null) { throw new ArgumentNullException("value"); }_plane3 = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a ColorHistogramReport class.
        /// </summary>

        public ColorHistogramReport()
        {
            _plane1 = new HistogramReport();
            _plane2 = new HistogramReport();
            _plane3 = new HistogramReport();
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorHistogramReport.
        /// </summary>
        /// <param name="other">
        /// A ColorHistogramReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ColorHistogramReport other)
        {
            return other != null && _plane1.Equals(other._plane1) && _plane2.Equals(other._plane2) && _plane3.Equals(other._plane3);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorHistogramReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ColorHistogramReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ColorHistogramReport other = (ColorHistogramReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _plane1.GetHashCode() ^ _plane2.GetHashCode() ^ _plane3.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ColorHistogramReport: Plane1=" + _plane1.ToString() + ", Plane2=" + _plane2.ToString() + ", Plane3=" + _plane3.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains advanced parameters used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnPattern" crefType="Unqualified"/> 
    /// method during the shift phase to learn the template.
    /// </summary>

    [Serializable]
    public class LearnPatternAdvancedShiftOptions : IEquatable<LearnPatternAdvancedShiftOptions>
    {
        private Int32 _initialStepSize;
        private Int32 _initialSampleSize;
        private double _initialSampleSizeFactor;
        private Int32 _finalSampleSize;
        private double _finalSampleSizeFactor;
        private Int32 _subpixelSampleSize;
        private double _subpixelSampleSizeFactor;

internal LearnPatternAdvancedShiftOptions()
        {
            _initialStepSize = 7;
            _initialSampleSize = 0;
            _initialSampleSizeFactor = 0;
            _finalSampleSize = 0;
            _finalSampleSizeFactor = 0;
            _subpixelSampleSize = 0;
            _subpixelSampleSizeFactor = 0;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the sample for the subpixel phase of shift-invariant matching as a percent of the template size, in pixels. 
        /// </summary>
        /// <value>
        /// The default is 0, which causes the algorithm to use SubpixelSampleSize. For optimal speed, the algorithm coerces sizes that are less than 240 to an integer multiple of 12 and coerces sizes greater than 240 to an integer multiple of 60.
        /// </value>

        public double SubpixelSampleSizeFactor
        {
            get { return _subpixelSampleSizeFactor; }
            set { _subpixelSampleSizeFactor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of template pixels that you want to include in a sample for the subpixel phase of shift-invariant matching.
        /// </summary>
        /// <value>
        /// The default is 0, which allows the algorithm to compute SubpixelSampleSize. For optimal speed, the algorithm coerces sizes that are less than 240 to an integer multiple of 12 and coerces sizes greater than 240 to an integer multiple of 60.
        /// </value>

        public Int32 SubpixelSampleSize
        {
            get { return _subpixelSampleSize; }
            set { _subpixelSampleSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the sample for the final phase of shift-invariant matching 
        /// as a percent of the edge points in the template, in pixels. 
        /// </summary>
        /// <value>
        /// The default is 0, which causes the algorithm to use FinalSampleSize. If you provide 
        /// values for both FinalSampleSizeFactor and FinalSampleSize, the algorithm uses the 
        /// FinalSampleSize. For optimal speed, the algorithm coerces sizes that are less than 
        /// 240 to an integer multiple of 12 and coerces sizes greater than 240 to an integer 
        /// multiple of 60. 
        /// </value>

        public double FinalSampleSizeFactor
        {
            get { return _finalSampleSizeFactor; }
            set { _finalSampleSizeFactor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of template pixels you want to add to the InitialSampleSize for the 
        /// final phase of shift-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 0, which allows the algorithm to compute the FinalSampleSize. 
        /// For optimal speed, the algorithm coerces sizes that are less than 240 to an 
        /// integer multiple of 12 and coerces sizes greater than 240 to an integer multiple of 60.
        /// </value>

        public Int32 FinalSampleSize
        {
            get { return _finalSampleSize; }
            set { _finalSampleSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the sample for the initial phase of shift-invariant 
        /// matching as a percent 
        /// of the template size, in pixels. 
        /// </summary>
        /// <value>
        /// The default is 0, which causes the algorithm to use InitialSampleSize. If 
        /// you provide values for both InitialSampleSizeFactor and InitialSampleSize, 
        /// the algorithm uses InitialSampleSize. For optimal speed, the algorithm coerces 
        /// sizes that are less than 240 to an integer multiple of 12 and coerces sizes 
        /// greater than 240 to an integer multiple of 60.
        /// </value>

        public double InitialSampleSizeFactor
        {
            get { return _initialSampleSizeFactor; }
            set { _initialSampleSizeFactor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of template pixels that you want to include in a 
        /// sample for the initial phase of shift-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 0, which allows the algorithm to compute the InitialSampleSize. 
        /// For optimal speed, the algorithm coerces sizes that are less than 240 to an 
        /// integer multiple of 12 and coerces sizes greater than 240 to an integer multiple of 60.
        /// </value>

        public Int32 InitialSampleSize
        {
            get { return _initialSampleSize; }
            set { _initialSampleSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the largest number of image pixels to shift the sample across the inspection image during the initial phase of shift-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 7. The algorithm may reduce the value of InitialStepSize based on InitialSampleSize and the template image. If the step size is not an odd integer, the algorithm coerces it to the next smaller odd integer.
        /// </value>

        public Int32 InitialStepSize
        {
            get { return _initialStepSize; }
            set { _initialStepSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedShiftOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnPatternAdvancedShiftOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnPatternAdvancedShiftOptions other)
        {
            return other != null && _initialStepSize == other._initialStepSize && _initialSampleSize == other._initialSampleSize && _initialSampleSizeFactor == other._initialSampleSizeFactor && _finalSampleSize == other._finalSampleSize && _finalSampleSizeFactor == other._finalSampleSizeFactor && _subpixelSampleSize == other._subpixelSampleSize && _subpixelSampleSizeFactor == other._subpixelSampleSizeFactor;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedShiftOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnPatternAdvancedShiftOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnPatternAdvancedShiftOptions other = (LearnPatternAdvancedShiftOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _initialStepSize.GetHashCode() ^ _initialSampleSize.GetHashCode() ^ _initialSampleSizeFactor.GetHashCode() ^ _finalSampleSize.GetHashCode() ^ _finalSampleSizeFactor.GetHashCode() ^ _subpixelSampleSize.GetHashCode() ^ _subpixelSampleSizeFactor.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnPatternAdvancedShiftOptions: InitialStepSize=" + _initialStepSize;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains advanced parameters used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnPattern" crefType="Unqualified"/> 
    /// method during the rotation phase to learn the template.
    /// </summary>

    [Serializable]
    public sealed class LearnPatternAdvancedRotationOptions : LearnPatternAdvancedShiftOptions, IEquatable<LearnPatternAdvancedRotationOptions>
    {
        private SearchStrategy _strategySupport;
        private Int32 _initialAngularAccuracy;
        private Int32 _finalAngularAccuracy;

internal LearnPatternAdvancedRotationOptions()
        {
            _strategySupport = SearchStrategy.Balanced;
            _initialAngularAccuracy = 6;
            _finalAngularAccuracy = 1;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle accuracy, in degrees, to use during the final phase of the rotation-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 1 degree. Use subpixel accuracy to achieve angle accuracy less than the default. This value must be no greater than the value for InitialAngularAccuracy. The algorithm coerces the angle to the largest integer smaller than it that evenly divides 360. This option is not used in conjunction with the Aggressive search strategy.
        /// </value>

        public Int32 FinalAngularAccuracy
        {
            get { return _finalAngularAccuracy; }
            set { _finalAngularAccuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle accuracy, in degrees, to use during the initial phase of rotation-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 6 degrees. The algorithm coerces the angle to the largest integer smaller than it that evenly divides 360. This option is not used in conjunction with the Aggressive search strategy.
        /// </value>

        public Int32 InitialAngularAccuracy
        {
          get { return _initialAngularAccuracy; }
          set { _initialAngularAccuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the aggressiveness of the rotation search strategy available during the matching phase. 
        /// </summary>
        /// <value>
        /// The default is Balanced.
        /// </value>

        public SearchStrategy StrategySupport
        {
            get { return _strategySupport; }
            set { _strategySupport = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedRotationOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnPatternAdvancedRotationOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnPatternAdvancedRotationOptions other)
        {
            return other != null && Equals((LearnPatternAdvancedShiftOptions)other) && _strategySupport == other._strategySupport && _finalAngularAccuracy == other._finalAngularAccuracy && _initialAngularAccuracy == other._initialAngularAccuracy;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedRotationOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnPatternAdvancedRotationOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnPatternAdvancedRotationOptions other = (LearnPatternAdvancedRotationOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return base.GetHashCode() ^ _strategySupport.GetHashCode() ^ _initialAngularAccuracy.GetHashCode() ^ _finalAngularAccuracy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnPatternAdvancedRotationOptions: InitialStepSize=" + InitialStepSize;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains advanced parameters used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnPattern" crefType="Unqualified"/> 
    /// method to learn the template.
    /// </summary>

    [Serializable]
    public sealed class LearnPatternAdvancedOptions : IEquatable<LearnPatternAdvancedOptions>
    {
        private LearnPatternAdvancedShiftOptions _shift;
        private LearnPatternAdvancedRotationOptions _rotation;

        
        internal LearnPatternAdvancedOptions()
        {
            _shift = new LearnPatternAdvancedShiftOptions();
            _rotation = new LearnPatternAdvancedRotationOptions();
        }
        //==========================================================================================
        /// <summary>
        /// Gets options to use when learning the shift learning phase.
        /// </summary>

        public LearnPatternAdvancedShiftOptions Shift { get { return _shift; } }
        //==========================================================================================
        /// <summary>
        /// Gets options to use when learning the rotation learning phase.
        /// </summary>

        public LearnPatternAdvancedRotationOptions Rotation { get { return _rotation; } }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnPatternAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnPatternAdvancedOptions other)
        {
            return other != null && Object.Equals(_shift, other._shift) && Object.Equals(_rotation, other._rotation);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnPatternAdvancedOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnPatternAdvancedOptions other = (LearnPatternAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _shift.GetHashCode() ^ _rotation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnPatternAdvancedOptions: Shift=" + _shift.ToString() + ", Rotation=" + _rotation.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the learn mode used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnPattern" crefType="Unqualified"/> 
    /// method to learn the template.
    /// </summary>

    [Serializable]
    public sealed class LearnPatternOptions : IEquatable<LearnPatternOptions>
    {
        private LearnMode _mode;
        private LearnPatternAdvancedOptions _advancedOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnPatternOptions class.
        /// </summary>

        public LearnPatternOptions()
            : this(LearnMode.ShiftInformation)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnPatternOptions class.
        /// </summary>
        /// <param name="mode">
        /// The invariance mode to use when learning the pattern.
        /// </param>

        public LearnPatternOptions(LearnMode mode)
        {
            _mode = mode;
            _advancedOptions = new LearnPatternAdvancedOptions();
        }
        //==========================================================================================
        /// <summary>
        /// Gets advanced options to the pattern matching algorithm.
        /// </summary>

        public LearnPatternAdvancedOptions AdvancedOptions { get { return _advancedOptions; } }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the invariance mode to use when learning the pattern.
        /// </summary>
        /// <value>
        /// The default is ShiftInformation.
        /// </value>

        public LearnMode Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnPatternOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnPatternOptions other)
        {
            return other != null && Object.Equals(_advancedOptions, other._advancedOptions) && _mode == other._mode;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnPatternOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnPatternOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnPatternOptions other = (LearnPatternOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _advancedOptions.GetHashCode() ^ _mode.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnPatternOptions: Mode=" + _mode.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Optimizes the performance of the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.MatchPattern" crefType="Unqualified"/>
    /// method and fine-tunes the matches located by the method.
    /// </summary>

    [Serializable]
    public sealed class MatchPatternAdvancedOptions : IEquatable<MatchPatternAdvancedOptions>
    {
        private Int32 _subpixelIterations;
        private double _subpixelTolerance;
        private Int32 _initialMatchListLength;
        private Int32 _matchListReductionFactor;
        private Int32 _initialStepSize;
        private SearchStrategy _searchStrategy;
        private Int32 _intermediateAngularAccuracy;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternAdvancedOptions class.
        /// </summary>

        public MatchPatternAdvancedOptions() : this (SearchStrategy.Balanced)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternAdvancedOptions class.
        /// </summary>
        /// <param name="searchStrategy">
        /// Specifies the aggressiveness of the rotation search strategy.
        /// </param>

        public MatchPatternAdvancedOptions(SearchStrategy searchStrategy)
            : this(searchStrategy, 0, 0, 0, 0, 0, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternAdvancedOptions class.
        /// </summary>
        /// <param name="searchStrategy">
        /// Specifies the aggressiveness of the rotation search strategy.
        /// </param>
        /// <param name="subpixelIterations">
        /// Specifies the maximum number of incremental improvements used to refine matching using 
        /// subpixel information.
        /// <para>
        /// If you provide values for both subpixelIterations and subpixelTolerance, the algorithm 
        /// refines the match for at most subpixelIterations but may stop early if SubpixelTolerance 
        /// is satisfied. If you set subpixelTolerance, matches may be invalidated during the 
        /// subpixel matching process. However, using subpixelIterations alone cannot invalidate a 
        /// match.
        /// </para>
        /// </param>
        /// <param name="subpixelTolerance">
        /// Specifies the maximum amount of change, in pixels, between consecutive incremental 
        /// improvements in the match position that you want to trigger the end of the refinement 
        /// process. 
        /// </param>
        /// <param name="initialMatchListLength">
        /// Specifies the maximum size of the match list. The match list contains the regions 
        /// in the inspection image that have the highest probability of containing a match.
        /// </param>
        /// <param name="matchListReductionFactor">
        /// Specifies the reduction of the match list as matches are refined.
        /// </param>
        /// <param name="initialStepSize">
        /// Specifies the number of pixels to shift the sample across the 
        /// inspection image during the initial phase of shift-invariant matching.  
        /// </param>
        /// <param name="intermediateAngularAccuracy">
        /// Specifies the accuracy, in degrees, to use during the intermediate phase of 
        /// rotation-invariant matching. 
        /// </param>

        public MatchPatternAdvancedOptions(SearchStrategy searchStrategy, Int32 subpixelIterations, double subpixelTolerance, Int32 initialMatchListLength, Int32 matchListReductionFactor, Int32 initialStepSize, Int32 intermediateAngularAccuracy) 
        {
            _subpixelIterations = subpixelIterations;
            _subpixelTolerance = subpixelTolerance;
            _initialMatchListLength = initialMatchListLength;
            _matchListReductionFactor = matchListReductionFactor;
            _initialStepSize = initialStepSize;
            _searchStrategy = searchStrategy;
            _intermediateAngularAccuracy = intermediateAngularAccuracy;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy, in degrees, to use during the intermediate phase of 
        /// rotation-invariant matching. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 IntermediateAngularAccuracy
        {
            get { return _intermediateAngularAccuracy; }
            set { _intermediateAngularAccuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the aggressiveness of the rotation search strategy.
        /// </summary>
        /// <value>
        ///  The default is Balanced. 
        /// </value>

        public SearchStrategy SearchStrategy
        {
            get { return _searchStrategy; }
            set { _searchStrategy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of pixels to shift the sample across the 
        /// inspection image during the initial phase of shift-invariant matching.  
        /// </summary>
        /// <value>
        /// The default is 0, which uses the InitialStepSize stored in the template. 
        /// If the step size is not an odd integer, the algorithm uses the default value.
        /// </value>

        public Int32 InitialStepSize
        {
            get { return _initialStepSize; }
            set { _initialStepSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the reduction of the match list as matches are refined.
        /// </summary>
        /// <value>
        /// The default is 5. 
        /// </value>

        public Int32 MatchListReductionFactor
        {
            get { return _matchListReductionFactor; }
            set { _matchListReductionFactor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum size of the match list. The match list contains the regions in the inspection image that have the highest probability of containing a match.
        /// </summary>
        /// <value>
        /// The default is 200.
        /// </value>

        public Int32 InitialMatchListLength
        {
            get { return _initialMatchListLength; }
            set { _initialMatchListLength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum amount of change, in pixels, between consecutive incremental 
        /// improvements in the match position that you want to trigger the end of the refinement 
        /// process. 
        /// <para>
        /// If you provide values for both SubpixelIterations and SubpixelTolerance, the algorithm 
        /// refines the match for at most SubpixelIterations but may stop early if SubpixelTolerance 
        /// is satisfied. If you set SubpixelTolerance, matches may be invalidated during the 
        /// subpixel matching process. However, using SubpixelIterations alone cannot invalidate a 
        /// match. This behavior is particularly important when using the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.RefineMatches" crefType="Unqualified"/>
        /// method. 
        /// </para>
        /// </summary>
        /// <value>
        /// The default is 0, which specifies using the SubpixelIterations value.
        /// </value>

        public double SubpixelTolerance
        {
            get { return _subpixelTolerance; }
            set { _subpixelTolerance = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of incremental improvements used to refine matching using subpixel information.
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        public Int32 SubpixelIterations
        {
            get { return _subpixelIterations; }
            set { _subpixelIterations = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchPatternAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchPatternAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchPatternAdvancedOptions other)
        {
            return other != null && _subpixelIterations == other._subpixelIterations && _subpixelTolerance == other._subpixelTolerance && _initialMatchListLength == other._initialMatchListLength && _matchListReductionFactor == other._matchListReductionFactor && _initialStepSize == other._initialStepSize && _searchStrategy == other._searchStrategy && _intermediateAngularAccuracy == other._intermediateAngularAccuracy;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchPatternAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchPatternAdvancedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchPatternAdvancedOptions other = (MatchPatternAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _subpixelIterations.GetHashCode() ^ _subpixelTolerance.GetHashCode() ^ _initialMatchListLength.GetHashCode() ^ _matchListReductionFactor.GetHashCode() ^ _initialStepSize.GetHashCode() ^ _searchStrategy.GetHashCode() ^ _intermediateAngularAccuracy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchPatternAdvancedOptions: SearchStrategy=" + _searchStrategy;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Sets parameters that are used to find the template in the image. 
    /// </summary>

    [Serializable]
    public sealed class MatchPatternOptions : IEquatable<MatchPatternOptions>
    {
        private MatchPatternAdvancedOptions _advanced;
        private MatchMode _mode;
        private Int32 _minContrast;
        private bool _subpixelAccuracy;
        private Collection<Range> _rotationAngleRanges;
        private Int32 _numMatchesRequested;
        // _matchFactor would go here, but we don't need it anymore, and setting it to something
        // non-zero returns an error (ERR_MATCHFACTOR_OBSOLETE)
        private double _minMatchScore;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternOptions class.
        /// </summary>

        public MatchPatternOptions()
            : this(MatchMode.ShiftInvariant, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>

        public MatchPatternOptions(MatchMode mode)
            : this(mode, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchPatternOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// Specifies the number of valid matches expected. 
        /// </param>

        public MatchPatternOptions(MatchMode mode, Int32 numberOfMatchesRequested)
        {
            _advanced = new MatchPatternAdvancedOptions();
            _mode = mode;
            _minContrast = 10;
            _subpixelAccuracy = false;
            _rotationAngleRanges = new Collection<Range>();
            _numMatchesRequested = numberOfMatchesRequested;
            _minMatchScore = 800.0;
        }
        //==========================================================================================
        /// <summary>
        /// Gets a collection of angle ranges, where each range specifies how much you expect the template image to rotate in the image. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<Range> RotationAngleRanges
        {
            get { return _rotationAngleRanges; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score a match can have for the method to consider the 
        /// match valid. Acceptable values range from 0 to 1,000. 
        /// </summary>
        /// <value>
        /// The default is 800.
        /// </value>

        public double MinimumMatchScore
        {
            get { return _minMatchScore; }
            set { _minMatchScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of valid matches expected. 
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public Int32 NumberOfMatchesRequested
        {
            get { return _numMatchesRequested; }
            set { _numMatchesRequested = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to calculate match locations with subpixel accuracy. Set this 
        /// parameter to <see langword="true"/> to specify that the function should calculate 
        /// match locations with subpixel accuracy. Set this element to <see langword="false"/> 
        /// to specify that the function should calculate match locations with pixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast expected in the image. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public Int32 MinimumContrast
        {
            get { return _minContrast; }
            set { _minContrast = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method looks for the pattern in the image.
        /// </summary>
        /// <value>
        /// The default is ShiftInvariant.
        /// </value>

        public MatchMode Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the advanced options to the algorithm.
        /// </summary>
        /// <value>
        /// </value>

        public MatchPatternAdvancedOptions Advanced
        {
            get { return _advanced; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchPatternOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchPatternOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchPatternOptions other)
        {
            return other != null && Object.Equals(_advanced, other._advanced) && _mode == other._mode && _minContrast == other._minContrast && _subpixelAccuracy == other._subpixelAccuracy && Utilities.CollectionsEqual(_rotationAngleRanges, other._rotationAngleRanges) && _numMatchesRequested == other._numMatchesRequested && _minMatchScore == other._minMatchScore;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchPatternOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchPatternOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchPatternOptions other = (MatchPatternOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _advanced.GetHashCode() ^ _mode.GetHashCode() ^ _minContrast.GetHashCode() ^ _subpixelAccuracy.GetHashCode() ^ _rotationAngleRanges.Count.GetHashCode() ^ _numMatchesRequested.GetHashCode() ^ _minMatchScore.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchPatternOptions: Mode=" + _mode.ToString() + ", NumberOfMatchesRequested=" + _numMatchesRequested.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a matched pattern.
    /// </summary>

    [Serializable]
    public sealed class PatternMatch : IEquatable<PatternMatch>
    {
        private PointContour _position;
        private double _rotation;
        private double _scale;
        private double _score;
        private Collection<PointContour> _corners;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PatternMatch class.
        /// </summary>

        public PatternMatch()
        {
            _position = new PointContour();
            _corners = new Collection<PointContour>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets the coordinates of the corners of the rectangle surrounding the template image.
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match. A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the match relative to the size of the template image, expressed as a percentage. 
        /// </summary>

        public double Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees.
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the match.
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PatternMatch.
        /// </summary>
        /// <param name="other">
        /// A PatternMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PatternMatch other)
        {
            return other != null && Object.Equals(_position, other._position) && _rotation == other._rotation && _scale == other._scale && _score == other._score && Object.Equals(_corners, other._corners);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PatternMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PatternMatch
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PatternMatch other = (PatternMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _scale.GetHashCode() ^ _score.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PatternMatch: Position=" + _position.ToString() + ", Corners=" + _corners.ToString();
        }
    }

    public sealed class PatternMatchReport : IEquatable<PatternMatchReport>
    {
        private PointContour _position;
        private PointContour _calibratedPosition;
        private float _rotation;
        private float _calibratedRotation;
        private float _scale;
        private float _calibratedScale;
        private float _score;
        private float _calibratedScore;
        private Collection<PointContour> _corners;
        private Collection<PointContour> _calibratedCorners;

        public float CalibratedRotation
        {
            get { return _calibratedRotation; }
            set { _calibratedRotation = value; }
        }

        public float CalibratedScale
        {
            get { return _calibratedScale; }
            set { _calibratedScale = value; }
        }

        public float CalibratedScore
        {
            get { return _calibratedScore; }
            set { _calibratedScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PatternMatch class.
        /// </summary>

        public PatternMatchReport()
        {
            _position = new PointContour();
            _calibratedPosition = new PointContour();
            _corners = new Collection<PointContour>();
            _calibratedCorners = new Collection<PointContour>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets the coordinates of the corners of the rectangle surrounding the template image.
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }
        public Collection<PointContour> CalibratedCorners
        {
            get { return _calibratedCorners; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match. A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </summary>

        public float Score
        {
            get { return _score; }
            set { _score = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the match relative to the size of the template image, expressed as a percentage. 
        /// </summary>

        public float Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees.
        /// </summary>

        public float Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the match.
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }

        public PointContour CalibratedPosition
        {
            get { return _calibratedPosition; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _calibratedPosition = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PatternMatch.
        /// </summary>
        /// <param name="other">
        /// A PatternMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PatternMatchReport other)
        {
            return other != null && Object.Equals(_position, other._position) && _rotation == other._rotation && _scale == other._scale && _score == other._score && Object.Equals(_corners, other._corners) && object.Equals(_calibratedCorners, other._calibratedCorners) && object.Equals(_calibratedPosition, other._calibratedPosition);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PatternMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PatternMatch
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PatternMatchReport other = (PatternMatchReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _scale.GetHashCode() ^ _score.GetHashCode() ^ _calibratedPosition.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PatternMatch: Position=" + _position.ToString() + ", Corners=" + _corners.ToString() +", CalibratedPosition"+ _calibratedPosition.ToString() + ", Calibrated Corners=" + _calibratedCorners.ToString();
        }

    }

    [Serializable]
    public sealed class LearnTemplateReport
    {

        private Int32 templateContrast;
        private Int32 grayvalueMaxPyramidLevel;
        private Int32 grayvalueOptimalPyramidLevel;
        private Int32 gradientMaxPyramidLevel;
        private Int32 gradientOptimalPyramidLevel;

        public LearnTemplateReport()
        {
            templateContrast                =  0;
            grayvalueMaxPyramidLevel        = -1;
            grayvalueOptimalPyramidLevel    = -1;
            gradientMaxPyramidLevel         = -1;
            gradientOptimalPyramidLevel     = -1;
        }
        public Int32 TemplateContrast
        {
            get { return templateContrast; }
            set { templateContrast = value; }
        }
        public Int32 GrayvalueMaxPyramidLevel
        {
            get { return grayvalueMaxPyramidLevel; }
            set { grayvalueMaxPyramidLevel = value; }
        }
        public Int32 GrayvalueOptimalPyramidLevel
        {
            get { return grayvalueOptimalPyramidLevel; }
            set { grayvalueOptimalPyramidLevel = value; }
        }
        public Int32 GradientMaxPyramidLevel
        {
            get { return gradientMaxPyramidLevel; }
            set { gradientMaxPyramidLevel = value; }
        }
        public Int32 GradientOptimalPyramidLevel
        {
            get { return gradientOptimalPyramidLevel; }
            set { gradientOptimalPyramidLevel = value; }
        }
    }

    [Serializable]
    public sealed class PMLearnAdvancedSetupDataOption : IEquatable<PMLearnAdvancedSetupDataOption>
    {
        private LearnSetupOption type;
        private double value;

        public double Value
        {
            get { return this.value; }
            set { this.value = value; }
        }

        public LearnSetupOption Type
        {
            get { return type; }
            set { type = value; }
        }

        public PMLearnAdvancedSetupDataOption(LearnSetupOption setupOption, double value)
        {
            this.type  = setupOption;
            this.value = value;
        }

        public PMLearnAdvancedSetupDataOption(PMLearnAdvancedSetupDataOption learnOption)
        {
            this.type = learnOption.Type;
            this.value = learnOption.Value;
        }

        public bool Equals(PMLearnAdvancedSetupDataOption other)
        {
            return other != null && this.type == other.type && this.value == other.value;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PMLearnAdvancedSetupDataOption other = (PMLearnAdvancedSetupDataOption)obj;
            return Equals(other);
        }
        
        public override int GetHashCode()
        {
            return type.GetHashCode() ^ value.GetHashCode();
        }
    }

    [Serializable]
    public sealed class PMMatchAdvancedSetupDataOption : IEquatable<PMMatchAdvancedSetupDataOption>
    {
        private MatchSetupOption type;
        private double value;

        public double Value
        {
            get { return this.value; }
            set { this.value = value; }
        }

        public MatchSetupOption Type
        {
            get { return type; }
            set { type = value; }
        }

        public PMMatchAdvancedSetupDataOption(MatchSetupOption setupOption, double value)
        {
            this.type = setupOption;
            this.value = value;
        }

        public PMMatchAdvancedSetupDataOption(PMMatchAdvancedSetupDataOption matchOption)
        {
            this.type = matchOption.Type;
            this.value = matchOption.value;
        }

        public bool Equals(PMMatchAdvancedSetupDataOption other)
        {
            return other != null && this.type == other.type && this.value == other.value;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PMMatchAdvancedSetupDataOption other = (PMMatchAdvancedSetupDataOption)obj;
            return Equals(other);
        }

        public override int GetHashCode()
        {
            return type.GetHashCode() ^ value.GetHashCode();
        }
    }

    [Serializable]
    public sealed class PyramidInfo : IEquatable<PyramidInfo>
    {
        Int32 maxPyramidLevel;
        Int32 optimalPyramidLevel;
        Int32 maxPyramidLevelToStoreData;

        public Int32 MaxPyramidLevelToStoreData
        {
            get { return maxPyramidLevelToStoreData; }
            set { maxPyramidLevelToStoreData = value; }
        }  

        public Int32 OptimalPyramidLevel
        {
            get { return optimalPyramidLevel; }
            set { optimalPyramidLevel = value; }
        }

        public Int32 MaxPyramidLevel
        {
            get { return maxPyramidLevel; }
            set { maxPyramidLevel = value; }
        }

        public PyramidInfo()
        {
            maxPyramidLevel     = -1;
            optimalPyramidLevel = -1;
            maxPyramidLevelToStoreData = -1;
        }

        public PyramidInfo(Int32 _maxPyramidLevel, Int32 _optimalPyramidLevel, Int32 _maxPyramidLevelToStoreData)
        {
            maxPyramidLevel = _maxPyramidLevel;
            optimalPyramidLevel = _optimalPyramidLevel;
            maxPyramidLevelToStoreData = _maxPyramidLevelToStoreData;
        }

        public bool Equals(PyramidInfo other)
        {
            return other != null && this.maxPyramidLevel == other.maxPyramidLevel && this.optimalPyramidLevel == other.optimalPyramidLevel && this.maxPyramidLevelToStoreData == other.maxPyramidLevelToStoreData;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PyramidInfo other = (PyramidInfo)obj;
            return Equals(other);
        }

        public override int GetHashCode()
        {
            return maxPyramidLevel.GetHashCode() ^ optimalPyramidLevel.GetHashCode() ^ maxPyramidLevelToStoreData.GetHashCode();
        }
        
    }

    [Serializable]
    public sealed class MatchOffsetInfo : IEquatable<MatchOffsetInfo>
    {
        private double matchOffsetX;
        private double matchOffsetY;
        private double angleOffset;

        public double MatchOffsetX
        {
            get { return matchOffsetX; }
            set { matchOffsetX = value; }
        }
        public double MatchOffsetY
        {
            get { return matchOffsetY; }
            set { matchOffsetY = value; }
        }
        public double AngleOffset
        {
            get { return angleOffset; }
            set { angleOffset = value; }
        }
        public MatchOffsetInfo()
        {
            matchOffsetX = 0.0;
            matchOffsetY = 0.0;
            angleOffset  = 0.0;
        }
        public MatchOffsetInfo(double _matchOffsetX, double _matchOffsetY, double _angleOffset)
        {
            matchOffsetX = _matchOffsetX;
            matchOffsetY = _matchOffsetY;
            angleOffset  = _angleOffset;
        }

        public bool Equals(MatchOffsetInfo other)
        {
            return other != null && this.matchOffsetX == other.matchOffsetX && this.matchOffsetY == other.matchOffsetY && this.angleOffset == other.angleOffset;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchOffsetInfo other = (MatchOffsetInfo)obj;
            return Equals(other);
        }

        public override int GetHashCode()
        {
            return matchOffsetX.GetHashCode() ^ matchOffsetY.GetHashCode() ^ angleOffset.GetHashCode();
        }
    }

    [Serializable]
    public sealed class PatternMatchTemplateInfo : IEquatable<PatternMatchTemplateInfo>
    {
        private PyramidInfo pyramidMatchInfo;
        private MatchOffsetInfo matchOffsetInfo;

        public MatchOffsetInfo MatchOffsetInfo
        {
            get { return matchOffsetInfo; }
            set { if (value == null) { throw new ArgumentNullException("value"); } matchOffsetInfo = value; }
        }

        public PyramidInfo PyramidMatchInfo
        {
            get { return pyramidMatchInfo; }
            set { if (value == null) { throw new ArgumentNullException("value"); } pyramidMatchInfo = value; }
        }

        public PatternMatchTemplateInfo()
        {
            pyramidMatchInfo = new PyramidInfo();
            matchOffsetInfo = new MatchOffsetInfo();   
        }

        public bool Equals(PatternMatchTemplateInfo other)
        {
            return other != null && Object.Equals(pyramidMatchInfo, other.pyramidMatchInfo) && object.Equals(matchOffsetInfo, other.MatchOffsetInfo);
        }
        
        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PatternMatchTemplateInfo other = (PatternMatchTemplateInfo)obj;
            return Equals(other);
        }
        public override int GetHashCode()
        {
            return pyramidMatchInfo.GetHashCode() ^ pyramidMatchInfo.GetHashCode();
        }

        public override string ToString()
        {
            return "PatternMatchTemplateInfo: PyramidMatchInfo=" + pyramidMatchInfo.ToString() + ", MatchOffsetInfo=" + matchOffsetInfo.ToString();
        }
    }

    [Serializable]
    public sealed class RotationAngleRange : IEquatable<RotationAngleRange>
    {
        private float lower;
        private float upper;

        public RotationAngleRange()
        {
            lower = 0.0f;
            upper = 0.0f;
        }

        public RotationAngleRange(RotationAngleRange angleRange)
        {
            this.lower = angleRange.lower;
            this.upper = angleRange.upper;
        }

        public RotationAngleRange(float _lower, float _upper)
        {
            lower = _lower;
            upper = _upper;
        }

        public float Upper
        {
            get { return upper; }
            set { upper = value; }
        }

        public float Lower
        {
            get { return lower; }
            set { lower = value; }
        }

        public bool Equals(RotationAngleRange other)
        {
            return other != null && this.lower != other.lower && this.upper != other.upper;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RotationAngleRange other = (RotationAngleRange)obj;
            return Equals(other);
        }

        public override int GetHashCode()
        {
            return lower.GetHashCode() ^ lower.GetHashCode();
        }

        public override string ToString()
        {
            return "RotationAngleRange: lower = " + lower.ToString() + ", RotationAngleRange: Upper=" + upper.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Optimizes and fine-tunes advanced parameters used during the learning phase.
    /// </summary>

    [Serializable]
    public sealed class LearnGeometricPatternFeatureBasedAdvancedOptions : IEquatable<LearnGeometricPatternFeatureBasedAdvancedOptions>
    {
        private Int32 _minimumRectangleLength;
        private double _minimumRectangleAspectRatio;
        private Int32 _minimumRadius;
        private Int32 _minimumLineLength;
        private double _minimumFeatureStrength;
        private Int32 _maximumFeaturesUsed;
        private Int32 _maximumPixelDistanceFromLine;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnGeometricPatternFeatureBasedAdvancedOptions class.
        /// </summary>

        public LearnGeometricPatternFeatureBasedAdvancedOptions()
            : this(10)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnGeometricPatternFeatureBasedAdvancedOptions class.
        /// </summary>
        /// <param name="minimumRectangleLength">
        /// Specifies the minimum length for each side of a rectangular feature. The method 
        /// ignores rectangular features with a side shorter than this value. 
        /// </param>

        public LearnGeometricPatternFeatureBasedAdvancedOptions(int minimumRectangleLength)
            : this(minimumRectangleLength, .2)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnGeometricPatternFeatureBasedAdvancedOptions class.
        /// </summary>
        /// <param name="minimumRectangleLength">
        /// Specifies the minimum length for each side of a rectangular feature. The method 
        /// ignores rectangular features with a side shorter than this value. 
        /// </param>
        /// <param name="minimumRectangleAspectRatio">
        /// Specifies the minimum aspect ratio of a rectangular feature. The method ignores rectangular 
        /// features with aspect ratios less than this value. 
        /// </param>

        public LearnGeometricPatternFeatureBasedAdvancedOptions(int minimumRectangleLength, double minimumRectangleAspectRatio)
        {
            _minimumRectangleLength = minimumRectangleLength;
            _minimumRectangleAspectRatio = minimumRectangleAspectRatio;
            _minimumRadius = 5;
            _minimumLineLength = 15;
            _minimumFeatureStrength = .5;
            _maximumFeaturesUsed = 25;
            _maximumPixelDistanceFromLine = 2;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of pixels between an edge pixel and a linear 
        /// feature for the method to consider that edge pixel as part of the linear feature. 
        /// </summary>
        /// <value>
        /// The default is 2.
        /// </value>

        public Int32 MaximumPixelDistanceFromLine
        {
            get { return _maximumPixelDistanceFromLine; }
            set { _maximumPixelDistanceFromLine = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of features the method uses when learning.
        /// </summary>
        /// <value>
        /// The default is 25.
        /// </value>

        public Int32 MaximumFeaturesUsed
        {
            get { return _maximumFeaturesUsed; }
            set { _maximumFeaturesUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum strength for a feature. The method ignores features with a strength less than this value. Valid values range from 0 to 1. 
        /// </summary>
        /// <value>
        /// The default is 0.5.
        /// </value>

        public double MinimumFeatureStrength
        {
            get { return _minimumFeatureStrength; }
            set { _minimumFeatureStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum length for a linear feature. The method ignores linear features 
        /// with lengths shorter than this value. 
        /// </summary>
        /// <value>
        /// The default is 15.
        /// </value>

        public Int32 MinimumLineLength
        {
            get { return _minimumLineLength; }
            set { _minimumLineLength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum radius for a circular feature. The method ignores circular 
        /// features with radii less than this value. 
        /// </summary>
        /// <value>
        /// The default is 5.
        /// </value>

        public Int32 MinimumRadius
        {
            get { return _minimumRadius; }
            set { _minimumRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum aspect ratio of a rectangular feature. The method ignores rectangular 
        /// features with aspect ratios less than this value. 
        /// </summary>
        /// <value>
        /// The default is 0.2.
        /// </value>

        public double MinimumRectangleAspectRatio
        {
            get { return _minimumRectangleAspectRatio; }
            set { _minimumRectangleAspectRatio = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum length for each side of a rectangular feature. The method 
        /// ignores rectangular features with a side shorter than this value. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public Int32 MinimumRectangleLength
        {
            get { return _minimumRectangleLength; }
            set { _minimumRectangleLength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnGeometricPatternFeatureBasedAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnGeometricPatternFeatureBasedAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnGeometricPatternFeatureBasedAdvancedOptions other)
        {
            return other != null && _minimumRectangleLength == other._minimumRectangleLength && _minimumRectangleAspectRatio == other._minimumRectangleAspectRatio && _minimumRadius == other._minimumRadius && _minimumLineLength == other._minimumLineLength && _minimumFeatureStrength == other._minimumFeatureStrength && _maximumFeaturesUsed == other._maximumFeaturesUsed && _maximumPixelDistanceFromLine == other._maximumPixelDistanceFromLine;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnGeometricPatternFeatureBasedAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnGeometricPatternFeatureBasedAdvancedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnGeometricPatternFeatureBasedAdvancedOptions other = (LearnGeometricPatternFeatureBasedAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _minimumRectangleLength.GetHashCode() ^ _minimumRectangleAspectRatio.GetHashCode() ^ _minimumRadius.GetHashCode() ^ _minimumLineLength.GetHashCode() ^ _minimumFeatureStrength.GetHashCode() ^ _maximumFeaturesUsed.GetHashCode() ^ _maximumPixelDistanceFromLine.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnGeometricPatternFeatureBasedAdvancedOptions: MinimumRectangleLength=" + _minimumRectangleLength + ", MinimumRectangleAspectRatio=" + _minimumRectangleAspectRatio;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Optimizes and fine-tunes advanced parameters used during the learning phase.
    /// </summary>

    [Serializable]
    public sealed class LearnGeometricPatternEdgeBasedAdvancedOptions : IEquatable<LearnGeometricPatternEdgeBasedAdvancedOptions>
    {
        private Range _scaleRange;
        private Range _rotationAngleRange;
        private UInt32 _imageSamplingFactor;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnGeometricPatternEdgeBasedAdvancedOptions class.
        /// </summary>

        public LearnGeometricPatternEdgeBasedAdvancedOptions()
            : this(new Range(75, 125))
        {
        }
 
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnGeometricPatternEdgeBasedAdvancedOptions class.
        /// </summary>
        /// <param name="scaleRange">
        /// Specifies the scale factor range for matches to the template. For example, if the range is (75,125),
        /// matches with dimensions less than 75% and greater than 125% of the dimensions of the template will 
        /// not be searched for. 
        /// </param>

        public LearnGeometricPatternEdgeBasedAdvancedOptions(Range scaleRange)
        {
            _scaleRange = scaleRange;
            _rotationAngleRange = new Range(0,360.0);
            _imageSamplingFactor = 0;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the scale factor range for matches to the template. For example, if the range is (75,125),
        /// matches with dimensions less than 75% and greater than 125% of the dimensions of the template will 
        /// not be searched for. 
        /// </summary>
        /// <value>
        /// The default is (75, 125).
        /// </value>

        public Range ScaleRange
        {
            get { return _scaleRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _scaleRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation angle range for the template.
        /// </summary>
        /// <value>
        /// The default is (0, 360).
        /// </value>

        public Range RotationAngleRange
        {
            get { return _rotationAngleRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _rotationAngleRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the factor that is used to subsample the template and the image for the 
        /// initial matching phase. The image is subsampled by a power of 2 factor that is 
        /// less than or equal to the specified value. 
        /// </summary>
        /// <value>
        /// The default is 0, which specifies that the subsamping factor is automatically determined.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 ImageSamplingFactor
        {
            get { return _imageSamplingFactor; }
            set { _imageSamplingFactor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnGeometricPatternEdgeBasedAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnGeometricPatternEdgeBasedAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnGeometricPatternEdgeBasedAdvancedOptions other)
        {
            return other != null && _scaleRange.Equals(other._scaleRange) && _rotationAngleRange.Equals(other._rotationAngleRange) && _imageSamplingFactor == other._imageSamplingFactor;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnGeometricPatternEdgeBasedAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnGeometricPatternEdgeBasedAdvancedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnGeometricPatternEdgeBasedAdvancedOptions other = (LearnGeometricPatternEdgeBasedAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _scaleRange.GetHashCode() ^
                   _rotationAngleRange.GetHashCode() ^
                   _imageSamplingFactor.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnGeometricPatternEdgeBasedAdvancedOptions: ImageSamplingFactor=" + _imageSamplingFactor;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Optimizes the performance of the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.MatchGeometricPatternFeatureBased" crefType="Unqualified"/> 
    /// method and fine-tunes the matches located by the method.
    /// </summary>

    [Serializable]
    public sealed class MatchGeometricPatternFeatureBasedAdvancedOptions
    {
        private Range                           _featuresUsedRange;
        private Int32                           _subpixelIterations;         
        private double                          _subpixelTolerance;          
        private Int32                           _initialMatchListLength;     
        private bool                            _targetTemplateCurveScore;
        private bool                            _correlationScore;           
        private double                          _minMatchSeparationDistance; 
        private double                          _minMatchSeparationAngle;    
        private double                          _minMatchSeparationScale;    
        private double                          _maxMatchOverlap;            
        private bool                            _coarseResult;
        private bool                            _smoothContours;
        private bool                            _enableCalibrationSupport;   

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternFeatureBasedAdvancedOptions class.
        /// </summary>

        public MatchGeometricPatternFeatureBasedAdvancedOptions()
            : this(200)
        {
        }
   
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternFeatureBasedAdvancedOptions class.
        /// </summary>
        /// <param name="initialMatchListLength">
        /// Specifies the maximum size of the match list. The match list contains the 
        /// regions in the inspection image that have the highest probability of containing a match. 
        /// </param>

        public MatchGeometricPatternFeatureBasedAdvancedOptions(Int32 initialMatchListLength)
        {
            _featuresUsedRange = new Range(5, 5);
            _subpixelIterations = 20;
            _subpixelTolerance = 0;
            _initialMatchListLength = initialMatchListLength;
            _targetTemplateCurveScore = false;
            _correlationScore = true;
            _minMatchSeparationDistance = 20;
            _minMatchSeparationAngle = 10;
            _minMatchSeparationScale = 10;
            _maxMatchOverlap = 80;
            _coarseResult = false;
            _smoothContours = false;
            _enableCalibrationSupport = true;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether or not smoothing be done on the contours of the inspection 
        /// image before feature extraction. Set this element to <see langword="true"/> to specify smoothing 
        /// be done on the contours of the inspection image before feature extraction. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SmoothContours
        {
            get { return _smoothContours; }
            set { _smoothContours = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should calculate the match curve to template curve score. 
        /// Set this element to <see langword="true"/> to specify that the method should calculate 
        /// the match curve to template curve score and return it for each match 
        /// result. Set this element to <see langword="false"/> to specify that the method should not 
        /// calculate the match curve to template curve score.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool TargetTemplateCurveScore
        {
            get { return _targetTemplateCurveScore; }
            set { _targetTemplateCurveScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of the number of features the method uses when matching.
        /// </summary>
        /// <value>
        /// The default is (5, 5).
        /// </value>

        public Range FeaturesUsedRange
        {
            get { return _featuresUsedRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _featuresUsedRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of incremental improvements used to refine matches with subpixel information. 
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        public Int32 SubpixelIterations
        {
            get { return _subpixelIterations; }
            set { _subpixelIterations = value; }
        }   

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum amount of change, in pixels, between consecutive incremental 
        /// improvements in the match position before the method stops refining the match position. 
        /// <para>
        /// Set this parameter to 0 to specify that the method should always use a number of refinements 
        /// equal to SubpixelIterations. If you provide values for both SubpixelIterations and 
        /// SubpixelTolerance, the method refines the match for, at most, SubpixelIterations but may 
        /// stop early if SubpixelTolerance is satisfied. If you set SubpixelTolerance, the method may 
        /// invalidate matches during the subpixel refinement process. However, using SubpixelIterations 
        /// alone cannot invalidate a match. 
        /// </para>
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double SubpixelTolerance
        {
            get { return _subpixelTolerance; }
            set { _subpixelTolerance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum size of the match list. The match list contains the 
        /// regions in the inspection image that have the highest probability of containing a match. 
        /// </summary>
        /// <value>
        /// The default is 200.
        /// </value>

        public Int32 InitialMatchListLength
        {
            get { return _initialMatchListLength; }
            set { _initialMatchListLength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should calculate the correlation score. Set this 
        /// parameter to <see langword="true"/> to specify that the method should calculate 
        /// the correlation score and return it for each match result. Set this parameter to 
        /// <see langword="false"/> to specify that the method should not calculate the 
        /// correlation score. 
        /// </summary>
        /// <value>
        /// The default is <see langword="true"/>.
        /// </value>

        public bool CorrelationScore
        {
            get { return _correlationScore; }
            set { _correlationScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum separation distance, in pixels, between the origins of 
        /// two matches that have unique positions. The method does not return matches that 
        /// have the same position, scale, and angle. Set this value to -1 if you do not want 
        /// the method to use the position of a match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        public double MinimumMatchSeparationDistance
        {
            get { return _minMatchSeparationDistance; }
            set { _minMatchSeparationDistance = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum angular difference, in degrees, between two matches that 
        /// have unique angles. The method does not return matches that have the same position, 
        /// scale, and angle. Set this value to -1 if you do not want the method to use the angle 
        /// of a match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public double MinimumMatchSeparationAngle
        {
            get { return _minMatchSeparationAngle; }
            set { _minMatchSeparationAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum difference in scale, expressed as a percentage, between two matches 
        /// that have unique scales. The method does not return matches that have the same position, 
        /// scale, and angle. Set this value to -1 if you do not want the method to use the scale of a 
        /// match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public double MinimumMatchSeparationScale
        {
            get { return _minMatchSeparationScale; }
            set { _minMatchSeparationScale = value; }
        }  
        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum amount of overlap, expressed as a percentage, allowed 
        /// between the bounding rectangles of two unique matches. The method does not 
        /// return matches that exceed this overlap percentage. Set this value to -1 if you 
        /// want the method to ignore bounding rectangle overlap. 
        /// </summary>
        /// <value>
        /// The default is 80.
        /// </value>

        public double MaximumMatchOverlap
        {
            get { return _maxMatchOverlap; }
            set { _maxMatchOverlap = value; }
        } 
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether you want the method to spend less time accurately 
        /// estimating the location of a match. Set this value to <see langword="true"/> if you want 
        /// to quickly determine whether a part is present in the inspection image 
        /// without an accurate estimate of its position, angle, and scale. Set 
        /// this value to <see langword="false"/> to specify that the method returns matches with 
        /// pixel or subpixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool CoarseResult
        {
            get { return _coarseResult; }
            set { _coarseResult = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to treat the inspection image as a calibrated image. Set this 
        /// parameter to <see langword="true"/> to specify that the method treat the inspection 
        /// image as a calibrated image. Use the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.SetSimpleCalibration" crefType="Unqualified"/>
        /// method or the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.CopyCalibrationInformation" crefType="Unqualified"/>
        /// method to calibrate the inspection image. 
        /// </summary>
        /// <value>
        /// The default is <see langword="true"/>.
        /// </value>

        public bool EnableCalibrationSupport
        {
            get { return _enableCalibrationSupport; }
            set { _enableCalibrationSupport = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternFeatureBasedAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchGeometricPatternFeatureBasedAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchGeometricPatternFeatureBasedAdvancedOptions other)
        {
            return other != null &&
                    Object.Equals(_featuresUsedRange, other._featuresUsedRange) &&
                    _subpixelIterations == other._subpixelIterations &&
                    _subpixelTolerance == other._subpixelTolerance &&
                    _initialMatchListLength == other._initialMatchListLength &&
                    _targetTemplateCurveScore == other._targetTemplateCurveScore &&
                    _correlationScore == other._correlationScore &&
                    _minMatchSeparationDistance == other._minMatchSeparationDistance &&
                    _minMatchSeparationAngle == other._minMatchSeparationAngle &&
                    _minMatchSeparationScale == other._minMatchSeparationScale &&
                    _maxMatchOverlap == other._maxMatchOverlap &&
                    _coarseResult == other._coarseResult &&
                    _smoothContours == other._smoothContours &&
                    _enableCalibrationSupport == other._enableCalibrationSupport;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternFeatureBasedAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchGeometricPatternFeatureBasedAdvancedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchGeometricPatternFeatureBasedAdvancedOptions other = (MatchGeometricPatternFeatureBasedAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return  _featuresUsedRange.GetHashCode() ^
                    _subpixelIterations.GetHashCode() ^
                    _subpixelTolerance.GetHashCode() ^
                    _initialMatchListLength.GetHashCode() ^
                    _targetTemplateCurveScore.GetHashCode() ^
                    _correlationScore.GetHashCode() ^
                    _minMatchSeparationDistance.GetHashCode() ^
                    _minMatchSeparationAngle.GetHashCode() ^
                    _minMatchSeparationScale.GetHashCode() ^
                    _maxMatchOverlap.GetHashCode() ^
                    _coarseResult.GetHashCode() ^
                    _smoothContours.GetHashCode() ^
                    _enableCalibrationSupport.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchGeometricPatternFeatureBasedAdvancedOptions: InitialMatchListLength=" + _initialMatchListLength.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Optimizes the performance of the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.MatchGeometricPatternEdgeBased" crefType="Unqualified"/> 
    /// method and fine-tunes the matches located by the method.
    /// </summary>

    [Serializable]
    public sealed class MatchGeometricPatternEdgeBasedAdvancedOptions : IEquatable<MatchGeometricPatternEdgeBasedAdvancedOptions>
    {
        private UInt32                          _subpixelIterations;         
        private double                          _subpixelTolerance;          
        private UInt32                          _initialMatchListLength;     
        private bool                            _targetTemplateCurveScore;    
        private bool                            _correlationScore;           
        private double                          _minMatchSeparationDistance; 
        private double                          _minMatchSeparationAngle;    
        private double                          _minMatchSeparationScale;    
        private double                          _maxMatchOverlap;            
        private bool                            _coarseResult;               
        private bool                            _enableCalibrationSupport;   
        private ContrastMode                    _contrastMode;     
        private GeometricMatchingSearchStrategy _matchStrategy;              
        private UInt32                          _refineMatchFactor;
        private UInt32                          _subpixelMatchFactor;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternEdgeBasedAdvancedOptions class.
        /// </summary>

        public MatchGeometricPatternEdgeBasedAdvancedOptions()
            : this(ContrastMode.Original, GeometricMatchingSearchStrategy.Balanced)
        {
        }
   
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternEdgeBasedAdvancedOptions class.
        /// </summary>
        /// <param name="contrastMode">
        /// Specifies the contrast of the matches in the target image in relation to the contrast of the template.
        /// </param>

        public MatchGeometricPatternEdgeBasedAdvancedOptions(ContrastMode contrastMode)
            : this(contrastMode, GeometricMatchingSearchStrategy.Balanced)

       {
       }
   
        //==========================================================================================
       /// <summary>
       /// Initializes a new instance of the MatchGeometricPatternEdgeBasedAdvancedOptions class.
       /// </summary>
       /// <param name="contrastMode">
       /// Specifies the contrast of the matches in the target image in relation to the contrast of the template.
       /// </param>
       /// <param name="matchStrategy">
       /// Specifies the aggressiveness of the search strategy.
       /// </param>

        public MatchGeometricPatternEdgeBasedAdvancedOptions(ContrastMode contrastMode, GeometricMatchingSearchStrategy matchStrategy)
        {
            _subpixelIterations = 20;
            _subpixelTolerance = 0;
            _initialMatchListLength = 200;
            _targetTemplateCurveScore = false;
            _correlationScore = true;
            _minMatchSeparationDistance = 20;
            _minMatchSeparationAngle = 10;
            _minMatchSeparationScale = 10;
            _maxMatchOverlap = 80;
            _coarseResult = false;
            _enableCalibrationSupport = true;
            _contrastMode = contrastMode;
            _matchStrategy = matchStrategy;
            _refineMatchFactor = 0;
            _subpixelMatchFactor = 0;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of incremental improvements used to refine matches with subpixel information. 
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 SubpixelIterations
        {
            get { return _subpixelIterations; }
            set { _subpixelIterations = value; }
        }   

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum amount of change, in pixels, between consecutive incremental 
        /// improvements in the match position before the method stops refining the match position. 
        /// <para>
        /// Set this parameter to 0 to specify that the method should always use a number of refinements 
        /// equal to SubpixelIterations. If you provide values for both SubpixelIterations and 
        /// SubpixelTolerance, the method refines the match for, at most, SubpixelIterations but may 
        /// stop early if SubpixelTolerance is satisfied. If you set SubpixelTolerance, the method may 
        /// invalidate matches during the subpixel refinement process. However, using SubpixelIterations 
        /// alone cannot invalidate a match. 
        /// </para>
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double SubpixelTolerance
        {
            get { return _subpixelTolerance; }
            set { _subpixelTolerance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum size of the match list. The match list contains the 
        /// regions in the inspection image that have the highest probability of containing a match. 
        /// </summary>
        /// <value>
        /// The default is 200.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 InitialMatchListLength
        {
            get { return _initialMatchListLength; }
            set { _initialMatchListLength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should calculate the match curve to template curve score. 
        /// Set this element to <see langword="true"/> to specify that the method should calculate 
        /// the match curve to template curve score and return it for each match 
        /// result. Set this element to <see langword="false"/> to specify that the method should not 
        /// calculate the match curve to template curve score.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool TargetTemplateCurveScore
        {
            get { return _targetTemplateCurveScore; }
            set { _targetTemplateCurveScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should calculate the correlation score. Set this 
        /// parameter to <see langword="true"/> to specify that the method should calculate 
        /// the correlation score and return it for each match result. Set this parameter to 
        /// <see langword="false"/> to specify that the method should not calculate the 
        /// correlation score. 
        /// </summary>
        /// <value>
        /// The default is <see langword="true"/>.
        /// </value>

        public bool CorrelationScore
        {
            get { return _correlationScore; }
            set { _correlationScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum separation distance, in pixels, between the origins of 
        /// two matches that have unique positions. The method does not return matches that 
        /// have the same position, scale, and angle. Set this value to 1 if you do not want 
        /// the method to use the position of a match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        public double MinimumMatchSeparationDistance
        {
            get { return _minMatchSeparationDistance; }
            set { _minMatchSeparationDistance = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum angular difference, in degrees, between two matches that 
        /// have unique angles. The method does not return matches that have the same position, 
        /// scale, and angle. Set this value to 1 if you do not want the method to use the angle 
        /// of a match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public double MinimumMatchSeparationAngle
        {
            get { return _minMatchSeparationAngle; }
            set { _minMatchSeparationAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum difference in scale, expressed as a percentage, between two matches 
        /// that have unique scales. The method does not return matches that have the same position, 
        /// scale, and angle. Set this value to -1 if you do not want the method to use the scale of a 
        /// match to determine whether the match is unique. 
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public double MinimumMatchSeparationScale
        {
            get { return _minMatchSeparationScale; }
            set { _minMatchSeparationScale = value; }
        }  
        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum amount of overlap, expressed as a percentage, allowed 
        /// between the bounding rectangles of two unique matches. The method does not 
        /// return matches that exceed this overlap percentage. Set this value to 1 if you 
        /// want the method to ignore bounding rectangle overlap. 
        /// </summary>
        /// <value>
        /// The default is 80.
        /// </value>

        public double MaximumMatchOverlap
        {
            get { return _maxMatchOverlap; }
            set { _maxMatchOverlap = value; }
        } 
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether you want the method to spend less time accurately 
        /// estimating the location of a match. Set this value to <see langword="true"/> if you want 
        /// to quickly determine whether a part is present in the inspection image 
        /// without an accurate estimate of its position, angle, and scale. Set 
        /// this value to <see langword="false"/> to specify that the method returns matches with 
        /// pixel or subpixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool CoarseResult
        {
            get { return _coarseResult; }
            set { _coarseResult = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to treat the inspection image as a calibrated image. Set this 
        /// parameter to <see langword="true"/> to specify that the method treat the inspection 
        /// image as a calibrated image. Use the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.SetSimpleCalibration" crefType="Unqualified"/>
        /// method or the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.CopyCalibrationInformation" crefType="Unqualified"/>
        /// method to calibrate the inspection image. 
        /// </summary>
        /// <value>
        /// The default is <see langword="true"/>.
        /// </value>

        public bool EnableCalibrationSupport
        {
            get { return _enableCalibrationSupport; }
            set { _enableCalibrationSupport = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the contrast of the matches in the target image in relation to the contrast of the template.
        /// </summary>
        /// <value>
        /// The default value is Original.
        /// </value>

        public ContrastMode ContrastMode
        {
            get { return _contrastMode; }
            set { _contrastMode = value; }
        } 
        //==========================================================================================
        /// <summary>
        /// Gets or sets the aggressiveness of the search strategy.
        /// </summary>
        /// <value>
        /// The default is Balanced. 
        /// </value>

        public GeometricMatchingSearchStrategy MatchStrategy
        {
            get { return _matchStrategy; }
            set { _matchStrategy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the factor that is applied to the number of matches requested by 
        /// the user to determine the number of matches that are refined at the initial matching stage. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 RefineMatchFactor
        {
            get { return _refineMatchFactor; }
            set { _refineMatchFactor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the factor that is applied to the number of matches requested by 
        /// the user to determine the number of matches that are evaluated at the final 
        /// subpixel matching stage. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 SubpixelMatchFactor
        {
            get { return _subpixelMatchFactor; }
            set { _subpixelMatchFactor = value; }
        }   
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternEdgeBasedAdvancedOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchGeometricPatternEdgeBasedAdvancedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchGeometricPatternEdgeBasedAdvancedOptions other)
        {
            return  other != null && 
                    _subpixelIterations ==  other._subpixelIterations &&         
                    _subpixelTolerance  == other._subpixelTolerance  &&
                    _initialMatchListLength == other._initialMatchListLength &&     
                    _targetTemplateCurveScore == other._targetTemplateCurveScore &&    
                    _correlationScore == other._correlationScore &&           
                    _minMatchSeparationDistance == other._minMatchSeparationDistance && 
                    _minMatchSeparationAngle == other._minMatchSeparationAngle &&   
                    _minMatchSeparationScale == other._minMatchSeparationScale &&    
                    _maxMatchOverlap == other._maxMatchOverlap &&            
                    _coarseResult == other._coarseResult &&               
                    _enableCalibrationSupport == other._enableCalibrationSupport &&
                    _contrastMode == other._contrastMode &&     
                    _matchStrategy == other._matchStrategy &&              
                    _refineMatchFactor == other._refineMatchFactor &&
                    _subpixelMatchFactor == other._subpixelMatchFactor;                 
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternEdgeBasedAdvancedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchGeometricPatternEdgeBasedAdvancedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchGeometricPatternEdgeBasedAdvancedOptions other = (MatchGeometricPatternEdgeBasedAdvancedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return  _subpixelIterations.GetHashCode() ^
                    _subpixelTolerance.GetHashCode() ^
                    _initialMatchListLength.GetHashCode() ^
                    _targetTemplateCurveScore.GetHashCode() ^
                    _correlationScore.GetHashCode() ^
                    _minMatchSeparationDistance.GetHashCode() ^
                    _minMatchSeparationAngle.GetHashCode() ^
                    _minMatchSeparationScale.GetHashCode() ^
                    _maxMatchOverlap.GetHashCode() ^
                    _coarseResult.GetHashCode() ^
                    _enableCalibrationSupport.GetHashCode() ^
                    _contrastMode.GetHashCode() ^
                    _matchStrategy.GetHashCode() ^
                    _refineMatchFactor.GetHashCode() ^
                    _subpixelMatchFactor.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchGeometricPatternEdgeBasedAdvancedOptions: MatchStrategy=" + _matchStrategy;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Sets parameters that are used during the matching process. 
    /// </summary>

    [Serializable]
    public sealed class MatchGeometricPatternFeatureBasedOptions : IEquatable<MatchGeometricPatternFeatureBasedOptions>
    {
        private MatchGeometricPatternFeatureBasedAdvancedOptions _advanced;
        private GeometricMatchModes _mode;
        private bool _subpixelAccuracy;
        private Collection<Range> _rotationAngleRanges;
        private Range _scaleRange;
        private Range _occlusionRange;
        private Int32 _numMatchesRequested;
        private double _minMatchScore;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternFeatureBasedOptions class.
        /// </summary>

        public MatchGeometricPatternFeatureBasedOptions(): this(GeometricMatchModes.ShiftInvariant, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternFeatureBasedOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>

        public MatchGeometricPatternFeatureBasedOptions(GeometricMatchModes mode): this(mode, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternFeatureBasedOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// Specifies the number of valid matches expected. 
        /// </param>

        public MatchGeometricPatternFeatureBasedOptions(GeometricMatchModes mode, Int32 numberOfMatchesRequested)
        {
            _advanced = new MatchGeometricPatternFeatureBasedAdvancedOptions();
            _mode = mode;
            _subpixelAccuracy = false;
            _rotationAngleRanges = new Collection<Range>();
            _scaleRange = new Range(90, 110);
            _occlusionRange = new Range(0, 25);
            _numMatchesRequested = numberOfMatchesRequested;
            _minMatchScore = (float) (800.0);
        }
        //==========================================================================================
        /// <summary>
        /// Gets a collection of angle ranges, where each range specifies how much you expect the template image to rotate in the image. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<Range> RotationAngleRanges
        {
            get { return _rotationAngleRanges; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a range that specifies the sizes of the pattern you expect to be in the image, 
        /// expressed as a ratio percentage representing the size of the pattern in the image 
        /// divided by size of the original pattern multiplied by 100.
        /// </summary>
        /// <value>
        /// The default is (90, 110).
        /// </value>

        public Range ScaleRange
        {
            get { return _scaleRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _scaleRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets what percentage of the template image you expect to be occluded in the image.
        /// </summary>
        /// <value>
        /// The default is (0, 25).
        /// </value>

        public Range OcclusionRange
        {
            get { return _occlusionRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _occlusionRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score a match can have for the method to consider the 
        /// match valid. Acceptable values range from 0 to 1,000. 
        /// </summary>
        /// <value>
        /// The default is 800.
        /// </value>

        public double MinimumMatchScore
        {
            get { return _minMatchScore; }
            set { _minMatchScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of valid matches expected. 
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public Int32 NumberOfMatchesRequested
        {
            get { return _numMatchesRequested; }
            set { _numMatchesRequested = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to calculate match locations with subpixel accuracy. Set this 
        /// parameter to <see langword="true"/> to specify that the function should calculate 
        /// match locations with subpixel accuracy. Set this element to <see langword="false"/> 
        /// to specify that the function should calculate match locations with pixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method looks for the pattern in the image.
        /// </summary>
        /// <value>
        /// The default is ShiftInvariant.
        /// </value>

        [CLSCompliant(false)]
        public GeometricMatchModes Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the advanced options to the algorithm.
        /// </summary>

        public MatchGeometricPatternFeatureBasedAdvancedOptions Advanced
        {
            get { return _advanced; }	 
            set { if (value == null) { throw new ArgumentNullException("value"); } _advanced = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternFeatureBasedOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchGeometricPatternFeatureBasedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchGeometricPatternFeatureBasedOptions other)
        {
            return other != null && Object.Equals(_advanced, other._advanced) && _mode == other._mode && _subpixelAccuracy == other._subpixelAccuracy && Utilities.CollectionsEqual(_rotationAngleRanges, other._rotationAngleRanges) && _scaleRange.Equals(other._scaleRange) && _occlusionRange.Equals(other._occlusionRange) && _numMatchesRequested == other._numMatchesRequested && _minMatchScore == other._minMatchScore;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternFeatureBasedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchGeometricPatternFeatureBasedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchGeometricPatternFeatureBasedOptions other = (MatchGeometricPatternFeatureBasedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _advanced.GetHashCode() ^ _mode.GetHashCode() ^ _subpixelAccuracy.GetHashCode() ^ _rotationAngleRanges.Count.GetHashCode() ^ _scaleRange.GetHashCode() ^ _occlusionRange.GetHashCode() ^  _numMatchesRequested.GetHashCode() ^ _minMatchScore.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchGeometricPatternFeatureBasedOptions: Mode=" + _mode.ToString() + ", NumberOfMatchesRequested=" + _numMatchesRequested.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Sets parameters that are used during the matching process. 
    /// </summary>

    [Serializable]
    public sealed class MatchGeometricPatternEdgeBasedOptions : IEquatable<MatchGeometricPatternEdgeBasedOptions>
    {
        private MatchGeometricPatternEdgeBasedAdvancedOptions _advanced;
        private GeometricMatchModes _mode;
        private bool _subpixelAccuracy;
        private Collection<Range> _rotationAngleRanges;
        private Range _scaleRange;
        private Range _occlusionRange;
        private Int32 _numMatchesRequested;
        private double _minMatchScore;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternEdgeBasedOptions class.
        /// </summary>

        public MatchGeometricPatternEdgeBasedOptions(): this(GeometricMatchModes.ShiftInvariant, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternEdgeBasedOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>

        public MatchGeometricPatternEdgeBasedOptions(GeometricMatchModes mode): this(mode, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchGeometricPatternEdgeBasedOptions class.
        /// </summary>
        /// <param name="mode">
        /// Specifies how the method looks for the pattern in the image.
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// Specifies the number of valid matches expected. 
        /// </param>

        public MatchGeometricPatternEdgeBasedOptions(GeometricMatchModes mode, Int32 numberOfMatchesRequested)
        {
            _advanced = new MatchGeometricPatternEdgeBasedAdvancedOptions();
            _mode = mode;
            _subpixelAccuracy = false;
            _rotationAngleRanges = new Collection<Range>();
            _scaleRange = new Range(90, 110);
            _occlusionRange = new Range(0, 25);
            _numMatchesRequested = numberOfMatchesRequested;
            _minMatchScore = (float) (800.0);
        }
        //==========================================================================================
        /// <summary>
        /// Gets a collection of angle ranges, where each range specifies how much you expect the template image to rotate in the image. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<Range> RotationAngleRanges
        {
            get { return _rotationAngleRanges; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a range that specifies the sizes of the pattern you expect to be in the image, 
        /// expressed as a ratio percentage representing the size of the pattern in the image 
        /// divided by size of the original pattern multiplied by 100.
        /// </summary>
        /// <value>
        /// The default is (90, 110).
        /// </value>

        public Range ScaleRange
        {
            get { return _scaleRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _scaleRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets what percentage of the template image you expect to be occluded in the image.
        /// </summary>
        /// <value>
        /// The default is (0, 25).
        /// </value>

        public Range OcclusionRange
        {
            get { return _occlusionRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _occlusionRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score a match can have for the method to consider the 
        /// match valid. Acceptable values range from 0 to 1,000. 
        /// </summary>
        /// <value>
        /// The default is 800.
        /// </value>

        public double MinimumMatchScore
        {
            get { return _minMatchScore; }
            set { _minMatchScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of valid matches expected. 
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public Int32 NumberOfMatchesRequested
        {
            get { return _numMatchesRequested; }
            set { _numMatchesRequested = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to calculate match locations with subpixel accuracy. Set this 
        /// parameter to <see langword="true"/> to specify that the function should calculate 
        /// match locations with subpixel accuracy. Set this element to <see langword="false"/> 
        /// to specify that the function should calculate match locations with pixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method looks for the pattern in the image.
        /// </summary>
        /// <value>
        /// The default is ShiftInvariant.
        /// </value>

        [CLSCompliant(false)]
        public GeometricMatchModes Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the advanced options to the algorithm.
        /// </summary>

        public MatchGeometricPatternEdgeBasedAdvancedOptions Advanced
        {
            get { return _advanced; }	 
            set { if (value == null) { throw new ArgumentNullException("value"); } _advanced = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternEdgeBasedOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchGeometricPatternEdgeBasedOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchGeometricPatternEdgeBasedOptions other)
        {
            return other != null && Object.Equals(_advanced, other._advanced) && _mode == other._mode && _subpixelAccuracy == other._subpixelAccuracy && Utilities.CollectionsEqual(_rotationAngleRanges, other._rotationAngleRanges) && _scaleRange.Equals(other._scaleRange) && _occlusionRange.Equals(other._occlusionRange) && _numMatchesRequested == other._numMatchesRequested && _minMatchScore == other._minMatchScore;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchGeometricPatternEdgeBasedOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchGeometricPatternEdgeBasedOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchGeometricPatternEdgeBasedOptions other = (MatchGeometricPatternEdgeBasedOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _advanced.GetHashCode() ^ _mode.GetHashCode() ^ _subpixelAccuracy.GetHashCode() ^ _rotationAngleRanges.Count.GetHashCode() ^ _scaleRange.GetHashCode() ^ _occlusionRange.GetHashCode() ^  _numMatchesRequested.GetHashCode() ^ _minMatchScore.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchGeometricPatternEdgeBasedOptions: Mode=" + _mode.ToString() + ", NumberOfMatchesRequested=" + _numMatchesRequested.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a circle feature.
    /// </summary>

    [Serializable]
    public sealed class CircleFeature : IEquatable<CircleFeature>
    {
        private PointContour _position;
        private double _radius;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CircleFeature class.
        /// </summary>

        public CircleFeature()
        {
            _position = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the radius of the circle.
        /// </summary>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the circle. 
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleFeature.
        /// </summary>
        /// <param name="other">
        /// A CircleFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CircleFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && _radius == other._radius;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CircleFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CircleFeature other = (CircleFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _radius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CircleFeature: Position=" + _position.ToString() + ", Radius=" + _radius.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Gets or sets an ellipse feature.
    /// </summary>

    [Serializable]
    public sealed class EllipseFeature : IEquatable<EllipseFeature>
    {
        private PointContour _position;
        private double _rotation;
        private double _minorRadius;
        private double _majorRadius;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EllipseFeature class.
        /// </summary>

        public EllipseFeature()
        {
            _position = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the semi-major axis of the ellipse. 
        /// </summary>

        public double MajorRadius
        {
            get { return _majorRadius; }
            set { _majorRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the semi-minor axis of the ellipse. 
        /// </summary>

        public double MinorRadius
        {
            get { return _minorRadius; }
            set { _minorRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the semi-major axis of the ellipse with respect to the horizontal. 
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the ellipse.
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseFeature.
        /// </summary>
        /// <param name="other">
        /// A EllipseFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EllipseFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && _rotation == other._rotation && _majorRadius == other._majorRadius && _minorRadius == other._minorRadius;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EllipseFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EllipseFeature other = (EllipseFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _majorRadius.GetHashCode() ^ _minorRadius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EllipseFeature: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a constant curve feature.
    /// </summary>

    [Serializable]
    public sealed class ConstCurveFeature : IEquatable<ConstCurveFeature>
    {
        private PointContour _position;
        private double _radius;
        private double _startAngle;
        private double _endAngle;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConstCurveFeature class.
        /// </summary>

        public ConstCurveFeature()
        {
            _position = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the ending angle in degrees. When traveling along the constant curve from one endpoint to the next in a counterclockwise manner, this is the angular component of the vector originating at the center of the constant curve and pointing towards the second endpoint of the constant curve. 
        /// </summary>

        public double EndAngle
        {
            get { return _endAngle; }
            set { _endAngle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the starting angle in degrees. When traveling along the constant curve from one endpoint to the next in a counterclockwise manner, this is the angular component of the vector originating at the center of the constant curve and pointing towards the first endpoint of the constant curve.
        /// </summary>

        public double StartAngle
        {
            get { return _startAngle; }
            set { _startAngle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the radius of the circle that this constant curve lies upon.
        /// </summary>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the center of the circle that this constant curve lies upon. 
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConstCurveFeature.
        /// </summary>
        /// <param name="other">
        /// A ConstCurveFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ConstCurveFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && _radius == other._radius && _startAngle == other._startAngle && _endAngle == other._endAngle;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConstCurveFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ConstCurveFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ConstCurveFeature other = (ConstCurveFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _radius.GetHashCode() ^ _startAngle.GetHashCode() ^ _endAngle.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ConstCurveFeature: Position=" + _position.ToString() + ", Radius=" + _radius.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing a rectangle feature.
    /// </summary>
    /// <remarks>
    /// Width is defined as the length of the shorter side of a rectangle and height is defined as the longer side of the rectangle.
    /// </remarks>

    [Serializable]
    public sealed class RectangleFeature : IEquatable<RectangleFeature>
    {
        private PointContour _position;
        private Collection<PointContour> _corners;
        private double _rotation;
        private double _width;
        private double _height;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RectangleFeature class.
        /// </summary>

        public RectangleFeature()
        {
            _position = new PointContour();
            _corners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the rectangle.
        /// </summary>
        /// <value>
        /// </value>

        public double Height
        {
            get { return _height; }
            set { _height = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the rectangle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the rectangle with respect to the horizontal. 
        /// </summary>
        /// <value>
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the four corners of the rectangle.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the center of the rectangle.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleFeature.
        /// </summary>
        /// <param name="other">
        /// A RectangleFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RectangleFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && Utilities.CollectionsEqual(_corners, other._corners) && _rotation == other._rotation && _width == other._width && _height == other.Height;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RectangleFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RectangleFeature other = (RectangleFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _width.GetHashCode() ^ _height.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RectangleFeature: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture);
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Describes a leg feature.
    /// </summary>

    [Serializable]
    public sealed class LegFeature : IEquatable<LegFeature>
    {
        private PointContour _position;
        private Collection<PointContour> _corners;
        private double _rotation;
        private double _width;
        private double _height;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LegFeature class.
        /// </summary>

        public LegFeature()
        {
            _position = new PointContour();
            _corners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the leg.
        /// </summary>

        public double Height
        {
            get { return _height; }
            set { _height = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the leg.
        /// </summary>

        public double Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the leg with respect to the horizontal.
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the coordinates of the four corners of the leg feature. 
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the leg feature. The location is the center of the segment adjoining the two parallel sides.
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LegFeature.
        /// </summary>
        /// <param name="other">
        /// A LegFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LegFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && Utilities.CollectionsEqual(_corners, other._corners) && _rotation == other._rotation && _width == other._width && _height == other.Height;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LegFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LegFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LegFeature other = (LegFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _width.GetHashCode() ^ _height.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LegFeature: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a corner feature.
    /// </summary>

    [Serializable]
    public sealed class CornerFeature : IEquatable<CornerFeature>
    {
        private PointContour _position;
        private double _rotation;
        private double _enclosedAngle;
        private bool _isVirtual;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CornerFeature class.
        /// </summary>

        public CornerFeature()
        {
            _position = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether a corner is virtual. This parameter is <see langword="true"/> if the corner is 
        /// virtual and <see langword="false"/> if the corner is not virtual. A virtual corner is a corner that 
        /// would be created if two non-intersecting lines are extended until they intersect. 
        /// </summary>

        public bool IsVirtual
        {
            get { return _isVirtual; }
            set { _isVirtual = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the measure of the enclosed angle of the corner. 
        /// </summary>

        public double EnclosedAngle
        {
            get { return _enclosedAngle; }
            set { _enclosedAngle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angular component of the vector bisecting the corner from Position.
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the corner feature.
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CornerFeature.
        /// </summary>
        /// <param name="other">
        /// A CornerFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CornerFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && _rotation == other._rotation && _enclosedAngle == other._enclosedAngle && _isVirtual == other._isVirtual;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CornerFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CornerFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CornerFeature other = (CornerFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _enclosedAngle.GetHashCode() ^ _isVirtual.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CornerFeature: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a parallel line pair feature.
    /// </summary>

    [Serializable]
    public sealed class ParallelLinePairFeature : IEquatable<ParallelLinePairFeature>
    {
        private LineContour _firstLine;
        private LineContour _secondLine;
        private double _rotation;
        private double _distance;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParallelLinePairFeature class.
        /// </summary>

        public ParallelLinePairFeature()
        {
            _firstLine = new LineContour();
            _secondLine = new LineContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance from the first line to the second line. 
        /// </summary>
        /// <value>
        /// </value>

        public double Distance
        {
            get { return _distance; }
            set { _distance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the feature with respect to the horizontal. 
        /// </summary>
        /// <value>
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the starting point and ending point of the second line of the pair. 
        /// </summary>
        /// <value>
        /// </value>

        public LineContour SecondLine
        {
            get { return _secondLine; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _secondLine = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the starting point and ending point of the first line of the pair. 
        /// </summary>
        /// <value>
        /// </value>

        public LineContour FirstLine
        {
            get { return _firstLine; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _firstLine = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParallelLinePairFeature.
        /// </summary>
        /// <param name="other">
        /// A ParallelLinePairFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParallelLinePairFeature other)
        {
            return other != null && Object.Equals(_firstLine, other._firstLine) && Object.Equals(_secondLine, other._secondLine) && _rotation == other._rotation && _distance == other._distance;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParallelLinePairFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParallelLinePairFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParallelLinePairFeature other = (ParallelLinePairFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstLine.GetHashCode() ^ _secondLine.GetHashCode() ^ _rotation.GetHashCode() ^ _distance.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParallelLinePairFeature: FirstLine=" + _firstLine.ToString() + ", SecondLine=" + _secondLine.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a pair of parallel line pairs feature.
    /// </summary>

    [Serializable]
    public sealed class PairOfParallelLinePairsFeature : IEquatable<PairOfParallelLinePairsFeature>
    {
        private ParallelLinePairFeature _firstParallelLinePair;
        private ParallelLinePairFeature _secondParallelLinePair;
        private double _rotation;
        private double _distance;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PairOfParallelLinePairsFeature class.
        /// </summary>

        public PairOfParallelLinePairsFeature()
        {
            _firstParallelLinePair = new ParallelLinePairFeature();
            _secondParallelLinePair = new ParallelLinePairFeature();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance from the midline of the first parallel line pair to the midline of the second parallel line pair. 
        /// </summary>
        /// <value>
        /// </value>

        public double Distance
        {
            get { return _distance; }
            set { _distance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the feature with respect to the horizontal. 
        /// </summary>
        /// <value>
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the second parallel line pair. 
        /// </summary>
        /// <value>
        /// </value>

        public ParallelLinePairFeature SecondParallelLinePair
        {
            get { return _secondParallelLinePair; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _secondParallelLinePair = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the first parallel line pair. 
        /// </summary>
        /// <value>
        /// </value>

        public ParallelLinePairFeature FirstParallelLinePair
        {
            get { return _firstParallelLinePair; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _firstParallelLinePair = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PairOfParallelLinePairsFeature.
        /// </summary>
        /// <param name="other">
        /// A PairOfParallelLinePairsFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PairOfParallelLinePairsFeature other)
        {
            return other != null && Object.Equals(_firstParallelLinePair, other._firstParallelLinePair) && Object.Equals(_secondParallelLinePair, other._secondParallelLinePair) && _rotation == other._rotation && _distance == other._distance;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PairOfParallelLinePairsFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PairOfParallelLinePairsFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PairOfParallelLinePairsFeature other = (PairOfParallelLinePairsFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstParallelLinePair.GetHashCode() ^ _secondParallelLinePair.GetHashCode() ^ _rotation.GetHashCode() ^ _distance.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PairOfParallelLinePairsFeature: FirstParallelLinePair=" + _firstParallelLinePair.ToString() + ", SecondParallelLinePair=" +  _secondParallelLinePair.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a line feature.
    /// </summary>

    [Serializable]
    public sealed class LineFeature : IEquatable<LineFeature>
    {
        private LineContour _line;
        private double _length;
        private double _rotation;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineFeature class.
        /// </summary>

        public LineFeature()
        {
            _line = new LineContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the line with respect to the horizontal.
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the line measured in pixels from the start point to the end point. 
        /// </summary>

        public double Length
        {
            get { return _length; }
            set { _length = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the line.
        /// </summary>

        public LineContour Line
        {
            get { return _line; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _line = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineFeature.
        /// </summary>
        /// <param name="other">
        /// A LineFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LineFeature other)
        {
            return other != null && Object.Equals(_line, other._line) && _length == other._length && _rotation == other._rotation;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LineFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LineFeature other = (LineFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _line.GetHashCode() ^ _length.GetHashCode() ^ _rotation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LineFeature: Line=" + _line.ToString() + ", Length=" + _length.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a closed curve feature.
    /// </summary>

    [Serializable]
    public sealed class ClosedCurveFeature : IEquatable<ClosedCurveFeature>
    {
        private PointContour _position;
        private double _arcLength;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClosedCurveFeature class.
        /// </summary>

        public ClosedCurveFeature()
        {
            _position = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the arc length of the closed curve feature. 
        /// </summary>

        public double ArcLength
        {
            get { return _arcLength; }
            set { _arcLength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the center of the closed curve feature. 
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClosedCurveFeature.
        /// </summary>
        /// <param name="other">
        /// A ClosedCurveFeature instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClosedCurveFeature other)
        {
            return other != null && Object.Equals(_position, other._position) && _arcLength == other._arcLength;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClosedCurveFeature.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClosedCurveFeature
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClosedCurveFeature other = (ClosedCurveFeature)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _arcLength.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClosedCurveFeature: Position=" + _position.ToString() + ", ArcLength=" + _arcLength.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describe a generic geometric matching feature.
    /// </summary>

    [Serializable]
    public sealed class GeometricFeatureData
    {
        private GeometricFeatureType _featureType;
        private Collection<PointContour> _contourPoints;
        private object _feature;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricFeatureData class.
        /// </summary>
        /// <param name="featureType">
        /// Specifies the feature type.
        /// </param>

        public GeometricFeatureData(GeometricFeatureType featureType)
        {
            _featureType = featureType;
            _contourPoints = new Collection<PointContour>();
            switch (_featureType)
            {
                case GeometricFeatureType.None:
                    _feature = new object();
                    break;
                case GeometricFeatureType.Circle:
                    _feature = new CircleFeature();
                    break;
                case GeometricFeatureType.Ellipse:
                    _feature = new EllipseFeature();
                    break;
                case GeometricFeatureType.ConstCurve:
                    _feature = new ConstCurveFeature();
                    break;
                case GeometricFeatureType.Rectangle:
                    _feature = new RectangleFeature();
                    break;
                case GeometricFeatureType.Leg:
                    _feature = new LegFeature();
                    break;
                case GeometricFeatureType.Corner:
                    _feature = new CornerFeature();
                    break;
                case GeometricFeatureType.ParallelLinePair:
                    _feature = new ParallelLinePairFeature();
                    break;
                case GeometricFeatureType.PairOfParallelLinePairs:
                    _feature = new PairOfParallelLinePairsFeature();
                    break;
                case GeometricFeatureType.Line:
                    _feature = new LineFeature();
                    break;
                case GeometricFeatureType.ClosedCurve:
                    _feature = new ClosedCurveFeature();
                    break;
                default:
                    // Just create something so it isn't null.
                    _feature = new object();
                    break;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the feature data specific to this type of feature. 
        /// </summary>

        public object Feature
        {
            get { return _feature; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _feature = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a set of points describing the contour of the feature. 
        /// </summary>

        public Collection<PointContour> ContourPoints
        {
            get { return _contourPoints; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _contourPoints = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the feature type.
        /// </summary>

        public GeometricFeatureType FeatureType
        {
            get { return _featureType; }
            set { _featureType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricFeatureData.
        /// </summary>
        /// <param name="other">
        /// A GeometricFeatureData instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(GeometricFeatureData other)
        {
            return other != null && _featureType == other._featureType && Utilities.CollectionsEqual(_contourPoints, other._contourPoints) && Object.Equals(_feature, other._feature);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricFeatureData.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GeometricFeatureData and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            GeometricFeatureData other = (GeometricFeatureData)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _featureType.GetHashCode() ^ _contourPoints.Count.GetHashCode() ^ _feature.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GeometricFeatureData: FeatureType=" + _featureType.ToString() + ", Feature=" + _feature.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing a matched geometric pattern.
    /// </summary>

    [Serializable]
    public sealed class GeometricFeatureBasedPatternMatch : IEquatable<GeometricFeatureBasedPatternMatch>
    {
        private PointContour _position;
        private double _rotation;
        private double _scale;
        private double _score;
        private Collection<PointContour> _corners;
        private bool _inverse;
        private double _occlusion;
        private double _templateMatchCurveScore;
        private double _matchTemplateCurveScore;
        private double _correlationScore;
        private Collection<GeometricFeatureData> _features;
        private PointContour _calibratedPosition;
        private double _calibratedRotation;
        private Collection<PointContour> _calibratedCorners;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricFeatureBasedPatternMatch class.
        /// </summary>

        public GeometricFeatureBasedPatternMatch()
        {
            _position = new PointContour();
            _corners = new Collection<PointContour>();
            _features = new Collection<GeometricFeatureData>();
            _calibratedPosition = new PointContour();
            _calibratedCorners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets an array of four points describing the rectangle surrounding the template image.
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value describes the calibrated rectangle. 
        /// </remarks>

        public Collection<PointContour> CalibratedCorners
        {
            get { return _calibratedCorners; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _calibratedCorners = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees. 
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value is in real-world units. Otherwise, this value is the same as <see cref="NationalInstruments.Vision.Analysis.GeometricFeatureBasedPatternMatch.Rotation" crefType="Unqualified"/>. 
        /// </remarks>

        public double CalibratedRotation
        {
            get { return _calibratedRotation; }
            set { _calibratedRotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the origin of the template in the match. 
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value is in real-world units. Otherwise, this value is the same as <see cref="NationalInstruments.Vision.Analysis.GeometricFeatureBasedPatternMatch.Position" crefType="Unqualified"/>. 
        /// </remarks>

        public PointContour CalibratedPosition
        {
            get { return _calibratedPosition; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _calibratedPosition = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the features uses in this match.
        /// </summary>

        public Collection<GeometricFeatureData> Features
        {
            get { return _features; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }  _features = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match obtained by comparing the template image to the match region using a correlation metric that compares the two regions as a function of their pixel values.
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match.
        /// </remarks>

        public double CorrelationScore
        {
            get { return _correlationScore; }
            set { _correlationScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match obtained by comparing the curves in the match region to the template curves. 
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </remarks>

        public double MatchTemplateCurveScore
        {
            get { return _matchTemplateCurveScore; }
            set { _matchTemplateCurveScore = value; }
        }

        //==========================================================================================
        /// <summary>Gets or sets the accuracy of the match obtained by comparing the template curves to the curves in the match region. 
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </remarks>

        public double TemplateMatchCurveScore
        {
            get { return _templateMatchCurveScore; }
            set { _templateMatchCurveScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the percentage of the match that is occluded. 
        /// </summary>

        public double Occlusion
        {
            get { return _occlusion; }
            set { _occlusion = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the match is an inverse of the template image. 
        /// </summary>
        /// <remarks>
        /// This element is <see langword="true"/> if the match is an inverse of the template image. For example, the match is a white object on a black background 
        /// but the template image is a black object on a white background. This element is <see langword="false"/> if the match and the template image have the same 
        /// contrast with the image background. 
        /// </remarks>

        public bool Inverse
        {
            get { return _inverse; }
            set { _inverse = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of four points describing the rectangle surrounding the template image. 
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _corners = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match. A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the match relative to the size of the template image, expressed as a percentage. 
        /// </summary>

        public double Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees. 
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the origin of the template in the match. 
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricFeatureBasedPatternMatch.
        /// </summary>
        /// <param name="other">
        /// A GeometricFeatureBasedPatternMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(GeometricFeatureBasedPatternMatch other)
        {
            return other != null &&
                Object.Equals(_position, other._position) &&
                _rotation == other._rotation &&
                _scale == other._scale &&
                _score == other._score &&
                Utilities.CollectionsEqual(_corners, other._corners) &&
                _inverse == other._inverse &&
                _occlusion == other._occlusion &&
                _templateMatchCurveScore == other._templateMatchCurveScore &&
                _matchTemplateCurveScore == other._matchTemplateCurveScore &&
                _correlationScore == other._correlationScore &&
                Utilities.CollectionsEqual(_features, other._features) &&
                Object.Equals(_calibratedPosition, other._calibratedPosition) &&
                _calibratedRotation == other._calibratedRotation &&
                Utilities.CollectionsEqual(_calibratedCorners, other._calibratedCorners);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricFeatureBasedPatternMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GeometricFeatureBasedPatternMatch and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            GeometricFeatureBasedPatternMatch other = (GeometricFeatureBasedPatternMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _scale.GetHashCode() ^ _score.GetHashCode() ^ _inverse.GetHashCode() ^ _occlusion.GetHashCode() ^ _templateMatchCurveScore.GetHashCode() ^ _matchTemplateCurveScore.GetHashCode() ^ _correlationScore.GetHashCode() ^ _features.Count.GetHashCode() ^ _calibratedPosition.GetHashCode() ^ _calibratedRotation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GeometricFeatureBasedPatternMatch: Position=" + _position.ToString() + ", Rotation=" + _rotation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing a matched geometric pattern.
    /// </summary>

    [Serializable]
    public sealed class GeometricEdgeBasedPatternMatch : IEquatable<GeometricEdgeBasedPatternMatch>
    {
        private PointContour _position;
        private double _rotation;
        private double _scale;
        private double _score;
        private Collection<PointContour> _corners;
        private bool _inverse;
        private double _occlusion;
        private double _templateMatchCurveScore;
        private double _matchTemplateCurveScore;
        private double _correlationScore;
        private PointContour _calibratedPosition;
        private double _calibratedRotation;
        private Collection<PointContour> _calibratedCorners;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricEdgeBasedPatternMatch class.
        /// </summary>

        public GeometricEdgeBasedPatternMatch()
        {
            _position = new PointContour();
            _corners = new Collection<PointContour>();
            _calibratedPosition = new PointContour();
            _calibratedCorners = new Collection<PointContour>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of four points describing the rectangle surrounding the template image. 
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets an array of four points describing the rectangle surrounding the template image.
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value describes the calibrated rectangle. 
        /// </remarks>

        public Collection<PointContour> CalibratedCorners
        {
            get { return _calibratedCorners; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match. A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the match relative to the size of the template image, expressed as a percentage. 
        /// </summary>

        public double Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees. 
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the match is an inverse of the template image. 
        /// </summary>
        /// <remarks>
        /// This element is <see langword="true"/> if the match is an inverse of the template image. For example, the match is a white object on a black background 
        /// but the template image is a black object on a white background. This element is <see langword="false"/> if the match and the template image have the same 
        /// contrast with the image background. 
        /// </remarks>

        public bool Inverse
        {
            get { return _inverse; }
            set { _inverse = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the percentage of the match that is occluded. 
        /// </summary>

        public double Occlusion
        {
            get { return _occlusion; }
            set { _occlusion = value; }
        }
        //==========================================================================================
        /// <summary>Gets or sets the accuracy of the match obtained by comparing the template curves to the curves in the match region. 
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match. 
        /// </remarks>

        public double TemplateMatchCurveScore
        {
            get { return _templateMatchCurveScore; }
            set { _templateMatchCurveScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match obtained by comparing the curves in the match region to the template curves. 
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match.
        /// </remarks>

        public double MatchTemplateCurveScore
        {
            get { return _matchTemplateCurveScore; }
            set { _matchTemplateCurveScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the match obtained by comparing the template image to the match region using a correlation metric that compares the two regions as a function of their pixel values.
        /// </summary>
        /// <remarks>
        /// A score of 1,000 indicates a perfect match, and a score of 0 indicates no match.
        /// </remarks>

        public double CorrelationScore
        {
            get { return _correlationScore; }
            set { _correlationScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rotation of the match relative to the template image, in degrees. 
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value is in real-world units. Otherwise, this value is the same as <see cref="NationalInstruments.Vision.Analysis.GeometricEdgeBasedPatternMatch.Rotation" crefType="Unqualified"/>. 
        /// </remarks>

        public double CalibratedRotation
        {
            get { return _calibratedRotation; }
            set { _calibratedRotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the origin of the template in the match. 
        /// </summary>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the origin of the template in the match. 
        /// </summary>
        /// <remarks>
        /// If the image where the match is found is a calibrated image, then this value is in real-world units. Otherwise, this value is the same as <see cref="NationalInstruments.Vision.Analysis.GeometricEdgeBasedPatternMatch.Position" crefType="Unqualified"/>. 
        /// </remarks>

        public PointContour CalibratedPosition
        {
            get { return _calibratedPosition; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _calibratedPosition = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricEdgeBasedPatternMatch.
        /// </summary>
        /// <param name="other">
        /// A GeometricEdgeBasedPatternMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(GeometricEdgeBasedPatternMatch other)
        {
            return other != null && Object.Equals(_position, other._position) && 
                   _rotation == other._rotation && 
                   _scale == other._scale && 
                   _score == other._score && 
                   Object.Equals(_corners, other._corners) && 
                   _inverse == other._inverse &&
                   _occlusion == other._occlusion &&
                   _templateMatchCurveScore == other._templateMatchCurveScore &&
                   _matchTemplateCurveScore == other._matchTemplateCurveScore &&
                   _correlationScore == other._correlationScore &&
                   Object.Equals(_calibratedPosition, other._calibratedPosition) && 
                   _calibratedRotation == other._calibratedRotation && 
                   Object.Equals(_calibratedCorners, other._calibratedCorners);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricEdgeBasedPatternMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GeometricEdgeBasedPatternMatch and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            GeometricEdgeBasedPatternMatch other = (GeometricEdgeBasedPatternMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _rotation.GetHashCode() ^ _scale.GetHashCode() ^ _score.GetHashCode() ^ _inverse.GetHashCode() ^ _occlusion.GetHashCode() ^ _templateMatchCurveScore.GetHashCode() ^ _matchTemplateCurveScore.GetHashCode() ^ _calibratedPosition.GetHashCode() ^ _calibratedRotation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GeometricEdgeBasedPatternMatch: Position=" + _position.ToString() + ", Corners=" + _corners.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how to transform pixel coordinates based on the difference between the reference coordinate system and the measurement coordinate system.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CoordinateTransform : IEquatable<CoordinateTransform>
    {
        private CoordinateSystem _referenceSystem;
        private CoordinateSystem _measurementSystem;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CoordinateTransform class.
        /// </summary>

        public CoordinateTransform()
            : this(new CoordinateSystem(), new CoordinateSystem())
        {
        }
        //==========================================================================================
        /// <summary>
        /// </summary>
        /// <param name="measurementSystem">The coordinate system in which the function should perform measurements. 
        /// </param>

        public CoordinateTransform(CoordinateSystem measurementSystem)
            : this(new CoordinateSystem(), measurementSystem)
        {
        }
        //==========================================================================================
        /// <summary>
        /// </summary>
        /// <param name="referenceSystem">The coordinate system for input coordinates. 
        /// </param>
        /// <param name="measurementSystem">The coordinate system in which the function should perform measurements. 
        /// </param>

        public CoordinateTransform(CoordinateSystem referenceSystem, CoordinateSystem measurementSystem)
        {
            if (referenceSystem == null) { throw new ArgumentNullException("referenceSystem"); }
            if (measurementSystem == null) { throw new ArgumentNullException("measurementSystem"); }
            _referenceSystem = referenceSystem;
            _measurementSystem = measurementSystem;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate system in which the function should perform measurements. 
        /// </summary>
        /// <value>
        /// </value>

        public CoordinateSystem MeasurementSystem
        {
            get { return _measurementSystem; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _measurementSystem = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate system for input coordinates. 
        /// </summary>
        /// <value>
        /// </value>

        public CoordinateSystem ReferenceSystem
        {
            get { return _referenceSystem; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _referenceSystem = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CoordinateTransform.
        /// </summary>
        /// <param name="other">
        /// A CoordinateTransform instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CoordinateTransform other)
        {
            return other != null && Object.Equals(_referenceSystem, other._referenceSystem) && Object.Equals(_measurementSystem, other._measurementSystem);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CoordinateTransform.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CoordinateTransform and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CoordinateTransform other = (CoordinateTransform)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _referenceSystem.GetHashCode() ^ _measurementSystem.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CoordinateTransform: ReferenceSystem=" + _referenceSystem + ", MeasurementSystem=" + _measurementSystem;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how to calibrate the image.
    /// </summary>

    [Serializable]
    public sealed class SimpleCalibrationOptions : IEquatable<SimpleCalibrationOptions>
    {
        private ScalingMethod _correctionScalingMethod;
        private CoordinateSystem _axisInfo;
        private bool _learnCorrectionTable;

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the correction table is processed and stored.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// The correction table accelerates the process of correcting an image. A correction table is useful if several images are 
        /// going to be corrected. If the current operation resets the real-world coordinate system, or if the correction table is 
        /// still required, the correction table is relearned.
        /// </remarks>

        public bool LearnCorrectionTable
        {
            get { return _learnCorrectionTable; }
            set { _learnCorrectionTable = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the reference coordinate system for the real-world coordinates. For an image that has already been 
        /// calibrated, this axis information overrides the old axis information.
        /// </summary>
        /// <value>
        /// </value>

        public CoordinateSystem AxisInfo
        {
            get { return _axisInfo; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _axisInfo = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the scaling to be used in the corrected image.
        /// </summary>
        /// <value>
        /// The default is ScaleToPreserveArea.
        /// </value>

        public ScalingMethod CorrectionScalingMethod
        {
            get { return _correctionScalingMethod; }
            set { _correctionScalingMethod = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleCalibrationOptions class.
        /// </summary>

        public SimpleCalibrationOptions()
            : this(new CoordinateSystem())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleCalibrationOptions class.
        /// </summary>
        /// <param name="axisInfo">
        /// The reference coordinate system for the real-world coordinates. For an image that has already been 
        /// calibrated, this axis information overrides the old axis information.
        /// </param>

        public SimpleCalibrationOptions(CoordinateSystem axisInfo)
            : this(axisInfo, ScalingMethod.ScaleToPreserveArea)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleCalibrationOptions class.
        /// </summary>
        /// <param name="axisInfo">
        /// The reference coordinate system for the real-world coordinates. For an image that has already been 
        /// calibrated, this axis information overrides the old axis information.
        /// </param>
        /// <param name="correctionScalingMethod">
        /// The scaling to use in the corrected image. The default is ScaleToPreserveArea.
        /// </param>

        public SimpleCalibrationOptions(CoordinateSystem axisInfo, ScalingMethod correctionScalingMethod)
        {
            _axisInfo = axisInfo;
            _correctionScalingMethod = correctionScalingMethod;
            _learnCorrectionTable = false;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SimpleCalibrationOptions.
        /// </summary>
        /// <param name="other">
        /// A SimpleCalibrationOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SimpleCalibrationOptions other)
        {
            return other != null && _correctionScalingMethod == other._correctionScalingMethod && Object.Equals(_axisInfo, other._axisInfo) && _learnCorrectionTable == other._learnCorrectionTable;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SimpleCalibrationOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SimpleCalibrationOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SimpleCalibrationOptions other = (SimpleCalibrationOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _correctionScalingMethod.GetHashCode() ^ _axisInfo.GetHashCode() ^ _learnCorrectionTable.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SimpleCalibrationOptions: CorrectionScalingMethod=" + _correctionScalingMethod.ToString() + ", AxisInfo=" + _axisInfo.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the converted coordinates that result from the ConvertRealWorldToPixelCoordinates or the ConvertPixelToRealWorldCoordinates methods.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CoordinatesReport : IEquatable<CoordinatesReport>
    {
        private Collection<PointContour> _points;
        private Collection<bool> _validPoints;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the converted coordinates.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Points
        {
            get { return _points; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_points = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of Boolean values that specify whether each of the coordinates is valid according to the region 
        /// selected in the CorrectionRegionMode of <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnCalibrationGrid" crefType="Unqualified"/> 
        /// or <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnCalibrationPoints" crefType="Unqualified"/>. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<bool> ValidPoints
        {
            get { return _validPoints; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_validPoints = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Creates and returns a CoordinatesReport object.
        /// </summary>

        public CoordinatesReport()
        {
            _points = new Collection<PointContour>();
            _validPoints = new Collection<bool>();
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CoordinatesReport.
        /// </summary>
        /// <param name="other">
        /// A CoordinatesReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CoordinatesReport other)
        {
            return other != null && Object.Equals(_points, other._points) && Object.Equals(_validPoints, other._validPoints);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CoordinatesReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CoordinatesReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CoordinatesReport other = (CoordinatesReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _points.GetHashCode() ^ _validPoints.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CoordinatesReport: Points=" + _points.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a particle in an image.
    /// </summary>

    [Serializable]
    public sealed class ParticleReport : IEquatable<ParticleReport>
    {
        private double _area;
        private RectangleContour _boundingRect;
        private PointContour _centerOfMass;
        private Int32 _numberOfHoles;
        private double _orientation;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the particle in degrees.
        /// </summary>

        public double Orientation
        {
            get { return _orientation; }
            set { _orientation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of holes in the particle.
        /// </summary>

        public Int32 NumberOfHoles
        {
            get { return _numberOfHoles; }
            set { _numberOfHoles = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the center of mass of the particle.
        /// </summary>

        public PointContour CenterOfMass
        {
            get { return _centerOfMass; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _centerOfMass = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the bounding rectangle of the particle.
        /// </summary>

        public RectangleContour BoundingRect
        {
            get { return _boundingRect; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _boundingRect = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the area of the particle.
        /// </summary>

        public double Area
        {
            get { return _area; }
            set { _area = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleReport class.
        /// </summary>

        public ParticleReport()
        {
            _centerOfMass = new PointContour();
            _boundingRect = new RectangleContour();
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleReport.
        /// </summary>
        /// <param name="other">
        /// A ParticleReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleReport other)
        {
            return other != null && _area == other._area && Object.Equals(_boundingRect, other._boundingRect) && Object.Equals(_centerOfMass, other._centerOfMass) && _numberOfHoles == other._numberOfHoles && _orientation == other._orientation;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleReport other = (ParticleReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _area.GetHashCode() ^ _boundingRect.GetHashCode() ^ _centerOfMass.GetHashCode() ^ _numberOfHoles.GetHashCode() ^ _orientation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleReport: CenterOfMass=" + _centerOfMass.ToString() + ", Area=" + _area.ToString(CultureInfo.CurrentCulture) + ", BoundingRect=" + _boundingRect.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the criteria used to filter particles in the image.
    /// </summary>

    [Serializable]
    public sealed class ParticleFilterCriteria : IEquatable<ParticleFilterCriteria>
    {
        private MeasurementType _parameter;
        private Range _range;
        private Boolean _calibrated;
        private RangeType _rangeType;

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to include or exclude the values given in Range. 
        /// <para>
        /// When RangeType is InsideRange, 
        /// the particle meets the criteria if Range Lower Value <entity value="le"/> particle measurement <entity value="lt"/> Range Upper Value.
        /// </para>
        /// 	<para>
        /// When RangeType is OutsideRange, the particle meets the criteria if Range Upper Value <entity value="ge"/>  particle measurement 
        /// or particle measurement <entity value="lt"/> Range Lower Value.
        /// </para>
        /// </summary>
        /// <value>
        /// The default is InsideRange.
        /// </value>

        public RangeType RangeType
        {
            get { return _rangeType; }
            set { _rangeType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to take calibrated measurements or pixel measurements. Set this parameter 
        /// to <see langword="true"/> to take calibrated measurements. Set this parameter to <see langword="false"/> 
        /// to take pixel measurements. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public Boolean Calibrated
        {
            get { return _calibrated; }
            set { _calibrated = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range for the measurement chosen in Parameter.
        /// </summary>

        public Range Range
        {
            get { return _range; }
            set { _range = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the morphological measurement that the method uses for filtering. 
        /// </summary>

        public MeasurementType Parameter
        {
            get { return _parameter; }
            set { _parameter = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterCriteria class.
        /// </summary>
        /// <param name="parameter">
        /// The morphological measurement that the method uses for filtering. 
        /// </param>
        /// <param name="range">
        /// The range for the measurement chosen in parameter.
        /// </param>

        public ParticleFilterCriteria(MeasurementType parameter, Range range)
            : this(parameter, range, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterCriteria class.
        /// </summary>
        /// <param name="parameter">
        /// The morphological measurement that the method uses for filtering. 
        /// </param>
        /// <param name="range">
        /// The range for the measurement chosen in parameter.
        /// </param>
        /// <param name="calibrated">
        /// Specifies whether to take calibrated measurements or pixel measurements. Set this parameter 
        /// to <see langword="true"/> to take calibrated measurements. Set this parameter to <see langword="false"/> 
        /// to take pixel measurements. 
        /// </param>

        public ParticleFilterCriteria(MeasurementType parameter, Range range, bool calibrated)
            : this(parameter, range, calibrated, RangeType.InsideRange)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterCriteria class.
        /// </summary>
        /// <param name="parameter">
        /// The morphological measurement that the method uses for filtering. 
        /// </param>
        /// <param name="range">
        /// The range for the measurement chosen in parameter.
        /// </param>
        /// <param name="calibrated">
        /// Specifies whether to take calibrated measurements or pixel measurements. Set this parameter 
        /// to <see langword="true"/> to take calibrated measurements. Set this parameter to <see langword="false"/> 
        /// to take pixel measurements. 
        /// </param>
        /// <param name="rangeType">
        /// Specifies whether to include or exclude the values given in Range. When <format type="italics">rangeType</format> 
        /// is InsideRange, the particle meets the criteria if range lower value <entity value="le"/> particle measurement <entity value="lt"/> range upper value.
        /// When <format type="italics">rangeType</format> is OutsideRange, the particle meets the criteria if range upper value <entity value="ge"/>  
        /// particle measurement or particle measurement <entity value="lt"/>  range lower value.
        /// </param>

        public ParticleFilterCriteria(MeasurementType parameter, Range range, bool calibrated, RangeType rangeType)
        {
            _parameter = parameter;
            _range = range;
            _calibrated = calibrated;
            _rangeType = rangeType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleFilterCriteria.
        /// </summary>
        /// <param name="other">
        /// A ParticleFilterCriteria instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleFilterCriteria other)
        {
            return other != null && _parameter == other._parameter && Object.Equals(_range, other._range) && _calibrated == other._calibrated && _rangeType == other._rangeType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleFilterCriteria.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleFilterCriteria
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleFilterCriteria other = (ParticleFilterCriteria)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _parameter.GetHashCode() ^ _range.GetHashCode() ^ _calibrated.GetHashCode() ^ _rangeType.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleFilterCriteria: Parameter=" + _parameter.ToString() + ", Range=" + _range.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides options used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.ParticleFilter" crefType="Unqualified"/> 
    /// method to filter binary particles.
    /// </summary>

    [Serializable]
    public sealed class ParticleFilterOptions : IEquatable<ParticleFilterOptions>
    {
        private bool _rejectMatches;
        private bool _rejectBorder;
        private bool _fillHoles;
        private Connectivity _connectivity;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of connectivity to use. Set this parameter to Connectivity8 to use 
        /// connectivity-8 to determine whether particles are touching. Set this parameter to Connectivity4 
        /// to use connectivity-4 to determine whether particles are touching.
        /// </summary>
        /// <value>
        /// The default is Connectivity8.
        /// </value>

        public Connectivity Connectivity
        {
            get { return _connectivity; }
            set { _connectivity = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to reject border particles. Set this parameter to 
        /// <see langword="true"/> to reject border particles. Set this parameter to 
        /// <see langword="false"/> to keep border particles. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RejectBorder
        {
            get { return _rejectBorder; }
            set { _rejectBorder = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to fill holes in the particle. Set this parameter to 
        /// <see langword="true"/> to fill holes in particles. Set this parameter to 
        /// <see langword="false"/> to keep the holes in particles. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool FillHoles
        {
            get { return _fillHoles; }
            set { _fillHoles = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to reject matches. Set this parameter to <see langword="true"/> to transfer only those 
        /// particles that do not meet all the criteria. Set this parameter to 
        /// <see langword="false"/> to transfer only those particles that meet 
        /// all the criteria to the destination. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RejectMatches
        {
            get { return _rejectMatches; }
            set { _rejectMatches = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterOptions class.
        /// </summary>

        public ParticleFilterOptions() : this (false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterOptions class.
        /// </summary>
        /// <param name="rejectMatches">
        /// Specifies whether to reject matches. Set this parameter to <see langword="true"/> to transfer only those 
        /// particles that do not meet all the criteria. Set this parameter to 
        /// <see langword="false"/> to transfer only those particles that meet 
        /// all the criteria to the destination. 
        /// </param>

        public ParticleFilterOptions(bool rejectMatches) : this (rejectMatches, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterOptions class.
        /// </summary>
        /// <param name="rejectMatches">
        /// Specifies whether to reject matches. Set this parameter to <see langword="true"/> to transfer only those 
        /// particles that do not meet all the criteria. Set this parameter to 
        /// <see langword="false"/> to transfer only those particles that meet 
        /// all the criteria to the destination. 
        /// </param>
        /// <param name="rejectBorder">
        /// Specifies whether to reject border particles. Set this parameter to 
        /// <see langword="true"/> to reject border particles. Set this parameter to 
        /// <see langword="false"/> to keep border particles.
        /// </param>

        public ParticleFilterOptions(bool rejectMatches, bool rejectBorder) : this (rejectMatches, rejectBorder, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterOptions class.
        /// </summary>
        /// <param name="rejectMatches">
        /// Specifies whether to reject matches. Set this parameter to <see langword="true"/> to transfer only those 
        /// particles that do not meet all the criteria. Set this parameter to 
        /// <see langword="false"/> to transfer only those particles that meet 
        /// all the criteria to the destination. 
        /// </param>
        /// <param name="rejectBorder">
        /// Specifies whether to reject border particles. Set this parameter to 
        /// <see langword="true"/> to reject border particles. Set this parameter to 
        /// <see langword="false"/> to keep border particles.
        /// </param>
        /// <param name="fillHoles">
        /// Specifies whether to fill holes in the particle. Set this parameter to 
        /// <see langword="true"/> to fill holes in particles. Set this parameter to 
        /// <see langword="false"/> to keep the holes in particles. 
        /// </param>

        public ParticleFilterOptions(bool rejectMatches, bool rejectBorder, bool fillHoles) : this (rejectMatches, rejectBorder, fillHoles, Connectivity.Connectivity8)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleFilterOptions class.
        /// </summary>
        /// <param name="rejectMatches">
        /// Specifies whether to reject matches. Set this parameter to <see langword="true"/> to transfer only those 
        /// particles that do not meet all the criteria. Set this parameter to 
        /// <see langword="false"/> to transfer only those particles that meet 
        /// all the criteria to the destination. 
        /// </param>
        /// <param name="rejectBorder">
        /// Specifies whether to reject border particles. Set this parameter to 
        /// <see langword="true"/> to reject border particles. Set this parameter to 
        /// <see langword="false"/> to keep border particles.
        /// </param>
        /// <param name="fillHoles">
        /// Specifies whether to fill holes in the particle. Set this parameter to 
        /// <see langword="true"/> to fill holes in particles. Set this parameter to 
        /// <see langword="false"/> to keep the holes in particles. 
        /// </param>
        /// <param name="connectivity">
        /// Specifies the type of connectivity to use. Set this parameter to Connectivity8 to use 
        /// connectivity-8 to determine whether particles are touching. Set this parameter to Connectivity4 
        /// to use connectivity-4 to determine whether particles are touching.
        /// </param>

        public ParticleFilterOptions(bool rejectMatches, bool rejectBorder, bool fillHoles, Connectivity connectivity)
        {
            _rejectMatches = rejectMatches;
            _rejectBorder = rejectBorder;
            _fillHoles = fillHoles;
            _connectivity = connectivity;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified 
        /// ParticleFilterOptions.
        /// </summary>
        /// <param name="other">
        /// A ParticleFilterOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleFilterOptions other)
        {
            return other != null && _rejectMatches == other._rejectMatches && _rejectBorder == other._rejectBorder && _fillHoles == other._fillHoles && _connectivity == other._connectivity;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleFilterOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleFilterOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleFilterOptions other = (ParticleFilterOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rejectMatches.GetHashCode() ^ _rejectBorder.GetHashCode() ^ _fillHoles.GetHashCode() ^ _connectivity.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleFilterOptions: RejectMatches=" + _rejectMatches.ToString() + ", RejectBorder=" + _rejectBorder.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Sets the characters that are valid for the character position that corresponds to the index of this item 
    /// in the <see cref="NationalInstruments.Vision.Analysis.OcrValidCharactersCollection" crefType="Unqualified"/>.
    /// </summary>

    public sealed class OcrValidCharactersForPosition
    {
        private OcrSession _owner;
        private Int32 _index = -1;

internal OcrValidCharactersForPosition(OcrSession owner, Int32 index)
        {
            _owner = owner;
            _index = index;
        }

internal void SetIndex(Int32 index) {
            _index = index;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets predefined sets of valid characters. 
        /// </summary>
        /// <value>
        /// </value>

        public OcrPredefinedCharacters PredefinedCharacters
        {
            get
            {
                _owner.ThrowIfDisposed();
                byte[] unused = new byte[256];
                Int32 predefined;
                Utilities.ThrowError(VisionDll.niocrGetValidCharacters(_owner._session, unused, out predefined, _index));
                return (OcrPredefinedCharacters) predefined;
            }
            set
            {
                _owner.ThrowIfDisposed();
                byte[] userDefined = new byte[256];
                // Make sure it's null-terminated
                userDefined[0] = 0;
                if (value == OcrPredefinedCharacters.UserDefinedCharacters)
                {
                    // Get the user defined characters.
                    Int32 predefined;
                    Utilities.ThrowError(VisionDll.niocrGetValidCharacters(_owner._session, userDefined, out predefined, _index));
                }
                Utilities.ThrowError(VisionDll.niocrSetValidCharacters(_owner._session, Utilities.ConvertBytesToString(userDefined), (Int32)value, _index));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the string that contains all characters that are valid for the corresponding 
        /// character position when you set PredefinedCharacters to UserDefinedCharacters.
        /// </summary>
        /// <value>
        /// </value>

        public string UserDefinedCharacters
        {
            get
            {
                _owner.ThrowIfDisposed();
                Int32 unused;
                byte[] userDefined = new byte[256];
                Utilities.ThrowError(VisionDll.niocrGetValidCharacters(_owner._session, userDefined, out unused, _index));
                return Utilities.ConvertBytesToString(userDefined);
            }
            set
            {
                _owner.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetValidCharacters(_owner._session, value, (Int32)(OcrPredefinedCharacters.UserDefinedCharacters), _index));
            }
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string  ToString()
        {
            return "OcrValidCharactersForPosition: Index=" + _index.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Sets the characters that are valid for each character position. The number of 
    /// objects in this collection specifies the number of valid positions you want to identify. 
    /// Any characters beyond this number are ignored.
    /// </summary>

    public sealed class OcrValidCharactersCollection : ReadOnlyCollection<OcrValidCharactersForPosition>
    {
        private OcrSession _owner;
        private Collection<OcrValidCharactersForPosition> _realCollection;

        
        internal OcrValidCharactersCollection(OcrSession owner, Collection<OcrValidCharactersForPosition> collection) : base(collection)
        {
            _owner = owner;
            _realCollection = collection;
        }

        //==========================================================================================
        /// <summary>
        /// Adds an OcrValidCharactersForPosition object to the OcrValidCharactersCollection collection.
        /// </summary>
        /// <param name="predefined">
        /// Specifies predefined sets of valid characters. 
        /// </param>

        public void Add(OcrPredefinedCharacters predefined)
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, _realCollection.Count + 1));
            _realCollection.Add(new OcrValidCharactersForPosition(_owner, _realCollection.Count));
            _realCollection[_realCollection.Count - 1].PredefinedCharacters = predefined;
        }

        //==========================================================================================
        /// <summary>
        /// Adds an OcrValidCharactersForPosition object to the OcrValidCharactersCollection collection.
        /// </summary>
        /// <param name="userDefined">
        /// Specifies the string that contains all characters that are valid for the corresponding 
        /// character position.
        /// </param>

        public void Add(string userDefined)
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, _realCollection.Count + 1));
            _realCollection.Add(new OcrValidCharactersForPosition(_owner, _realCollection.Count));
            _realCollection[_realCollection.Count - 1].PredefinedCharacters = OcrPredefinedCharacters.UserDefinedCharacters;
            _realCollection[_realCollection.Count - 1].UserDefinedCharacters = userDefined;
        }

        //==========================================================================================
        /// <summary>
        /// Removes the OcrValidCharactersForPosition object at the specified index from the OcrValidCharactersCollection collection.
        /// </summary>
        /// <param name="index">
        /// The location of the OcrValidCharactersForPosition object.
        /// </param>

        public void RemoveAt(int index)
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, _realCollection.Count - 1));
            _realCollection.RemoveAt(index);
            InvalidateAll();
        }

        //==========================================================================================
        /// <summary>
        /// Inserts an OcrValidCharactersForPosition object to the OcrValidCharactersCollection collection.
        /// </summary>
        /// <param name="index">
        /// The index of the character position to insert the object.
        /// </param>
        /// <param name="predefined">
        /// Specifies predefined sets of valid characters. 
        /// </param>

        public void Insert(int index, OcrPredefinedCharacters predefined)
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, _realCollection.Count + 1));
            _realCollection.Insert(index, new OcrValidCharactersForPosition(_owner, index));
            _realCollection[index].PredefinedCharacters = predefined;
            InvalidateAll();
        }

        //==========================================================================================
        /// <summary>
        /// Inserts an OcrValidCharactersForPosition object to the OcrValidCharactersCollection collection.
        /// </summary>
        /// <param name="index">
        /// The index of the character position to insert the object.
        /// </param>
        /// <param name="userDefined">
        /// Specifies the string that contains all characters that are valid for the corresponding 
        /// character position.
        /// </param>

        public void Insert(int index, string userDefined)
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, _realCollection.Count + 1));
            _realCollection.Insert(index, new OcrValidCharactersForPosition(_owner, index));
            _realCollection[index].PredefinedCharacters = OcrPredefinedCharacters.UserDefinedCharacters;
            _realCollection[index].UserDefinedCharacters = userDefined;
            InvalidateAll();
        }

        //==========================================================================================
        /// <summary>
        /// Removes all items from the collection. 
        /// </summary>

        public void Clear()
        {
            _owner.ThrowIfDisposed();
            Utilities.ThrowError(VisionDll.niocrSetNumberOfValidCharacterPositions(_owner._session, 0));
            _realCollection.Clear();
        }

        


        internal void InvalidateAll()
        {
            // Update the valid characters count.
            _owner.ThrowIfDisposed();
            Int32 numberOfPositions;
            Utilities.ThrowError(VisionDll.niocrGetNumberOfValidCharacterPositions(_owner._session, out numberOfPositions));
            while (_realCollection.Count < numberOfPositions)
            {
                _realCollection.Add(new OcrValidCharactersForPosition(_owner, _realCollection.Count));
            }
            while (_realCollection.Count > numberOfPositions)
            {
                _realCollection.RemoveAt(_realCollection.Count - 1);
            }
            for (int i = 0; i < _realCollection.Count; ++i)
            {
                _realCollection[i].SetIndex(i);
            }
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return base.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Configures how text is read.
    /// </summary>

    public sealed class OcrReadTextOptions
    {
        private Collection<OcrValidCharactersForPosition> _validCharsCollection;
        private OcrValidCharactersCollection _validChars;
        private OcrSession _session;

internal OcrReadTextOptions(OcrSession session)
        {
            _session = session;
            _validCharsCollection = new Collection<OcrValidCharactersForPosition>();
            _validChars = new OcrValidCharactersCollection(_session, _validCharsCollection);
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the read resolution, which determines how much of the trained character 
        /// data is used to match objects to trained characters.
        /// </summary>
        /// <value>
        /// The default is LowResolution.
        /// </value>

        public OcrReadResolution ReadResolution
        {
            get
            {
                _session.ThrowIfDisposed();
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetReadResolution(_session._session, out toReturn));
                return (OcrReadResolution)toReturn;
            }
            set
            {
                _session.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetReadResolution(_session._session, (Int32)value));
            }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the aspect ratio. Set this property to 0 to read text without considering 
        /// the aspect ratio. Set this property to a minimum value of 100 to consider the aspect 
        /// ratio when reading text. Setting the aspect ratio to 100 indicates that you expect the 
        /// read character to be exactly the same size as the trained character. This property does 
        /// not have a maximum value.
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 AspectRatio
        {
            get
            {
                _session.ThrowIfDisposed();
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetAspectRatio(_session._session, out toReturn));
                return toReturn;
            }
            set
            {
                _session.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetAspectRatio(_session._session, value));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum acceptance level at which an object is considered a trained character. 
        /// The range of valid values for this attribute is 0 to 1,000.
        /// </summary>
        /// <value>
        /// The default is 700.
        /// </value>

        public Int32 AcceptanceLevel
        {
            get
            {
                _session.ThrowIfDisposed();
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetAcceptanceLevel(_session._session, out toReturn));
                return toReturn;
            }
            set
            {
                _session.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetAcceptanceLevel(_session._session, value));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the possible read strategies. The read strategy determines how closely 
        /// images are analyzed to match objects with trained characters.
        /// </summary>
        /// <value>
        /// The default is Aggressive, which means that few criteria is used to analyze images.
        /// </value>

        public OcrReadStrategy ReadStrategy
        {
            get
            {
                _session.ThrowIfDisposed();
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetReadStrategy(_session._session, out toReturn));
                return (OcrReadStrategy)toReturn;
            }
            set
            {
                _session.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetReadStrategy(_session._session, (Int32)value));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the character that 
        /// <see cref="NationalInstruments.Vision.Analysis.OcrSession.ReadText" crefType="PartiallyQualified"/> 
        /// substitutes for objects it cannot match with any of the trained characters. 
        /// </summary>
        /// <value>
        /// The default is a question mark (?).
        /// </value>

        public char SubstitutionCharacter
        {
            get {
                _session.ThrowIfDisposed();
                byte toReturn;
                Utilities.ThrowError(VisionDll.niocrGetSubstitutionCharacter(_session._session, out toReturn));
                return (char)toReturn;
            }
            set {
                _session.ThrowIfDisposed();
                Utilities.ThrowError(VisionDll.niocrSetSubstitutionCharacter(_session._session, (byte)value));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the characters that are compared against read characters during the reading process. 
        /// </summary>

        public OcrValidCharactersCollection ValidCharacters
        {
            get { return _validChars; }
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "OcrReadTextOptions: ReadStrategy=" + ReadStrategy;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Configures how to train or read characters.
    /// </summary>

    public sealed class OcrProcessingOptions
    {
        private IntPtr _charSet = IntPtr.Zero;
        private OcrRange _thresholdRange;
        private OcrRange _thresholdLimits;

internal OcrProcessingOptions(IntPtr _session)
        {
            _charSet = _session;
            _thresholdRange = new OcrRange(_charSet, VisionDll.niocrGetThresholdRange, VisionDll.niocrSetThresholdRange);
            _thresholdLimits = new OcrRange(_charSet, VisionDll.niocrGetThresholdLimits, VisionDll.niocrSetThresholdLimits);
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of erosions to perform. After performing the erosions, the method 
        /// restores the remaining objects to their original uneroded size. Set this attribute to 0 if 
        /// you do not want to remove small particles. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 ErosionCount
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetNumberOfErosions(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetNumberOfErosions(_charSet, value)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to remove particles touching the ROI. Set this element to <see langword="true"/> 
        /// to remove the particles touching the ROI. Set this element to <see langword="false"/> 
        /// to include the particles touching the ROI.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RemoveParticlesTouchingRoi
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetRemoveObjectsTouchingROI(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetRemoveObjectsTouchingROI(_charSet, value ? 1 : 0)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets which pixel intensity to read or train in the image. Set this element to <see langword="true"/> 
        /// to read or train dark characters on a light background. Set this element to <see langword="false"/> to read 
        /// or train light characters on a dark background. 
        /// </summary>
        /// <value>
        /// The default is <see langword="true"/>.
        /// </value>

        public bool DarkCharacters
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetDarkCharacters(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetDarkCharacters(_charSet, value ? 1 : 0)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how to calculate low and high threshold values when the threshold calculation 
        /// is optimized. Set this parameter to <see langword="true"/> to calculate both the low and 
        /// high threshold values when using the fast thresholding method. Set this parameter to 
        /// <see langword="false"/> to calculate only the high threshold value when reading or training 
        /// dark characters and to calculate only the low threshold value when reading or training light 
        /// characters. This option is available only when FastThreshold is <see langword="true"/>. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool BiModalCalculation
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetPerformBiModalCalculation(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetPerformBiModalCalculation(_charSet, value ? 1 : 0)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to use a faster, less accurate threshold. Set this parameter to <see langword="true"/> 
        /// to use a faster, less accurate threshold calculation algorithm. Set this parameter to <see langword="false"/> 
        /// to use a slower, more accurate threshold calculation algorithm. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool FastThreshold
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetOptimizeForSpeed(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetOptimizeForSpeed(_charSet, value ? 1 : 0)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of blocks for threshold calculation algorithms that require blocks. Valid values range from 4 to 50. 
        /// </summary>
        /// <value>
        /// The default is 4.
        /// </value>

        public Int32 BlockCount
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetNumberOfBlocks(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetNumberOfBlocks(_charSet, value)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the low and high threshold values when you set Mode to FixedRange.
        /// </summary>

        public IRange ThresholdRange
        {
            get { return _thresholdRange; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the lower and upper threshold limits to establish a limit on the threshold calculated by the automatic 
        /// threshold calculation algorithms. 
        /// </summary>

        public IRange ThresholdLimits
        {
            get { return _thresholdLimits; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the thresholding mode. 
        /// </summary>
        /// <value>
        /// The default is ComputedUniform.
        /// </value>

        public OcrThresholdMode Mode
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetThresholdMode(_charSet, out toReturn));
                return (OcrThresholdMode)toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetThresholdMode(_charSet, (Int32)value)); }
        }

        public OCRThresholdType ThresholdType 
        {
            get 
            {
                OCRThresholdType toReturn;
                Utilities.ThrowError(VisionDll.niocrGetOCRThresholdType(_charSet, out toReturn));
                return (OCRThresholdType)toReturn;
            }
            set 
            {
                Utilities.ThrowError(VisionDll.niocrSetOCRThresholdType(_charSet, (OCRThresholdType)value));
            }
        }

        public void SetLocalThresholdOptions(LocalThresholdMethod _method, WindowRect _windowBounds, double _devWeight, ParticleType _darkObj)
        {
            CVI_OCRWindowRect toSet = new CVI_OCRWindowRect();
            toSet.ConvertFromExternal(_windowBounds);
            Utilities.ThrowError(VisionDll.niocrSetLocalThresholdOptions(_charSet, _method, toSet, _devWeight, _darkObj));
        }

        public void GetLocalThresholdOptions(out LocalThresholdMethod _method, out WindowRect _windowBounds, out double _devWeight, out ParticleType _darkObj)
        {
            CVI_OCRWindowRect toReturn = new CVI_OCRWindowRect();
            Utilities.ThrowError(VisionDll.niocrGetLocalThresholdOptions(_charSet, out _method, out toReturn, out _devWeight, out _darkObj));
            _windowBounds =  toReturn.ConvertToExternal();
        }

        public void SetColorThresholdOptions(ColorMode _mode, OCRPanelRange _RedHue, OCRPanelRange _GreenSaturation, OCRPanelRange _BlueLumIntenVal)
        {
            CVI_OCRPanelRange toSetRedHue = new CVI_OCRPanelRange();
            toSetRedHue.ConvertFromExternal(_RedHue);
            CVI_OCRPanelRange toSetGreenSaturation = new CVI_OCRPanelRange();
            toSetGreenSaturation.ConvertFromExternal(_GreenSaturation);
            CVI_OCRPanelRange toSetBlueLumIntenVal = new CVI_OCRPanelRange();
            toSetBlueLumIntenVal.ConvertFromExternal(_BlueLumIntenVal);
            Utilities.ThrowError(VisionDll.niocrSetColorThresholdOptions(_charSet, _mode, toSetRedHue, toSetGreenSaturation, toSetBlueLumIntenVal));
        }

        public void GetColorThresholdOptions(out ColorMode _mode, out OCRPanelRange _RedHue, out OCRPanelRange _GreenSaturation, out OCRPanelRange _BlueLumIntenVal)
        {
            CVI_OCRPanelRange toReturnRedHue          = new CVI_OCRPanelRange();
            CVI_OCRPanelRange toReturnGreenSaturation = new CVI_OCRPanelRange();
            CVI_OCRPanelRange toReturnBlueLumInterval = new CVI_OCRPanelRange();
            Utilities.ThrowError(VisionDll.niocrGetColorThresholdOptions(_charSet, out _mode, out toReturnRedHue, out toReturnGreenSaturation, out toReturnBlueLumInterval));
            _RedHue = toReturnRedHue.ConvertToExternal();
            _GreenSaturation = toReturnGreenSaturation.ConvertToExternal();
            _BlueLumIntenVal = toReturnBlueLumInterval.ConvertToExternal();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>
        
        //==========================================================================================
        public override string ToString()
        {
            return "OcrProcessingOptions: Mode=" + Mode;
        }
    }
    
    [Serializable]
    public sealed class OCRPanelRange 
    {
        private Int32 _minValue;
        private Int32 _maxValue;
        //---------------------------------------------
        // Default Constructor
        //---------------------------------------------
        public OCRPanelRange()
        {
            _minValue = 0;
            _maxValue = 0;
        }
        //---------------------------------------------
        // Parameterized Constructor
        //---------------------------------------------
        public OCRPanelRange(Int32 minValue, Int32 maxValue)
        {
            _minValue = minValue;
            _maxValue = maxValue;
        }
        //---------------------------------------------
        // Properties
        //---------------------------------------------
        public Int32 MinValue
        {
            get { return _minValue; }
            set { _minValue = value; }
        }
        public Int32 MaxValue
        {
            get { return _maxValue; }
            set { _maxValue = value; }
        }
    }

    [Serializable]
    public sealed class WindowRect
    {
        private UInt32 _windowWidth  ;
        private UInt32 _windowHeight ;

        public WindowRect()
        {
            _windowWidth = 0;
            _windowHeight = 0;
        }
        public WindowRect(UInt32 windowWidth, UInt32 windowHeight)
        {
            _windowWidth  = windowWidth  ;
            _windowHeight = windowHeight ; 
        }
        //---------------------------------------------
        // Properties
        //---------------------------------------------
        public UInt32 WindowWidth
        {
            get { return _windowWidth; }
            set { _windowWidth = value; }
        }
        public UInt32 WindowHeight
        {
            get { return _windowHeight; }
            set { _windowHeight = value; }
        }

    }
    //==============================================================================================
    /// <summary>
    /// Character size and spacing constraints you want to use during the training or reading process.
    /// </summary>

    public sealed class OcrSpacingOptions
    {
        private IntPtr _charSet = IntPtr.Zero;
        private OcrRange _charSizeRange;
        private OcrRange _boundingRectWidthRange;
        private OcrRange _boundingRectHeightRange;

        
        internal OcrSpacingOptions(IntPtr _session)
        {
            _charSet = _session;
            _charSizeRange = new OcrRange(_charSet, VisionDll.niocrGetCharacterSizeMinimum, VisionDll.niocrSetCharacterSizeMinimum, VisionDll.niocrGetCharacterSizeMaximum, VisionDll.niocrSetCharacterSizeMaximum);
            _boundingRectWidthRange = new OcrRange(_charSet, VisionDll.niocrGetBoundingRectangleWidthMinimum, VisionDll.niocrSetBoundingRectangleWidthMinimum, VisionDll.niocrGetBoundingRectangleWidthMaximum, VisionDll.niocrSetBoundingRectangleWidthMaximum);
            _boundingRectHeightRange = new OcrRange(_charSet, VisionDll.niocrGetBoundingRectangleHeightMinimum, VisionDll.niocrSetBoundingRectangleHeightMinimum, VisionDll.niocrGetBoundingRectangleHeightMaximum, VisionDll.niocrSetBoundingRectangleHeightMaximum);
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to split overlapping characters.
        /// Set this parameter to <see langword="true"/> to automatically adjust the location of the character 
        /// bounding rectangle when characters overlap vertically. This parameter is useful 
        /// when you are working with an image that contains slanted characters. If the characters are 
        /// not slanted and/or do not overlap vertically, set this parameter to <see langword="false"/>. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool AutoSplit
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetAutoSplit(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetAutoSplit(_charSet, value ? 1 : 0)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum possible height, in pixels, for a character bounding rectangle. 
        /// The minimum acceptable value for this parameter is 1. Set the maximum value to 65536 to
        /// specify that all heights greater than the minimum value are acceptable.
        /// </summary>
        /// <value>
        /// The default is (1, 65536).
        /// </value>

        public IRange BoundingRectHeightRange
        {
            get { return _boundingRectHeightRange; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum possible width, in pixels, for a character bounding rectangle. 
        /// The minimum acceptable value for this parameter is 1. Set the maximum value to 65536 to
        /// specify that all widths greater than the minimum value are acceptable.
        /// </summary>
        /// <value>
        /// The default is (1, 65536).
        /// </value>

        public IRange BoundingRectWidthRange
        {
            get { return _boundingRectWidthRange; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum vertical element spacing in pixels. Elements whose spacing from the main 
        /// character element exceeds MaximumVerticalElementSpacing are not used for training or reading. 
        /// Set this parameter to 0 to specify that any element in the ROI should be considered part 
        /// of a character. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 MaximumVerticalElementSpacing
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetElementVerticalSpacingMaximum(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetElementVerticalSpacingMaximum(_charSet, value)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum horizontal spacing, in pixels, allowed between character elements to 
        /// train or read the character elements as a single character. This value cannot exceed the minimum value of
        /// CharSizeRange. The minimum acceptable value for this parameter is 0. 
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public Int32 MaximumHorizontalElementSpacing
        {
            get {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetElementHorizontalSpacingMaximum(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetElementHorizontalSpacingMaximum(_charSet, value)); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum number of pixels required for an object to be a 
        /// potentially identifiable character. The minimum acceptable value for this parameter is 1. 
        /// The maximum value cannot exceed MinimumCharSpacing.
        /// </summary>
        /// <value>
        /// The default is (20, 65536).
        /// </value>

        public IRange CharSizeRange
        {
            get { return _charSizeRange; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum amount of space, in pixels, that can be between characters. 
        ///  This value cannot be less than MaximumHorizontalElementSpacing. 
        /// </summary>
        /// <value>
        /// </value>

        public Int32 MinimumCharSpacing
        {
            get 
            {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetCharacterSpacingMinimum(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetCharacterSpacingMinimum(_charSet, value)); }
        }
        
        public bool TextLocation
        {
            get
            {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetTextLocation(_charSet, out toReturn));
                return (toReturn != 0);
            }
            set { Utilities.ThrowError(VisionDll.niocrSetTextLocation(_charSet, value ? 1 : 0)); }
        }

        public LineSeparatorType LineSeparator
        {
            get 
            {
                Int32 lineSeparator ;
                Utilities.ThrowError(VisionDll.niocrGetLineSeparatorType(_charSet, out lineSeparator));
                return (LineSeparatorType)lineSeparator;

            }
            set { Utilities.ThrowError(VisionDll.niocrSetLineSeparatorType(_charSet, (Int32)value)); }
       }

        public Int32 ShortestPathSegment
        {
            get
            {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetShortestPathSegment(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetShortestPathSegment(_charSet, value)); }
        }

        public Int32 MinPixelsForSpace
        {
            get
            {
                Int32 toReturn;
                Utilities.ThrowError(VisionDll.niocrGetMinPixelsForSpace(_charSet, out toReturn));
                return toReturn;
            }
            set { Utilities.ThrowError(VisionDll.niocrSetMinPixelsForSpace(_charSet, value)); }
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "OcrSpacingOptions: CharSizeRange=" + CharSizeRange;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Describes the characters segmented in the ROI.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CharacterStatistics : IEquatable<CharacterStatistics>
    {
        private RectangleContour _boundingRect;
        private Int32 _characterSize;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CharacterStatistics class.
        /// </summary>

        public CharacterStatistics()
        {
            _boundingRect = new RectangleContour();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the character in pixels. 
        /// </summary>
        /// <value>
        /// </value>

        public Int32 CharacterSize
        {
            get { return _characterSize; }
            set { _characterSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the rectangle surrounding the match. 
        /// </summary>
        /// <value>
        /// </value>

        public RectangleContour BoundingRectangle
        {
            get { return _boundingRect; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _boundingRect = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CharacterStatistics.
        /// </summary>
        /// <param name="other">
        /// A CharacterStatistics instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CharacterStatistics other)
        {
            return other != null && Object.Equals(_boundingRect, other._boundingRect) && _characterSize == other._characterSize;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CharacterStatistics.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CharacterStatistics and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CharacterStatistics other = (CharacterStatistics)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _boundingRect.GetHashCode() ^ _characterSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CharacterStatistics: BoundingRectangle=" + _boundingRect.ToString() + ", CharacterSize=" + _characterSize.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information pertaining to a particular read character.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CharacterReport : IEquatable<CharacterReport>
    {
        private string _characterValue;
        private Int32 _classificationScore;
        private Int32 _verificationScore;
        private bool _verified;
        private Range _thresholdRange;
        private CharacterStatistics _characterStatistics;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CharacterReport class.
        /// </summary>

        public CharacterReport()
        {
            _thresholdRange = new Range();
            _characterStatistics = new CharacterStatistics();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets information about the characters segmented in the ROI.
        /// </summary>
        /// <value>
        /// </value>

        public CharacterStatistics CharacterStatistics
        {
            get { return _characterStatistics; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _characterStatistics = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of threshold limits that was used to threshold the character. 
        /// </summary>
        /// <value>
        /// </value>

        public Range ThresholdRange
        {
            get { return _thresholdRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _thresholdRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether a reference character was found for the character class.
        /// </summary>
        /// <value>
        /// 	<see langword="true"/>  if a reference character was found for the character class and <see langword="false"/>  if a reference character was not found.
        /// </value>

        public bool Verified
        {
            get { return _verified; }
            set { _verified = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the level of similarity of the character and the reference character for the character class.
        /// </summary>
        /// <value>
        /// </value>

        public Int32 VerificationScore
        {
            get { return _verificationScore; }
            set { _verificationScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the degree to which the assigned character class represents the object better than the other character classes in the character set. 
        /// </summary>
        /// <value>
        /// </value>

        public Int32 ClassificationScore
        {
            get { return _classificationScore; }
            set { _classificationScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the value of the identified character. 
        /// </summary>
        /// <value>
        /// </value>

        public string CharacterValue
        {
            get { return _characterValue; }
            set { _characterValue = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CharacterReport.
        /// </summary>
        /// <param name="other">
        /// A CharacterReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CharacterReport other)
        {
            return other != null && _characterValue == other._characterValue && _classificationScore == other._classificationScore && _verificationScore == other._verificationScore && _verified == other._verified && Object.Equals(_thresholdRange, other._thresholdRange) && Object.Equals(_characterStatistics, other._characterStatistics);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CharacterReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CharacterReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CharacterReport other = (CharacterReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _characterValue.GetHashCode() ^ _classificationScore.GetHashCode() ^ _verificationScore.GetHashCode() ^ _verified.GetHashCode() ^ _thresholdRange.GetHashCode() ^ _characterStatistics.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CharacterReport: CharacterValue=" + _characterValue + ", ClassificationScore=" + _classificationScore.ToString(CultureInfo.CurrentCulture) + ", VerificationScore=" + _verificationScore.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about the text read.
    /// </summary>

    public sealed class ReadTextReport : IDisposable, IEquatable<ReadTextReport>
    {
        private string _readString;
        private Collection<CharacterReport> _characterReports;
        private Roi _roiBoundingCharacters;
        private object _disposeLock = new object();

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ReadTextReport class.
        /// </summary>

        public ReadTextReport()
        {
            _readString = "";
            _characterReports = new Collection<CharacterReport>();
            _roiBoundingCharacters = new Roi();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the character-bounding ROI.
        /// </summary>

        public Roi RoiBoundingCharacters
        {
            get { return _roiBoundingCharacters; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _roiBoundingCharacters = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of reports describing the properties of each identified character.
        /// </summary>

        public Collection<CharacterReport> CharacterReports
        {
            get { return _characterReports; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_characterReports = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the string that was read.
        /// </summary>

        public string ReadString
        {
            get { return _readString; }
            set { _readString = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Releases all resources used by the ReadTextReport. 
        /// </summary>

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

private void Dispose(bool disposing) {
            lock (_disposeLock)
            {
                if (disposing)
                {
                    // Dispose the ROI.
                    _roiBoundingCharacters.Dispose();
                }
            }
        }

        
        ~ReadTextReport()
        {
            Dispose(false);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadTextReport.
        /// </summary>
        /// <param name="other">
        /// A ReadTextReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ReadTextReport other)
        {
            return other != null && _readString == other._readString && Object.Equals(_characterReports, other._characterReports) && Object.Equals(_roiBoundingCharacters, other._roiBoundingCharacters);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadTextReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ReadTextReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ReadTextReport other = (ReadTextReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _readString.GetHashCode() ^ _characterReports.GetHashCode() ^ _roiBoundingCharacters.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ReadTextReport: ReadString=" + _readString;
        }
    }

    public sealed class ReadTextReport2 : IDisposable, IEquatable<ReadTextReport2>
    {
        private string _readString;
        private Collection<CharacterReport> _characterReports;
        private Roi _roiBoundingCharacters;
        private Int32 _numberOflinesDetected;
        private object _disposeLock = new object();

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ReadTextReport class.
        /// </summary>

        public ReadTextReport2()
        {
            _readString = "";
            _characterReports = new Collection<CharacterReport>();
            _roiBoundingCharacters = new Roi();
            _numberOflinesDetected = 0;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the character-bounding ROI.
        /// </summary>

        public Roi RoiBoundingCharacters
        {
            get { return _roiBoundingCharacters; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _roiBoundingCharacters = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of reports describing the properties of each identified character.
        /// </summary>

        public Collection<CharacterReport> CharacterReports
        {
            get { return _characterReports; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _characterReports = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the string that was read.
        /// </summary>

        public string ReadString
        {
            get { return _readString; }
            set { _readString = value; }
        }

        public Int32 NumberOflinesDetected
        {
            get { return _numberOflinesDetected; }
            set { _numberOflinesDetected = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Releases all resources used by the ReadTextReport. 
        /// </summary>

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

private void Dispose(bool disposing)
        {
            lock (_disposeLock)
            {
                if (disposing)
                {
                    // Dispose the ROI.
                    _roiBoundingCharacters.Dispose();
                }
            }
        }

        
        ~ReadTextReport2()
        {
            Dispose(false);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadTextReport.
        /// </summary>
        /// <param name="other">
        /// A ReadTextReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ReadTextReport2 other)
        {
            return other != null && _readString == other._readString && Object.Equals(_characterReports, other._characterReports) && Object.Equals(_roiBoundingCharacters, other._roiBoundingCharacters) && (_numberOflinesDetected == other._numberOflinesDetected);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadTextReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ReadTextReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ReadTextReport2 other = (ReadTextReport2)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _readString.GetHashCode() ^ _characterReports.GetHashCode() ^ _roiBoundingCharacters.GetHashCode() ^ _numberOflinesDetected.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ReadTextReport: ReadString=" + _readString;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Allows reading and writing data in a compatible format with the NI Vision Legacy ActiveX control, specifically the CWIMAQData class.
    /// </summary>
    /// <remarks>
    /// If you are developing a new application, there is no need to use this class.  The only reason to use this class is for interoperability with the CWIMAQData class of the NI Vision Legacy ActiveX control.
    /// </remarks>

    public sealed class VBCustomData : IEquatable<VBCustomData>
    {
        private string _text;
        private float[] _numeric;
        private byte[] _byte;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the part of the data that is an array of bytes.
        /// </summary>

        public byte[] Byte
        {
            get { return _byte; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _byte = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the part of the data that is an array of Singles.
        /// </summary>

        public float[] Numeric
        {
            get { return _numeric; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _numeric = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the part of the data that is a string.
        /// </summary>

        public string Text
        {
            get { return _text; }
            set { _text = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the VBCustomData class.
        /// </summary>

        public VBCustomData() : this ("", new float[0], new byte[0])
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the VBCustomData class.
        /// </summary>
        /// <param name="text">
        /// The part of the data that is a string.
        /// </param>
        /// <param name="numeric">
        /// The part of the data that is an array of Singles.
        /// </param>
        /// <param name="bytes">
        /// The part of the data that is an array of bytes.
        /// </param>

        public VBCustomData(string text, float[] numeric, byte[] bytes)
        {
            _text = text;
            _numeric = numeric;
            _byte = bytes;
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the VBCustomData class.
        /// </summary>
        /// <param name="vbData">
        /// The raw data written with the NI Vision Legacy ActiveX control.
        /// </param>
        /// <remarks>
        /// This constructor can correctly interpret data written with the NI Vision Legacy ActiveX Control, specifically the CWIMAQData class.
        /// </remarks>

        public unsafe VBCustomData(byte[] vbData)
        {
            // We use the same format we do in VB for compatibility.
            //------------------------------------------------------------------------------
            //  The format for converting the data to a string is the following:
            //  unsigned long representing the version number of this structure (1)
            //  unsigned long representing the number of characters in the text.
            //  the text
            //  unsigned long representing the number of _elements_ in the float array. (NOT the number of bytes!)
            //  the float array
            //  unsigned long representing the number of elements in the byte array,
            //  the byte array
            //------------------------------------------------------------------------------
            if (vbData == null || vbData.Length == 0)
            {
                // There isn't any data here, but this isn't an error.
                return;
            }
            if (vbData.Length < 2 * sizeof(UInt32))
            {
                throw new VisionException(ErrorCode.DataCorrupted);
            }
            int index = 0;
            // First read the version and bail if it's too new.
            UInt32 version = BitConverter.ToUInt32(vbData, index);
            index += sizeof(UInt32);
            if (version > 0x70100)
            {
                throw new VisionException(ErrorCode.DataVersion);
            }
            // Now read the text size
            UInt32 textSize = BitConverter.ToUInt32(vbData, index);
            index += sizeof(UInt32);
            UInt32 textChunkSize = 2 * sizeof(UInt32) + textSize;
            // Size check!
            if (vbData.Length < textChunkSize + sizeof(UInt32))
            {
                throw new VisionException(ErrorCode.DataCorrupted);
            }
            // Now initialize the string data.
            fixed (byte* bytePtr = vbData) {
                _text = new string((sbyte*)bytePtr, index, (Int32)textSize);
            }
            index += (Int32)textSize;
            // Get the size of the numeric data.
            UInt32 numericSize = BitConverter.ToUInt32(vbData, index);
            index += sizeof(UInt32);
            UInt32 numericChunkSize = sizeof(UInt32) + numericSize * sizeof(float);
            // Size check
            if (vbData.Length < textChunkSize + numericChunkSize + sizeof(UInt32))
            {
                throw new VisionException(ErrorCode.DataCorrupted);
            }
            // Now, read in the numeric data.
            _numeric = new float[numericSize];
            for (int i = 0; i < numericSize; ++i)
            {
                _numeric[i] = BitConverter.ToSingle(vbData, index);
                index += sizeof(float);
            }
            // Now, find the size for the byte data.
            UInt32 byteSize = BitConverter.ToUInt32(vbData, index);
            index += sizeof(UInt32);
            // Size check
            if (vbData.Length < textChunkSize + numericChunkSize + byteSize)
            {
                throw new VisionException(ErrorCode.DataCorrupted);
            }
            // Read in the byte data
            _byte = new byte[byteSize];
            Array.Copy(vbData, index, _byte, 0, byteSize);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified VBCustomData.
        /// </summary>
        /// <param name="other">
        /// A VBCustomData instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(VBCustomData other)
        {
            return other != null && _text.Equals(other._text) && Array.Equals(_numeric, other._numeric) && Array.Equals(_byte, other._byte);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified VBCustomData.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of VBCustomData and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            VBCustomData other = (VBCustomData)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _text.GetHashCode() ^ _numeric.GetHashCode() ^ _byte.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "VBCustomData: Text=\"" + Text + "\"";
        }
        //==========================================================================================
        /// <summary>
        /// Converts custom data to bytes.
        /// </summary>
        /// <returns>
        /// An array of bytes.
        /// </returns>
        /// <remarks>
        /// These bytes are compatible with the with the NI Vision Legacy ActiveX Control, specifically the CWIMAQData class.
        /// </remarks>

        public byte[] ConvertToBytes()
        {
            // First, find out how big our array needs to be.
            byte[] textBytes = new byte[0];
            if (_text != null)
            {
                textBytes = System.Text.Encoding.Default.GetBytes(_text);
            }
            UInt32 textSize = (UInt32)textBytes.Length;
            // textChunkSize includes the version number.
            UInt32 textChunkSize = sizeof(UInt32) + sizeof(UInt32) + textSize;
            UInt32 numericSize = (_numeric != null) ? (UInt32)_numeric.Length : 0;
            UInt32 numericChunkSize = sizeof(UInt32) + numericSize * sizeof(float);
            UInt32 byteSize = (_byte != null) ? (UInt32)_byte.Length : 0;
            UInt32 byteChunkSize = sizeof(UInt32) + byteSize;
            byte[] array = new byte[textChunkSize + numericChunkSize + byteChunkSize];
            int index = 0;
            // Write the version.
            Array.Copy(BitConverter.GetBytes((UInt32)0x70100), 0, array, index, sizeof(UInt32));
            index += sizeof(UInt32);
            // Write the text size and text.
            Array.Copy(BitConverter.GetBytes((UInt32)textSize), 0, array, index, sizeof(UInt32));
            index += sizeof(UInt32);
            if (textSize > 0)
            {
                Array.Copy(textBytes, 0, array, index, textSize);
            }
            index += textBytes.Length;
            // Write the numeric size and text.
            Array.Copy(BitConverter.GetBytes((UInt32)numericSize), 0, array, index, sizeof(UInt32));
            index += sizeof(UInt32);
            for (int i = 0; i < numericSize; ++i)
            {
                Array.Copy(BitConverter.GetBytes(_numeric[i]), 0, array, index, sizeof(float));
                index += sizeof(float);
            }
            // Write the byte size and text.
            Array.Copy(BitConverter.GetBytes((UInt32)byteSize), 0, array, index, sizeof(UInt32));
            index += sizeof(UInt32);
            if (byteSize > 0)
            {
                Array.Copy(_byte, 0, array, index, byteSize);
            }
            return array;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains information about a class in a classifier.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ClassifierClass
    {
        private string _name;
        private double _accuracy;
        private double _predictiveValue;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the predictive value of this class, which indicates the probability that a sample classified into this class belongs to this class. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// Refer to the  <format type="italics">Classifier Predictability</format> section of Chapter 15, <format type="italics">Binary Particle Classification</format>, in the <format type="italics">NI Vision Concepts Manual</format> for more information about this field.
        /// </remarks>

        public double PredictiveValue
        {
            get { return _predictiveValue; }
            set { _predictiveValue = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of this class, which indicates the probability that the classifier classifies a sample into the correct class. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// Refer to the  <format type="italics">Classifier Accuracy</format> section of Chapter 15, <format type="italics">Binary Particle Classification</format>, in the <format type="italics">NI Vision Concepts Manual</format> for more information about this field.
        /// </remarks>

        public double Accuracy
        {
            get { return _accuracy; }
            set { _accuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the name of this class in the classifier. 
        /// </summary>
        /// <value>
        /// </value>

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the ClassifierClass class.
        /// </summary>
        /// <param name="name">The name of the class in the classifier.</param>
        /// <param name="accuracy">
        /// The accuracy information for this class.  This indicates the probability that the classifier classifies a sample into the correct class.
        /// </param>
        /// <param name="predictiveValue">The predictive value for this class.  This indicates the probability that a sample classified into a given class belongs to that class.
        /// </param>

        public ClassifierClass(string name, double accuracy, double predictiveValue)
        {
            _name = name;
            _accuracy = accuracy;
            _predictiveValue = predictiveValue;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierClass.
        /// </summary>
        /// <param name="other">
        /// A ClassifierClass instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifierClass other)
        {
            return other != null && _name == other._name && _accuracy == other._accuracy && _predictiveValue == other._predictiveValue;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierClass.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of  ClassifierClass
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifierClass other = (ClassifierClass)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _name.GetHashCode() ^ _accuracy.GetHashCode() ^ _predictiveValue.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifierClass: Name=" + _name + ", Accuracy=" + _accuracy.ToString(CultureInfo.CurrentCulture) + ", PredictiveValue=" + _predictiveValue.ToString(CultureInfo.CurrentCulture);
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides a report on the accuracy of the classifier, based on how well it classifies the samples it was trained with.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ClassifierAccuracyReport
    {
        private Collection<ClassifierClass> _classes;
        private int[,] _classifierDistribution;
        private double _accuracy;

        //==========================================================================================
        /// <summary>Initializes a new instance of the ClassifierAccuracyReport class.
        /// </summary>

        public ClassifierAccuracyReport()
        {
            _classes = new Collection<ClassifierClass>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets accuracy information for each class.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<ClassifierClass> Classes
        {
            get { return _classes; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the accuracy of the classifier.
        /// </summary>
        /// <value>
        /// </value>

        public double Accuracy
        {
            get { return _accuracy; }
            set { _accuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a two-dimensional array containing information about how the classifier classifies its samples. 
        /// </summary>
        /// <returns>
        /// </returns>
        /// <remarks>
        /// This array is a square array, with both dimensions containing the number of classes in the classifier.  
        /// <para>Refer to the <format type="italics"> Determining the Quality of a Trained Classifier</format>  section of Chapter 15, <format type="italics"> Binary Particle Classification</format>, in the <format type="italics"> NI Vision Concepts Manual</format>  for more information about this field.
        /// </para>
        /// </remarks>

        public int[,] GetClassifierDistribution()
        {
            return _classifierDistribution;
        }

        
        internal void SetClassifierDistribution(int[,] classifierDistribution)
        {
            _classifierDistribution = classifierDistribution;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierAccuracyReport.
        /// </summary>
        /// <param name="other">
        /// A ClassifierAccuracyReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifierAccuracyReport other)
        {
            return other != null && Utilities.CollectionsEqual(_classes, other._classes) && Utilities.ArraysEqual(_classifierDistribution, other._classifierDistribution) && _accuracy == other._accuracy;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierAccuracyReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassifierAccuracyReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifierAccuracyReport other = (ClassifierAccuracyReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _classes.GetHashCode() ^ _classifierDistribution.GetHashCode() ^ _accuracy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifierAccuracyReport: Accuracy=" + _accuracy.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents a sample on which the classifier will be trained.
    /// </summary>

    public class ClassifierSample
    {
        private ClassifierSession _owner;
        private bool _upToDate = false;
        private int _index = -1;
        private string _className;
        internal Collection<double> _featureVector;

        
        internal ClassifierSample(ClassifierSession owner, int index)
        {
            _owner = owner;
            _index = index;
            _featureVector = new Collection<double>();
        }

        
        internal void Invalidate()
        {
            _upToDate = false;
        }

        
        internal int Index
        {
            get { return _index; }
            set { _index = value; }
        }

        
        internal void UpdateData(VisionImage optionalThumbnail)
        {
            _owner.ThrowIfDisposed();
            VisionImage.ThrowIfNonNullAndDisposed(optionalThumbnail);
            if (!_upToDate || optionalThumbnail != null)
            {
                Int32 unusedNumSamples;
                Array1D classNameArray;
                VisionDll.Priv_InitArray1D(out classNameArray);
                Array1D featureVectorArray;
                VisionDll.Priv_InitArray1D(out featureVectorArray);
                IntPtr imagePtr = IntPtr.Zero;
                if (optionalThumbnail != null)
                {
                    imagePtr = optionalThumbnail._image;
                }
                try
                {
                    Utilities.ThrowError(VisionDll.Priv_GetClassifierSampleInfo(imagePtr, _owner._session, _index, out unusedNumSamples, ref classNameArray, ref featureVectorArray));
                    byte[] classNameBytes = Utilities.ConvertArray1DTo1DStructureArray<byte>(classNameArray);
                    _className = Utilities.ConvertBytesToString(classNameBytes);
                    _featureVector = Utilities.ConvertArray1DToCollection<double>(featureVectorArray);
                }
                finally
                {
                    VisionDll.Priv_DisposeArray1DBytes(ref classNameArray);
                    VisionDll.Priv_DisposeArray1DBytes(ref featureVectorArray);
                }
                _upToDate = true;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the name of the class this sample is in.
        /// </summary>
        /// <value>
        /// </value>

        public string ClassName
        {
            get
            {
                UpdateData(null);
                return _className;
            }
            set
            {
                UpdateData(null);
                Utilities.ThrowError(VisionDll.imaqRelabelClassifierSample(_owner._session, _index, value));
                _className = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a thumbnail image of this sample.
        /// </summary>
        /// <param name="destination">
        /// </param>

        public void GetThumbnail(VisionImage destination)
        {
            if (destination == null) { throw new ArgumentNullException("destination"); }
            UpdateData(destination);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifierSample: Index=" + _index + ", ClassName=" + _className;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents a sample on which the classifier will be trained.
    /// </summary>
    /// <remarks>
    /// </remarks>

    public sealed class CustomClassifierSample : ClassifierSample
    {

        
        internal CustomClassifierSample(ClassifierSession owner, int index) : base(owner, index)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets the feature vector that describes this sample.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<double> FeatureVector
        {
            get
            {
                UpdateData(null);
                return _featureVector;
            }
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CustomClassifierSample: Index=" + Index + ", ClassName=" + ClassName;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents the Paramters of Window Size the Texture Defect
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class WindowOptions : IEquatable<WindowOptions>
    {
        private Int32 _x;
        private Int32 _y;
        private Int32 _stepSize;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the x.
        /// </summary>

        public Int32 X
        {
            get { return _x; }
            set { _x = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Gets or sets the y.
        /// </summary>

        public Int32 Y
        {
            get { return _y; }
            set { _y = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Gets or sets the stepSize.
        /// </summary>

        public Int32 StepSize
        {
            get { return _stepSize; }
            set { _stepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new Instance of WindowOptions Class.
        /// </summary>

        public WindowOptions()
            : this(15, 15, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the WindowOptions class.
        /// </summary>
        /// <param name="x">
        /// The part of the data that is an Int32.
        /// </param>
        /// <param name="y">
        /// The part of the data that is an Int32.
        /// </param>
        /// <param name="stepSize">
        /// The part of the data that is an Int32.
        /// </param>
        /// 
public WindowOptions(Int32 x, Int32 y, Int32 stepSize)
        {
            _x = x;
            _y = y;
            _stepSize = stepSize;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WindowOptions.
        /// </summary>
        /// <param name="other">
        /// A WindowOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(WindowOptions other)
        {
            return other != null && _x == other._x && _y == other._y && _stepSize == other._stepSize;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WindowOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of WindowOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            WindowOptions other = (WindowOptions)obj;
            return Equals(other);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _x.GetHashCode() ^ _y.GetHashCode() ^ _stepSize.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "WindowOptions: x = " + _x + ", y = " + _y + ", stepSize = " + _stepSize;
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Represents the DisplacementVector Paramters for Texture Defect
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DisplacementVector : IEquatable<DisplacementVector>
    {
        private Int32 _x;
        private Int32 _y;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the x.
        /// </summary>

        public Int32 X
        {
            get { return _x; }
            set { _x = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the y.
        /// </summary>

        public Int32 Y
        {
            get { return _y; }
            set { _y = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new Instance of DisplacementVector Class.
        /// </summary>

        public DisplacementVector()
            : this(1, 1)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DisplacementVector class.
        /// </summary>
        /// <param name="x">
        /// The part of the data that is an Int32.
        /// </param>
        /// <param name="y">
        /// The part of the data that is an Int32.
        /// </param>
        /// 
public DisplacementVector(Int32 x, Int32 y)
        {
            _x = x;
            _y = y;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DisplacementVector.
        /// </summary>
        /// <param name="other">
        /// A DisplacementVector instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DisplacementVector other)
        {
            return other != null && _x == other._x && _y == other._y;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DisplacementVector.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DisplacementVector
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DisplacementVector other = (DisplacementVector)obj;
            return Equals(other);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _x.GetHashCode() ^ _y.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DisplacementVector: x = " + _x + ", y = " + _y;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents the WaveletOptions for Texture Defect
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class WaveletOptions : IEquatable<WaveletOptions>
    {
        private WaveletType _typeOfWavelet;
        private double _minEnergy;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the WaveletType for Texture Defect Detection.
        /// </summary>
        /// <value>
        /// The default value is bior3_1.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// db02
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 		<item>
        /// 			<description>
        /// db03
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db04
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db05
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db06
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db07
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db08
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db09
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db10
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db11
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db12
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db13
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// db14
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// Haar
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior1_3
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior1_5
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior2_2
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior2_4
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior2_6
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior2_8
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior3_1
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior3_3
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior3_5
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior3_7
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior3_9
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior4_4
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// coif1
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// coif2
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// coif3
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// coif4
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// coif5
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym2
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym3
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym4
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym5
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym6
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym7
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// sym8
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior5_5
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// bior6_8
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public WaveletType Wavelet_Type
        {
            get { return _typeOfWavelet; }
            set { _typeOfWavelet = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the Min Energy parameter.
        /// </summary>

        public double MinEnergy
        {
            get { return _minEnergy; }
            set { _minEnergy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new Instance of WaveletOptions Class.
        /// </summary>

        public WaveletOptions()
            : this(WaveletType.Bior3_1, 100)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the WaveletOptions class.
        /// </summary>
        /// <param name="typeOfWavelet">
        /// Represents the WaveletType.
        /// </param>
        /// <param name="minEnergy">
        /// The part of the data that is a double. Represents the minimum Energy in the bands to consider for texture defect detection.
        /// </param>
        /// 
public WaveletOptions(WaveletType typeOfWavelet, double minEnergy)
        {
            _typeOfWavelet = typeOfWavelet;
            _minEnergy = minEnergy;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WaveletOptions.
        /// </summary>
        /// <param name="other">
        /// A WaveletOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(WaveletOptions other)
        {
            return other != null && _typeOfWavelet == other._typeOfWavelet && _minEnergy == other._minEnergy;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WaveletOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of WaveletOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            WaveletOptions other = (WaveletOptions)obj;
            return Equals(other);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _typeOfWavelet.GetHashCode() ^ _minEnergy.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "WaveletOptions: TypeOfWavelet = " + _typeOfWavelet.ToString() + ", MinEnergy = " + _minEnergy;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents the Paramters for configuring the Cooccurence matrix
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CooccurrenceOptions : IEquatable<CooccurrenceOptions>
    {
        private Int32 _level;
        private DisplacementVector _displacement;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the level/size of the matrix
        /// </summary>

        public Int32 Level
        {
            get { return _level; }
            set { _level = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the Displacemnet between pixels to accumulate the matrix
        /// </summary>

        public DisplacementVector Displacement
        {
            get { return _displacement; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _displacement = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new Instance of CooccurrenceOptions Class.
        /// </summary>

        public CooccurrenceOptions()
            : this(16, new DisplacementVector())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CooccurrenceOptions class.
        /// </summary>
        /// <param name="level">
        /// Represents the level/size of the matrix.
        /// </param>
        /// 
public CooccurrenceOptions(Int32 level, DisplacementVector displacement)
        {
            _level = level;
            _displacement = displacement;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CooccurrenceOptions.
        /// </summary>
        /// <param name="other">
        /// A CooccurrenceOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CooccurrenceOptions other)
        {
            return other != null && _level == other._level && _displacement.Equals(other._displacement);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CooccurrenceOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CooccurrenceOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CooccurrenceOptions other = (CooccurrenceOptions)obj;
            return Equals(other);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _level.GetHashCode() ^ _displacement.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CooccurrenceOptions: Level = " + _level + ", Displacement = " + _displacement.ToString();
        }

    }

    //==============================================================================================
    /// <summary>
    /// Provides the distance from a class to the item that was classified.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public class ClassScore
    {
        private string _className;
        private double _distance;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassScore class.
        /// </summary>
        /// <param name="className">
        /// The name of the class.
        /// </param>
        /// <param name="distance">
        /// The distance between the closest sample of this class and the input sample.
        /// </param>

        public ClassScore(string className, double distance)
        {
            _className = className;
            _distance = distance;
        }

        //==========================================================================================
        /// <summary>Gets or sets the name of this class.
        /// </summary>
        /// <value>
        /// </value>

        public string ClassName
        {
            get { return _className; }
            set { _className = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance between the closest sample in this class and the input sample.
        /// </summary>
        /// <value>
        /// </value>

        public double Distance
        {
            get { return _distance; }
            set { _distance = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassScore.
        /// </summary>
        /// <param name="other">
        /// A ClassScore instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassScore other)
        {
            return other != null && _className == other._className && _distance == other._distance;
        }
        //==========================================================================================
        /// <summary>Returns a value indicating whether this instance is equal to the specified ClassScore.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassScore and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassScore other = (ClassScore)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _className.GetHashCode() ^ _distance.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassScore: ClassName=" + _className + ", Distance=" + _distance.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    ///  Provides the results of the Classify and CustomClassify methods.
    /// </summary>

    [Serializable]
    public sealed class SampleScore : ClassScore
    {
        private int _index = -1;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SampleScore class.
        /// </summary>
        /// <param name="className">
        /// Specifies the name of the class.
        /// </param>
        /// <param name="distance">
        /// Specifies the distance from the item to the class.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample.
        /// </param>

        public SampleScore(string className, double distance, int index) : base(className, distance)
        {
            _index = index;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the index of the sample.
        /// </summary>

        public int Index
        {
            get { return _index; }
            set { _index = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SampleScore.
        /// </summary>
        /// <param name="other">
        /// A SampleScore instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SampleScore other)
        {
            return other != null && ClassName == other.ClassName && Distance == other.Distance && _index == other._index;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SampleScore.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SampleScore
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SampleScore other = (SampleScore)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ClassName.GetHashCode() ^ Distance.GetHashCode() ^ _index.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassScore: ClassName=" + ClassName + ", Distance=" + Distance.ToString(CultureInfo.CurrentCulture) + ", Index=" + _index;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides a report of the results of classification.
    /// </summary>

    [Serializable]
    public class ClassifierReport
    {
        private string _bestClassName;
        private double _classificationScore;
        private double _identificationScore;
        private Collection<ClassScore> _allScores;

        //==========================================================================================
        /// <summary>Initializes a new instance of the ClassifierReport class.
        /// </summary>

        public ClassifierReport() {
            _allScores = new Collection<ClassScore>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the collection of classes and their scores. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// The collection contains one score for each class in the classifier.
        /// </remarks>

        public Collection<ClassScore> AllScores
        {
            get { return _allScores; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_allScores = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a score indicating the level of similarity of the sample and the assigned class. 
        /// </summary>
        /// <value>
        /// </value>

        public double IdentificationScore
        {
            get { return _identificationScore; }
            set { _identificationScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a value indicating the similarity of the sample and the two closest classes in the classifier.
        /// </summary>
        /// <value>
        /// </value>

        public double ClassificationScore
        {
            get { return _classificationScore; }
            set { _classificationScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the name of the class the classifier categorizes the input sample in.
        /// </summary>
        /// <value>
        /// </value>

        public string BestClassName
        {
            get { return _bestClassName; }
            set { _bestClassName = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierReport.
        /// </summary>
        /// <param name="other">
        /// A ClassifierReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifierReport other)
        {
            return other != null && _bestClassName == other._bestClassName && _classificationScore == other._classificationScore && _identificationScore == other._identificationScore && Utilities.CollectionsEqual(_allScores, other._allScores);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of  ClassifierReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifierReport other = (ClassifierReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _bestClassName.GetHashCode() ^ _classificationScore.GetHashCode() ^ _identificationScore.GetHashCode() ^ _allScores.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifierReport: BestClassName=" + _bestClassName + ", ClassificationScore=" + _classificationScore.ToString(CultureInfo.CurrentCulture) + ", IdentificationScore=" + _identificationScore.ToString(CultureInfo.CurrentCulture);
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides a report of the results of classification.
    /// </summary>

    [Serializable]
    public sealed class ClassifierReportAdvanced : ClassifierReport
    {
      
        private Collection<SampleScore> _sampleScores;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifierReportAdvanced class.
        /// </summary>

        public ClassifierReportAdvanced() : base()
        {
            _sampleScores = new Collection<SampleScore>();
        }
        
        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of all samples and their scores.
        /// </summary>

        public Collection<SampleScore> SampleScores
        {
            get { return _sampleScores; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _sampleScores = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierReportAdvanced.
        /// </summary>
        /// <param name="other">
        /// A ClassifierReportAdvanced instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifierReportAdvanced other)
        {
            return other != null && BestClassName == other.BestClassName && ClassificationScore == other.ClassificationScore && IdentificationScore == other.IdentificationScore && Utilities.CollectionsEqual(AllScores, other.AllScores) && Utilities.CollectionsEqual(_sampleScores, other._sampleScores);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifierReportAdvanced.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of  ClassifierReportAdvanced
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifierReportAdvanced other = (ClassifierReportAdvanced)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return BestClassName.GetHashCode() ^ ClassificationScore.GetHashCode() ^ IdentificationScore.GetHashCode() ^ AllScores.GetHashCode() ^ SampleScores.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifierReportAdvanced: BestClassName=" + BestClassName + ", ClassificationScore=" + ClassificationScore.ToString(CultureInfo.CurrentCulture) + ", IdentificationScore=" + IdentificationScore.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options to use when training with a Nearest Neighbor engine.
    /// </summary>

    public class ReadOnlyNearestNeighborOptions : IEquatable<ReadOnlyNearestNeighborOptions>
    {
        private NearestNeighborMethod _method;
        private NearestNeighborMetric _metric;
        private Int32 _k;
        private ClassifierSession _owner = null;

internal ReadOnlyNearestNeighborOptions()
            : this(NearestNeighborMethod.MinimumMeanDistance)
        {
        }

        
        internal ReadOnlyNearestNeighborOptions(NearestNeighborMethod method)
            : this(method, NearestNeighborMetric.Sum)
        {
        }

        
        internal ReadOnlyNearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric)
            : this(method, metric, 3)
        {
        }

        
        internal ReadOnlyNearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric, int k)
        {
            _method = method;
            _metric = metric;
            _k = k;
        }

        
        internal ReadOnlyNearestNeighborOptions(ClassifierSession owner) : this()
        {
            _owner = owner;
        }

internal void UpdateData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_NearestNeighborOptions cviOptions = new CVI_NearestNeighborOptions();
                try
                {
                    Utilities.ThrowError(VisionDll.imaqGetNearestNeighborOptions(_owner._session, out cviOptions));
                }
                catch (VisionException ex)
                {
                    // It's OK if we haven't trained yet and have no options, or if we can't get the options because we're compact.
                    if (ex.VisionErrorCode != ErrorCode.ClassifierSessionNotTrained && ex.VisionErrorCode != ErrorCode.InvalidOperationOnCompactSessionAttempted)
                    {
                        throw;
                    }
                }
                NearestNeighborOptions options = cviOptions.ConvertToExternal();
                _method = options._method;
                _metric = options._metric;
                _k = options._k;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the value of K to use when Method is set to KNearestNeighbor.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public Int32 K
        {
            get {
                UpdateData();
                return _k;
            }
            internal set
            {
                _k = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the metric to use when training the classifier.
        /// </summary>
        /// <value>
        /// The default is Sum.
        /// </value>

        public NearestNeighborMetric Metric
        {
            get {
                UpdateData();
                return _metric;
            }
            internal set
            {
                _metric = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the method to use when training the classifier.
        /// </summary>
        /// <value>
        /// The default is MinimumMeanDistance.
        /// </value>

        public NearestNeighborMethod Method
        {
            get
            {
                UpdateData();
                return _method;
            }
            internal set
            {
                _method = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadOnlyNearestNeighborOptions.
        /// </summary>
        /// <param name="other">
        /// A ReadOnlyNearestNeighborOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ReadOnlyNearestNeighborOptions other)
        {
            return other != null && _method == other._method && _metric == other._metric && _k == other._k;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ReadOnlyNearestNeighborOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ReadOnlyNearestNeighborOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ReadOnlyNearestNeighborOptions other = (ReadOnlyNearestNeighborOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _method.GetHashCode() ^ _metric.GetHashCode() ^ _k.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ReadOnlyNearestNeighborOptions: Method=" + _method + ", Metric=" + _metric + ", K=" + _k;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options to use when training with a Nearest Neighbor engine.
    /// </summary>

    [Serializable]
    public sealed class NearestNeighborOptions : ReadOnlyNearestNeighborOptions, IEquatable<NearestNeighborOptions> {
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborOptions class.
        /// </summary>

        public NearestNeighborOptions()
            : this(NearestNeighborMethod.MinimumMeanDistance)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborOptions class.
        /// </summary>
        /// <param name="method">
        /// The method to use when training the classifier.
        /// </param>

        public NearestNeighborOptions(NearestNeighborMethod method)
            : this(method, NearestNeighborMetric.Sum)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborOptions class.
        /// </summary>
        /// <param name="method">
        /// The method to use when training the classifier.
        /// </param>
        /// <param name="metric">
        /// The metric to use when training the classifier.
        /// </param>

        public NearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric)
            : this(method, metric, 3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborOptions class.
        /// </summary>
        /// <param name="method">
        /// The method to use when training the classifier.
        /// </param>
        /// <param name="metric">
        /// The metric to use when training the classifier.
        /// </param>
        /// <param name="k">
        /// The value of K to use when the method is set to KNearestNeighbor.
        /// </param>

        public NearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric, int k) : base(method, metric, k)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the method to use when training the classifier.
        /// </summary>
        /// <value>
        /// The default is MinimumMeanDistance.
        /// </value>

        public new NearestNeighborMethod Method
        {
            get
            {
                return base.Method;
            }
            set
            {
                base.Method = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the metric to use when training the classifier.
        /// </summary>
        /// <value>
        /// The default is Sum.
        /// </value>

        public new NearestNeighborMetric Metric
        {
            get
            {
                return base.Metric;
            }
            set
            {
                base.Metric = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the value of K to use when Method is set to KNearestNeighbor.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public new Int32 K
        {
            get {
                return base.K;
            }
            set
            {
                base.K = value;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborOptions.
        /// </summary>
        /// <param name="other">
        /// A NearestNeighborOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(NearestNeighborOptions other)
        {
            return other != null && base.Equals((ReadOnlyNearestNeighborOptions)other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of NearestNeighborOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            NearestNeighborOptions other = (NearestNeighborOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "NearestNeighborOptions: Method=" + Method + ", Metric=" + Metric + ", K=" + K;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the results of training with the Nearest Neighbor engine.
    /// </summary>

    [Serializable]
    public sealed class NearestNeighborClassResult
    {
        private string _className;
        private double _standardDeviation;
        private Int32 _count;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborClassResult class.
        /// </summary>

        public NearestNeighborClassResult()
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of samples in this class.
        /// </summary>

        public Int32 Count
        {
            get { return _count; }
            set { _count = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the standard deviation of the members of this class.
        /// </summary>

        public double StandardDeviation
        {
            get { return _standardDeviation; }
            set { _standardDeviation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the name of the class.
        /// </summary>

        public string ClassName
        {
            get { return _className; }
            set { _className = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborClassResult
        /// </summary>
        /// <param name="other">
        /// A NearestNeighborClassResult instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(NearestNeighborClassResult other)
        {
            return other != null && _className == other._className && _standardDeviation == other._standardDeviation && _count == other._count;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborClassResult.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of NearestNeighborClassResult
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            NearestNeighborClassResult other = (NearestNeighborClassResult)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _className.GetHashCode() ^ _standardDeviation.GetHashCode() ^ _count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "NearestNeighborClassResult: ClassName=" + _className + ", Count=" + _count.ToString(CultureInfo.CurrentCulture) + ", StandardDeviation=" + _standardDeviation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the results of training a classifier session with the nearest neighbor algorithm.
    /// </summary>

    [Serializable]
    public sealed class NearestNeighborTrainingReport
    {
        private double[,] _classDistancesTable;
        private Collection<NearestNeighborClassResult> _classResults;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the NearestNeighborTrainingReport class.
        /// </summary>

        public NearestNeighborTrainingReport()
        {
            _classResults = new Collection<NearestNeighborClassResult>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets a table that gives the mean distance from each class to each other class.
        /// </summary>
        /// <returns>
        /// An arrary giving the mean distance from each class to each other class.
        /// </returns>

        public double[,] GetClassDistancesTable()
        {
            return _classDistancesTable;
        }
        //==========================================================================================
        /// <summary>
        /// Sets an array that gives the mean distance from each class to each other class.
        /// </summary>
        /// <param name="classDistancesTable">
        /// An arrary giving the mean distance from each class to each other class.
        /// </param>

        public void SetClassDistancesTable(double[,] classDistancesTable)
        {
            _classDistancesTable = classDistancesTable;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of results of the nearest neighbor training for every class.
        /// </summary>

        public Collection<NearestNeighborClassResult> ClassResults
        {
            get { return _classResults; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_classResults = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborTrainingReport.
        /// </summary>
        /// <param name="other">
        /// A NearestNeighborTrainingReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(NearestNeighborTrainingReport other)
        {
            return other != null && Utilities.ArraysEqual(_classDistancesTable, other._classDistancesTable) && Utilities.CollectionsEqual(_classResults, other._classResults);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified NearestNeighborTrainingReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of NearestNeighborTrainingReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            NearestNeighborTrainingReport other = (NearestNeighborTrainingReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _classDistancesTable.GetLength(0).GetHashCode() ^ _classDistancesTable.GetLength(1).GetHashCode() ^ _classResults.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "NearestNeighborTrainingReport: ClassResults=" + _classResults.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Options used by a particle classifier to turn a grayscale image into a binary image when using an auto threshold.
    /// </summary>

    [Serializable]
    public sealed class ParticleClassifierAutoThresholdOptions
    {
        private ThresholdMethod _method;
        private ParticleType _particleType;
        private Range _limits;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleClassifierAutoThresholdOptions class.
        /// </summary>

        public ParticleClassifierAutoThresholdOptions()
        {
            _method = ThresholdMethod.Clustering;
            _particleType = ParticleType.Bright;
            _limits = new Range(0, 255);
            _limits.PropertyChanged += new EventHandler<EventArgs>(_limits_PropertyChanged);
        }

void _limits_PropertyChanged(object sender, EventArgs e)
        {
            // If the limits changed, we changed.
            OnPropertyChanged(e);
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the limits on the automatic threshold range. 
        /// </summary>
        /// <value>
        /// The default is (0, 255).
        /// </value>

        public Range Limits
        {
            get { return _limits; }
            set
            {
                if (value == null) { throw new ArgumentNullException("value"); }
                _limits.PropertyChanged -= _limits_PropertyChanged;
                _limits = value;
                _limits.PropertyChanged += _limits_PropertyChanged;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets what kind of particles to look for. 
        /// </summary>
        /// <value>
        /// The default is Bright.
        /// </value>

        public ParticleType ParticleType
        {
            get { return _particleType; }
            set {
                _particleType = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of binary thresholding, which specifies how to calculate the classes. 
        /// </summary>
        /// <value>
        /// The default is Clustering.
        /// </value>

        public ThresholdMethod Method
        {
            get { return _method; }
            set {
                _method = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The ParticleClassifierAutoThresholdOptions to copy data to.
        /// </param>

        public void CopyTo(ParticleClassifierAutoThresholdOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options.Method = _method;
            options.ParticleType = _particleType;
            options.Limits = _limits;
        }

internal void CopyFrom(ParticleClassifierAutoThresholdOptions options)
        {
            _method = options.Method;
            _particleType = options.ParticleType;
            _limits._min = options.Limits.Minimum;
            _limits._max = options.Limits.Maximum;
        }

internal event EventHandler<EventArgs> PropertyChanged;

        
        internal void OnPropertyChanged(EventArgs args) {
            EventHandler<EventArgs> handler = PropertyChanged;
            if (handler != null) {
                handler(this, args);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierAutoThresholdOptions.
        /// </summary>
        /// <param name="other">
        /// A ParticleClassifierAutoThresholdOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleClassifierAutoThresholdOptions other)
        {
            return other != null && _method == other._method && _particleType == other._particleType && _limits.Equals(other._limits);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierAutoThresholdOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleClassifierAutoThresholdOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleClassifierAutoThresholdOptions other = (ParticleClassifierAutoThresholdOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _method.GetHashCode() ^ _particleType.GetHashCode() ^ _limits.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleClassifierAutoThresholdOptions: Method=" + _method.ToString() + ", ParticleType=" + _particleType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Options used by a particle classifier to turn a grayscale image into a binary image when using a local threshold.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ParticleClassifierLocalThresholdOptions
    {
        private LocalThresholdMethod _method;
        private ParticleType _particleType;
        private UInt32 _windowWidth;
        private UInt32 _windowHeight;
        private double _deviationWeight;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleClassifierLocalThresholdOptions class.
        /// </summary>

        public ParticleClassifierLocalThresholdOptions()
        {
            _method = LocalThresholdMethod.NiBlack;
            _particleType = ParticleType.Bright;
            _windowWidth = 32;
            _windowHeight = 32;
            _deviationWeight = .2;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the k constant used in the Niblack local thresholding algorithm, which determines 
        /// the weight applied to the variance calculation. Valid k constants range from 0 to 1. Settings 
        /// this value to 0 will increase the performance of the method because the method will not 
        /// calculate the variance for any of the pixels. The method ignores this value if Method is not 
        /// set to NiBlack. 
        /// </summary>
        /// <value>
        /// The default is 0.2.
        /// </value>

        public double DeviationWeight
        {
            get { return _deviationWeight; }
            set {
                _deviationWeight = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the rectangular window around the pixel on which the method performs 
        /// the local threshold. This number must be at least 3 and cannot be larger than the 
        /// height of an image being classified. 
        /// </summary>
        /// <value>
        /// The default is 32.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 WindowHeight
        {
            get { return _windowHeight; }
            set {
                _windowHeight = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the rectangular window around the pixel on which the method 
        /// performs the local threshold. This number must be at least 3 and cannot be larger than 
        /// the width of an image being classified. 
        /// </summary>
        /// <value>
        /// The default is 32.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 WindowWidth
        {
            get { return _windowWidth; }
            set {
                _windowWidth = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets what kind of particles to look for. 
        /// </summary>
        /// <value>
        /// The default is Bright.
        /// </value>

        public ParticleType ParticleType
        {
            get { return _particleType; }
            set {
                _particleType = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of local thresholding the method uses. 
        /// </summary>
        /// <value>
        /// The default is NiBlack.
        /// </value>

        public LocalThresholdMethod Method
        {
            get { return _method; }
            set
            {
                _method = value;
                OnPropertyChanged(EventArgs.Empty);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The ParticleClassifierLocalThresholdOptions to copy data to.
        /// </param>

        public void CopyTo(ParticleClassifierLocalThresholdOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options.Method = _method;
            options.ParticleType = _particleType;
            options.WindowWidth = _windowWidth;
            options.WindowHeight = _windowHeight;
            options.DeviationWeight = _deviationWeight;
        }

internal void CopyFrom(ParticleClassifierLocalThresholdOptions options)
        {
            _method = options.Method;
            _particleType = options.ParticleType;
            _windowWidth = options.WindowWidth;
            _windowHeight = options.WindowHeight;
            _deviationWeight = options.DeviationWeight;
        }

internal event EventHandler<EventArgs> PropertyChanged;

        
        internal void OnPropertyChanged(EventArgs args) {
            EventHandler<EventArgs> handler = PropertyChanged;
            if (handler != null) {
                handler(this, args);
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierLocalThresholdOptions.
        /// </summary>
        /// <param name="other">
        /// A ParticleClassifierLocalThresholdOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleClassifierLocalThresholdOptions other)
        {
            return other != null && _method == other._method && _particleType == other._particleType && _windowWidth == other._windowWidth && _windowHeight == other._windowHeight && _deviationWeight == other._deviationWeight;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierLocalThresholdOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleClassifierLocalThresholdOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleClassifierLocalThresholdOptions other = (ParticleClassifierLocalThresholdOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _method.GetHashCode() ^ _particleType.GetHashCode() ^ _windowWidth.GetHashCode() ^ _windowHeight.GetHashCode() ^ _deviationWeight.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleClassifierLocalThresholdOptions: Method=" + _method.ToString() + ", ParticleType=" + _particleType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Options used by a particle classifier to turn a grayscale image into a binary image.
    /// </summary>

    [Serializable]
    public sealed class ParticleClassifierPreprocessingOptions
    {
        [NonSerialized]
        private ClassifierSession _owner = null;
        private ThresholdType _thresholdType;
        private Range _manualThresholdRange;
        private ParticleClassifierAutoThresholdOptions _autoThresholdOptions;
        private ParticleClassifierLocalThresholdOptions _localThresholdOptions;
        private bool _rejectBorder;
        private Int32 _numErosions;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to local threshold the image. This parameter is only used if 
        /// ThresholdType is set to Local. 
        /// </summary>

        public ParticleClassifierLocalThresholdOptions LocalThresholdOptions
        {
            get { return _localThresholdOptions; }
            internal set {
                _localThresholdOptions.PropertyChanged -= _subpropertyChanged;
                _localThresholdOptions = value;
                _localThresholdOptions.PropertyChanged += _subpropertyChanged;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to auto threshold the image. This parameter is 
        /// only used if ThresholdType is set to Auto. 
        /// </summary>

        public ParticleClassifierAutoThresholdOptions AutoThresholdOptions
        {
            get { return _autoThresholdOptions; }
            internal set {
                _autoThresholdOptions.PropertyChanged -= _subpropertyChanged;
                _autoThresholdOptions = value;
                _autoThresholdOptions.PropertyChanged += _subpropertyChanged;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of threshold to perform on the image. 
        /// </summary>
        /// <value>
        /// The default is Manual.
        /// </value>

        public ThresholdType ThresholdType
        {
            get { return _thresholdType; }
            set { _thresholdType = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of erosions to perform. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 NumberOfErosions
        {
            get { return _numErosions; }
            set { _numErosions = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to reject border particles. Set this parameter to 
        /// <see langword="true"/> to reject border particles. Set this parameter to 
        /// <see langword="false"/> to keep border particles. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RejectBorder
        {
            get { return _rejectBorder; }
            set { _rejectBorder = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of pixels to keep if manually thresholding the image. This parameter is only used if 
        /// ThresholdType is set to Manual. 
        /// </summary>
        /// <value>
        /// The default is (1, 255).
        /// </value>

        public Range ManualThresholdRange
        {
            get { return _manualThresholdRange; }
            set {
                if (value == null) { throw new ArgumentNullException("value"); }
                _manualThresholdRange.PropertyChanged -= _subpropertyChanged;
                _manualThresholdRange = value;
                _manualThresholdRange.PropertyChanged += _subpropertyChanged;
                SetData();
            }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleClassifierPreprocessingOptions class.
        /// </summary>

        public ParticleClassifierPreprocessingOptions()
        {
            _thresholdType = ThresholdType.Manual;
            _manualThresholdRange = new Range(1, 255);
            _manualThresholdRange.PropertyChanged += new EventHandler<EventArgs>(_subpropertyChanged);
            _autoThresholdOptions = new ParticleClassifierAutoThresholdOptions();
            _autoThresholdOptions.PropertyChanged += new EventHandler<EventArgs>(_subpropertyChanged);
            _localThresholdOptions = new ParticleClassifierLocalThresholdOptions();
            _localThresholdOptions.PropertyChanged += new EventHandler<EventArgs>(_subpropertyChanged);
            _rejectBorder = false;
            _numErosions = 0;
        }

void _subpropertyChanged(object sender, EventArgs e)
        {
            SetData();
        }

internal ParticleClassifierPreprocessingOptions(ClassifierSession owner) : this()
        {
            _owner = owner;
            UpdateData();
        }

internal void UpdateData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ParticleClassifierPreprocessingOptions2 cviOptions = new CVI_ParticleClassifierPreprocessingOptions2();
                Utilities.ThrowError(VisionDll.imaqGetParticleClassifierOptions2(_owner._session, out cviOptions, IntPtr.Zero));
                ParticleClassifierPreprocessingOptions options = cviOptions.ConvertToExternal();
                // Copy to the individual members to avoid firing the change event again.
                _thresholdType = options.ThresholdType;
                _manualThresholdRange._min = options.ManualThresholdRange.Minimum;
                _manualThresholdRange._max = options.ManualThresholdRange.Maximum;
                _autoThresholdOptions.CopyFrom(options.AutoThresholdOptions);
                _localThresholdOptions.CopyFrom(options.LocalThresholdOptions);
                _rejectBorder = options.RejectBorder;
                _numErosions = options.NumberOfErosions;
            }
        }

        
        internal void SetData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ParticleClassifierPreprocessingOptions2 cviOptions = new CVI_ParticleClassifierPreprocessingOptions2();
                cviOptions.ConvertFromExternal(this);
                try
                {
                    Utilities.ThrowError(VisionDll.imaqSetParticleClassifierOptions2(_owner._session, ref cviOptions, IntPtr.Zero));
                }
                catch (VisionException)
                {
                    // Restore our state to what it was before we set something.
                    UpdateData();
                    throw;
                }
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The ParticleClassifierPreprocessingOptions to copy data to.
        /// </param>

        public void CopyTo(ParticleClassifierPreprocessingOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options.ThresholdType = _thresholdType;
            options.ManualThresholdRange = _manualThresholdRange;
            _autoThresholdOptions.CopyTo(options.AutoThresholdOptions);
            _localThresholdOptions.CopyTo(options.LocalThresholdOptions);
            options.RejectBorder = RejectBorder;
            options.NumberOfErosions = NumberOfErosions;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierPreprocessingOptions.
        /// </summary>
        /// <param name="other">
        /// A ParticleClassifierPreprocessingOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleClassifierPreprocessingOptions other)
        {
            return other != null && _thresholdType == other._thresholdType && _manualThresholdRange.Equals(other._manualThresholdRange) && _autoThresholdOptions.Equals(other._autoThresholdOptions) && _localThresholdOptions.Equals(other._localThresholdOptions) && _rejectBorder == other._rejectBorder && _numErosions == other._numErosions;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierPreprocessingOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleClassifierPreprocessingOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleClassifierPreprocessingOptions other = (ParticleClassifierPreprocessingOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _thresholdType.GetHashCode() ^ _manualThresholdRange.GetHashCode() ^ _autoThresholdOptions.GetHashCode() ^ _localThresholdOptions.GetHashCode() ^ _rejectBorder.GetHashCode() ^ _numErosions.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleClassifierPreprocessingOptions: ThresholdType=" + _thresholdType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines the dependence of the particle classifier on shape, scale, and mirror symmetry.
    /// </summary>

    [Serializable]
    public sealed class ParticleClassifierOptions
    {
        [NonSerialized]
        private ClassifierSession _owner = null;
        private double _scaleDependence;
        private double _mirrorDependence;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the relative importance of mirror symmetry when classifying particles. 
        /// This value ranges from 0 to 1000. 
        /// <para>
        /// An example of objects exhibiting mirror symmetry are the lowercase letters p and q. If 
        /// MirrorDependence is 0, the samples are classified independent of mirror symmetry. For 
        /// example, p and q would be classified as the same class. 
        /// </para>
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double MirrorDependence
        {
            get { return _mirrorDependence; }
            set { _mirrorDependence = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the relative importance (between 0 and 1000) of scale when classifying particles. If 
        /// the value is 0, the samples are classified independent of scale.
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double ScaleDependence
        {
            get { return _scaleDependence; }
            set { _scaleDependence = value; SetData(); }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleClassifierOptions class.
        /// </summary>

        public ParticleClassifierOptions()
        {
            _scaleDependence = 0;
            _mirrorDependence = 0;
        }

        
        internal ParticleClassifierOptions(ClassifierSession owner)
        {
            _owner = owner;
            UpdateData();
        }

internal void UpdateData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ParticleClassifierOptions cviOptions = new CVI_ParticleClassifierOptions();
                Utilities.ThrowError(VisionDll.imaqGetParticleClassifierOptions2(_owner._session, IntPtr.Zero, out cviOptions));
                ParticleClassifierOptions options = cviOptions.ConvertToExternal();
                _mirrorDependence = options._mirrorDependence;
                _scaleDependence = options._scaleDependence;
            }
        }

        
        internal void SetData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ParticleClassifierOptions cviOptions = new CVI_ParticleClassifierOptions();
                cviOptions.ConvertFromExternal(this);
                try
                {
                    Utilities.ThrowError(VisionDll.imaqSetParticleClassifierOptions2(_owner._session, IntPtr.Zero, ref cviOptions));
                }
                catch (VisionException)
                {
                    // Restore our state to what it was before we set something.
                    UpdateData();
                    throw;
                }
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The ParticleClassifierOptions to copy data to.
        /// </param>

        public void CopyTo(ParticleClassifierOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options.MirrorDependence = MirrorDependence;
            options.ScaleDependence = ScaleDependence;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierOptions.
        /// </summary>
        /// <param name="other">
        /// A ParticleClassifierOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleClassifierOptions other)
        {
            return other != null && _scaleDependence == other._scaleDependence && _mirrorDependence == other._mirrorDependence;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleClassifierOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleClassifierOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleClassifierOptions other = (ParticleClassifierOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _scaleDependence.GetHashCode() ^ _mirrorDependence.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleClassifierOptions: ScaleDependence=" + _scaleDependence.ToString(CultureInfo.CurrentCulture) + ", MirrorDependence=" + _mirrorDependence.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Configures the color classifier options for the classifier session.
    /// </summary>

    [Serializable]
    public sealed class ColorClassifierOptions
    {
        [NonSerialized]
        private ClassifierSession _owner = null;
        private bool _useLuminance;
        private ColorClassifierResolution _colorClassifierResolution;
        private ColorMode _colorMode = ColorMode.Hsl;

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to use the luminance band in the feature vector.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool UseLuminance
        {
            get { return _useLuminance; }
            set { _useLuminance = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the color resolution to use.
        /// </summary>
        /// <value>
        /// The default is High.
        /// </value>

        public ColorClassifierResolution ColorClassifierResolution
        {
            get { return _colorClassifierResolution; }
            set { _colorClassifierResolution = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a ColorClassifierOptions class.
        /// </summary>

        public ColorClassifierOptions()
        {
            _useLuminance = false;
            _colorClassifierResolution = ColorClassifierResolution.High;
            _colorMode = ColorMode.Hsl;
        }

internal ColorClassifierOptions(ClassifierSession owner)
        {
            _owner = owner;
            UpdateData();
        }

internal void UpdateData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ColorOptions cviOptions = new CVI_ColorOptions();
                Utilities.ThrowError(VisionDll.imaqGetColorClassifierOptions(_owner._session, out cviOptions));
                ColorClassifierOptions options = cviOptions.ConvertToExternal();
                _useLuminance = options.UseLuminance;
                _colorClassifierResolution = options.ColorClassifierResolution;
            }
        }
        /// <summary>
        /// Sets this options structure to the session. 
        /// </summary>
        internal void SetData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_ColorOptions cviOptions = new CVI_ColorOptions();
                cviOptions.ConvertFromExternal(this);
                try
                {
                    Utilities.ThrowError(VisionDll.imaqSetColorClassifierOptions(_owner._session, ref cviOptions));
                }
                catch (VisionException)
                {
                    // Restore our state to what it was before we set something.
                    UpdateData();
                    throw;
                }
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The ColorClassifierOptions to copy data to.
        /// </param>

        public void CopyTo(ColorClassifierOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options.UseLuminance = UseLuminance;
            options.ColorClassifierResolution = ColorClassifierResolution;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorClassifierOptions.
        /// </summary>
        /// <param name="other">
        /// A ColorClassifierOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ColorClassifierOptions other)
        {
            return other != null && _useLuminance == other._useLuminance && _colorClassifierResolution == other._colorClassifierResolution && _colorMode == other._colorMode;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorClassifierOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ColorClassifierOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ColorClassifierOptions other = (ColorClassifierOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _useLuminance.GetHashCode() ^ _colorClassifierResolution.GetHashCode() ^ _colorMode.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ColorClassifierOptions: UseLuminance=" + _useLuminance.ToString(CultureInfo.CurrentCulture) + ", ColorClassificationResolution=" + _colorClassifierResolution.ToString() + ", ColorMode=" + _colorMode.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Configures the Texture Defect Classifier options for the classifier session.
    /// </summary>

    [Serializable]
    public sealed class TextureDefectClassifierOptions
    {
        [NonSerialized]
        private ClassifierSession _owner = null;
        private WindowOptions _windowOptions;
        private WaveletOptions _waveletOptions;
        private Collection<int> _bandsUsed;
        private CooccurrenceOptions _cooccurrenceOptions;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the Window Options.
        /// </summary>

        public WindowOptions Window_Options
        {
            get { return _windowOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _windowOptions = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the Wavelet Options Options.
        /// </summary>

        public WaveletOptions Wavelet_Options
        {
            get { return _waveletOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _waveletOptions = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array that describes the number of wavelet bands used.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<int> BandsUsed
        {
            get { return _bandsUsed; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _bandsUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array the Cooccurence Options.
        /// </summary>
        /// <value>
        /// </value>

        public CooccurrenceOptions Cooccurrence_Options
        {
            get { return _cooccurrenceOptions; }
            set { _cooccurrenceOptions = value; SetData(); }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a TextureDefectClassifierOptions class.
        /// </summary>

        public TextureDefectClassifierOptions()
        {
            _windowOptions = new WindowOptions();
            _waveletOptions = new WaveletOptions();
            _bandsUsed = new Collection<int>();
            _cooccurrenceOptions = new CooccurrenceOptions();
        }

internal TextureDefectClassifierOptions(ClassifierSession owner)
        {
            _owner = owner;
            UpdateData();
        }

internal void UpdateData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_WindowOptions cviWindowSize = new CVI_WindowOptions();
                CVI_WaveletOptions cviWaveletOptions = new CVI_WaveletOptions();
                CVI_CooccurrenceOptions cviCooccurrenceOptions = new CVI_CooccurrenceOptions();
                IntPtr bandsUsed = IntPtr.Zero;
                Int32 numBandsUsed = (Int32)0;
                Utilities.ThrowError(VisionDll.imaqClassificationTextureDefectOptions(_owner._session, ref cviWindowSize, ref cviWaveletOptions, bandsUsed, ref numBandsUsed, ref cviCooccurrenceOptions, (char)0));

                _windowOptions = cviWindowSize.ConvertToExternal();
                _waveletOptions = cviWaveletOptions.ConvertToExternal();
                _cooccurrenceOptions = cviCooccurrenceOptions.ConvertToExternal();
                _bandsUsed = Utilities.ConvertIntPtrToCollection<int>(bandsUsed, numBandsUsed, true);
            }
        }

        /// <summary>
        /// Sets this options structure to the session. 
        /// </summary>
        internal void SetData()
        {
            if (_owner != null)
            {
                _owner.ThrowIfDisposed();
                CVI_WindowOptions cviWindowSize = new CVI_WindowOptions();
                CVI_WaveletOptions cviWaveletOptions = new CVI_WaveletOptions();
                CVI_CooccurrenceOptions cviCooccurrenceOptions = new CVI_CooccurrenceOptions();
                IntPtr bandsUsed;
                Int32 numBandsUsed;
                cviWindowSize.ConvertFromExternal(_windowOptions);
                cviWaveletOptions.ConvertFromExternal(_waveletOptions);
                cviCooccurrenceOptions.ConvertFromExternal(_cooccurrenceOptions);
                bandsUsed = Utilities.ConvertCollectionToIntPtr<int>(_bandsUsed);
                numBandsUsed = _bandsUsed.Count;
                try
                {
                    Utilities.ThrowError(VisionDll.imaqClassificationTextureDefectOptions(_owner._session, ref cviWindowSize, ref cviWaveletOptions, bandsUsed, ref numBandsUsed, ref cviCooccurrenceOptions, (char)1));
                }
                catch (VisionException)
                {
                    // Restore our state to what it was before we set something.
                    UpdateData();
                    throw;
                }
            }
        }

        //==========================================================================================
        /// <summary>
        /// Copies the data from this class to another class.
        /// </summary>
        /// <param name="options">
        /// The TextureDefectClassifierOptions to copy data to.
        /// </param>

        public void CopyTo(TextureDefectClassifierOptions options)
        {
            if (options == null) { throw new ArgumentNullException("options"); }
            options._windowOptions = _windowOptions;
            options._waveletOptions = _waveletOptions;
            options._cooccurrenceOptions = _cooccurrenceOptions;
            options._bandsUsed = _bandsUsed;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified TextureDefectClassifierOptions.
        /// </summary>
        /// <param name="other">
        /// A TextureDefectClassifierOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(TextureDefectClassifierOptions other)
        {
            return other != null && _windowOptions.Equals(other._windowOptions) && _waveletOptions.Equals(other._waveletOptions) && _cooccurrenceOptions.Equals(other._cooccurrenceOptions) && _bandsUsed.Equals(other._bandsUsed);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified TextureDefectClassifierOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of TextureDefectClassifierOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            TextureDefectClassifierOptions other = (TextureDefectClassifierOptions)obj;
            return Equals(other);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _windowOptions.GetHashCode() ^ _waveletOptions.GetHashCode() ^ _cooccurrenceOptions.GetHashCode() ^ _bandsUsed.GetHashCode();
        }
        
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "TextureDefectClassifierOptions: " + _windowOptions.ToString() + ", " + _waveletOptions.ToString() + ", " + _cooccurrenceOptions.ToString();
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Provides information about a line.
    /// </summary>

    [Serializable]
    public sealed class LineProfileReport
    {
        private Collection<double> _profileData;
        private RectangleContour _boundingBox;
        private Range _pixelRange;
        private double _mean;
        private double _standardDeviation;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the standard deviation of the line profile. 
        /// </summary>

        public double StandardDeviation
        {
            get { return _standardDeviation; }
            set { _standardDeviation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the mean value of the pixels in the line profile. 
        /// </summary>

        public double Mean
        {
            get { return _mean; }
            set { _mean = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the smallest and largest pixel values in the line profile. 
        /// </summary>

        public Range PixelRange
        {
            get { return _pixelRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _pixelRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the bounding rectangle of the line. 
        /// </summary>

        public RectangleContour BoundingBox
        {
            get { return _boundingBox; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _boundingBox = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection containing the value of each pixel in the line. 
        /// </summary>

        public Collection<double> ProfileData
        {
            get { return _profileData; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_profileData = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineProfileReport class.
        /// </summary>

        public LineProfileReport()
        {
            _profileData = new Collection<double>();
            _pixelRange = new Range();
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineProfileReport.
        /// </summary>
        /// <param name="other">
        /// A LineProfileReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LineProfileReport other)
        {
            return other != null && Utilities.CollectionsEqual(_profileData, other._profileData) && _boundingBox.Equals(other._boundingBox) && _pixelRange.Equals(other._pixelRange) && _mean == other._mean && _standardDeviation == other._standardDeviation;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineProfileReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LineProfileReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LineProfileReport other = (LineProfileReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _profileData.Count.GetHashCode() ^ _boundingBox.GetHashCode() ^ _pixelRange.GetHashCode() ^ _mean.GetHashCode() ^ _standardDeviation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LineProfileReport: Mean=" + _mean.ToString(CultureInfo.CurrentCulture) + ", PixelRange=" + _pixelRange.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Represents image processing kernel data and properties that you can configure on a per kernel basis.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class Kernel
    {
        private int _rows;
        private int _cols;
        private double[] _entries;
        private double _divider;

        //==========================================================================================
        /// <summary>
        /// Creates and returns a Kernel object.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="width">The width of the kernel matrix.
        /// </param>
        /// <param name="height">The height of the kernel matrix.
        /// </param>

        public Kernel(int width, int height)
            : this(width, height, null)
        {
        }
        //==========================================================================================
        /// <summary>Creates and returns a Kernel object.
        /// </summary>
        /// <param name="width">The width of the kernel matrix.
        /// </param>
        /// <param name="height">The height of the kernel matrix.
        /// </param>
        /// <param name="entries"> The entries of the kernel.  This array must be width*height entries long.
        /// </param>

        public Kernel(int width, int height, double[] entries)
        {
            SetSize(width, height);
            if (entries != null)
            {
                // Make sure the array is the right size, and initialize.
                if (entries.Length != width * height)
                {
                    throw new VisionException(ErrorCode.ArraySizeMismatch);
                }
                Array.Copy(entries, _entries, width * height);
            }
        }
        //==========================================================================================
        /// <summary>
        /// Creates and returns a Kernel object.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="family"> The family of kernel to load.
        /// </param>
        /// <param name="size">The size of kernel to load.
        /// </param>
        /// <param name="number">The number of kernel to load.
        /// </param>

        public Kernel(KernelFamily family, int size, int number)
        {
            Load(family, size, number);
        }

        //==========================================================================================
        /// <summary>
        /// Loads a predefined matrix into the Kernel object.
        /// </summary>
        /// <param name="family"> The family of kernel to load.
        /// </param>
        /// <param name="size">The size of kernel to load.
        /// </param>
        /// <param name="number">The number of kernel to load.
        /// </param>

        public void Load(KernelFamily family, int size, int number)
        {
            IntPtr result = VisionDll.imaqGetKernel(family, size, number);
            Utilities.ThrowError(result);
            // Don't dispose the kernel because it points to static memory (per imaqGetKernel() documentation)
            float[] floatEntries = Utilities.ConvertIntPtrTo1DStructureArray<float>(result, size * size, false);
            _entries = Array.ConvertAll<float, double>(floatEntries, delegate(float f) { return f; });
            _rows = size;
            _cols = size;
            UpdateDivider();
        }

        //==========================================================================================
        /// <summary>
        /// Sets the width and height of the kernel matrix simultaneously.
        /// </summary>
        /// <param name="width">The new width of the kernel.
        /// </param>
        /// <param name="height">The new height of the kernel.
        /// </param>
        /// <remarks>
        /// This is a destructive operation. After setting the size, all elements of the kernel will have the value 0.
        /// </remarks>

        public void SetSize(int width, int height)
        {
            if (height <= 0 || width <= 0)
            {
                throw new VisionException(ErrorCode.InvalidKernelSize);
            }
            _rows = height;
            _cols = width;
            _entries = new double[_rows * _cols];
            _divider = 0;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the kernel entry at a particular location.
        /// </summary>
        /// <param name="row">
        ///  The row at which to get the entry.
        /// </param>
        /// <param name="column">The column at which to get the entry.
        /// </param>
        /// <returns>
        /// The kernel entry at that location.
        /// </returns>

        public double GetEntry(int row, int column)
        {
            if (row < 0 || row >= _rows) throw new ArgumentOutOfRangeException("row");
            if (column < 0 || column >= _cols) throw new ArgumentOutOfRangeException("column");
            return _entries[_cols * row + column];
        }
        //==========================================================================================
        /// <summary>
        /// Sets a kernel entry at a particular location.
        /// </summary>
        /// <param name="row"> The row at which to set the entry.
        /// </param>
        /// <param name="column"> The column at which to set the entry.
        /// </param>
        /// <param name="value"> The new kernel entry.
        /// </param>

        public void SetEntry(int row, int column, double value)
        {
            if (row < 0 || row >= _rows) throw new ArgumentOutOfRangeException("row");
            if (column < 0 || column >= _cols) throw new ArgumentOutOfRangeException("column");
            _entries[_cols * row + column] = value;
            UpdateDivider();
        }

        //==========================================================================================
        /// <summary>
        /// Gets the height of the kernel matrix.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// </remarks>

        public int Height
        {
            get { return _rows; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the width of the kernel matrix.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// </remarks>

        public int Width
        {
            get { return _cols; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the normalization factor applied to the sum of the obtained products. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// Under normal conditions, the divider is the sum of all matrix element values.
        /// </remarks>

        public double Divider
        {
            get { return _divider; }
            set { _divider = value; }
        }

private void UpdateDivider()
        {
            _divider = 0;
            foreach (double d in _entries) {
                _divider += d;
            }
            // If the divider is 0, it's going to be set to 1 in the DLL.  So let's do
            // that here for user clarity.
            if (_divider == 0) {
                _divider = 1;
            }
        }

internal float[] GetInternalEntries()
        {
            return Array.ConvertAll<double, float>(_entries, delegate(double d) { return (float)d; });
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Kernel.
        /// </summary>
        /// <param name="other">
        /// A Kernel instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(Kernel other)
        {
            return other != null && _rows == other._rows && _cols == other._cols && _divider == other._divider && Utilities.ArraysEqual(_entries, other._entries);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Kernel.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of Kernel and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            Kernel other = (Kernel)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rows.GetHashCode() ^ _cols.GetHashCode() ^ _divider.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "Kernel: Width=" + _cols.ToString(CultureInfo.CurrentCulture) + ", Height=" + _rows.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the structuring element applied to the image. 
    /// </summary>

    [Serializable]
    public sealed class StructuringElement
    {
        private int _rows;
        private int _cols;
        private int[] _entries;
        private StructuringElementShape _shape;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StructuringElement class.
        /// </summary>

        public StructuringElement()
            : this(3, 3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StructuringElement class.
        /// </summary>
        /// <param name="width">
        /// The width of the structuring element.
        /// </param>
        /// <param name="height">
        /// The height of the structuring element.
        /// </param>

        public StructuringElement(int width, int height)
            : this (width, height, null)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StructuringElement class.
        /// </summary>
        /// <param name="width">
        /// The width of the structuring element.
        /// </param>
        /// <param name="height">
        /// The height of the structuring element.
        /// </param>
        /// <param name="entries">
        /// The entries of the structuring element. This array must be <format type="italics">width</format>*<format type="italics">height</format> entries long. 
        /// </param>

        public StructuringElement(int width, int height, int[] entries)
        {
            SetSize(width, height);
            if (entries != null)
            {
                // Make sure the array is the right size, and initialize.
                if (entries.Length != width * height)
                {
                    throw new VisionException(ErrorCode.ArraySizeMismatch);
                }
                Array.Copy(entries, _entries, width * height);
            }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StructuringElement class.
        /// </summary>
        /// <param name="family">
        /// The family of structuring element to load.
        /// </param>
        /// <param name="size">
        /// The size of structuring element to load.
        /// </param>
        /// <param name="number">
        /// The number of kernel to load.
        /// </param>

        public StructuringElement(KernelFamily family, int size, int number)
        {
            Load(family, size, number);
        }

        //==========================================================================================
        /// <summary>
        /// Loads a predefined matrix into the Kernel object.
        /// </summary>
        /// <param name="family"> The family of kernel to load.
        /// </param>
        /// <param name="size">The size of kernel to load.
        /// </param>
        /// <param name="number">The number of kernel to load.
        /// </param>

        public void Load(KernelFamily family, int size, int number)
        {
            IntPtr result = VisionDll.imaqGetKernel(family, size, number);
            Utilities.ThrowError(result);
            // Don't dispose the kernel because it points to static memory (per imaqGetKernel() documentation)
            float[] floatEntries = Utilities.ConvertIntPtrTo1DStructureArray<float>(result, size * size, false);
            _entries = Array.ConvertAll<float, int>(floatEntries, delegate(float f) { return (int)f; });
            _rows = size;
            _cols = size;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the structuring element entry at a particular location.
        /// </summary>
        /// <param name="row">
        /// The row at which to get the entry.
        /// </param>
        /// <param name="column">
        /// The column at which to get the entry.
        /// </param>
        /// <returns>
        /// The structuring element entry at that location.
        /// </returns>

        public int GetEntry(int row, int column)
        {
            if (row < 0 || row >= _rows) throw new ArgumentOutOfRangeException("row");
            if (column < 0 || column >= _cols) throw new ArgumentOutOfRangeException("column");
            return _entries[_cols * row + column];
        }
        //==========================================================================================
        /// <summary>
        /// Sets a structuring element entry at a particular location.
        /// </summary>
        /// <param name="row"> The row at which to set the entry.
        /// </param>
        /// <param name="column"> The column at which to set the entry.
        /// </param>
        /// <param name="value"> The new structuring element entry.
        /// </param>

        public void SetEntry(int row, int column, int value)
        {
            if (row < 0 || row >= _rows) throw new ArgumentOutOfRangeException("row");
            if (column < 0 || column >= _cols) throw new ArgumentOutOfRangeException("column");
            _entries[_cols * row + column] = value;
        }

        
        internal int[] Entries
        {
            get { return _entries; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the height of the structuring element.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public int Height
        {
            get { return _rows; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the width of the structuring element.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public int Width
        {
            get { return _cols; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the shape of the structuring element.
        /// </summary>
        /// <value>
        /// The default is Square.
        /// </value>

        public StructuringElementShape Shape
        {
            get { return _shape; }
            set { _shape = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Sets the width and height of the structuring element simultaneously. 
        /// </summary>
        /// <param name="width">
        /// The new width of the structuring element.
        /// </param>
        /// <param name="height">
        /// The new height of the structuring element.
        /// </param>

        public void SetSize(int width, int height)
        {
            if (height <= 0 || width <= 0)
            {
                throw new VisionException(ErrorCode.InvalidKernelSize);
            }
            _rows = height;
            _cols = width;
            _entries = new int[_rows * _cols];
            // Initialize the entries to 1's.
            for (int i = 0; i < _rows * _cols; ++i)
            {
                _entries[i] = 1;
            }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StructuringElement.
        /// </summary>
        /// <param name="other">
        /// A StructuringElement instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(StructuringElement other)
        {
            return other != null && _rows == other._rows && _cols == other._cols && _shape == other._shape && Utilities.ArraysEqual(_entries, other._entries);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StructuringElement.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of StructuringElement and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            StructuringElement other = (StructuringElement)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rows.GetHashCode() ^ _cols.GetHashCode() ^ _shape.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "StructuringElement: Width=" + _cols.ToString(CultureInfo.CurrentCulture) + ", Height=" + _rows.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides parameters that specify the results of reading a barcode.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class BarcodeReport
    {
        private string _text;
        private char _outputChar1;
        private char _outputChar2;
        private double _confidenceLevel;
        private BarcodeTypes _barcodeType;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of barcode.
        /// </summary>
        /// <value>The default value is 0.
        /// </value>

        public BarcodeTypes BarcodeType
        {
            get { return _barcodeType; }
            set { _barcodeType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the quality measure of the decoded barcode ranging from 1 to 1000, where 1000 is the best.
        /// </summary>
        /// <value>The default value is 0.0.
        /// </value>

        public double ConfidenceLevel
        {
            get { return _confidenceLevel; }
            set { _confidenceLevel = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the contents of this character depending on the barcode type.
        /// </summary>
        /// <value>The default value is '\0'.
        /// </value>

        public char OutputChar2
        {
            get { return _outputChar2; }
            set { _outputChar2 = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the contents of this character depending on the barcode type.
        /// </summary>
        /// <value>The default value is '\0'.
        /// </value>

        public char OutputChar1
        {
            get { return _outputChar1; }
            set { _outputChar1 = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the string containing the decoded barcode data.
        /// </summary>
        /// <value>The default value is <see langword="null"/>. 
        /// </value>

        public string Text
        {
            get { return _text; }
            set { _text = value; }
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the BarcodeReport class.
        /// </summary>

        public BarcodeReport()
        {
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified BarcodeReport.
        /// </summary>
        /// <param name="other">
        /// A BarcodeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(BarcodeReport other)
        {
            return other != null && _text == other._text && _outputChar1 == other._outputChar1 && _outputChar2 == other._outputChar2 && _confidenceLevel == other._confidenceLevel && _barcodeType == other._barcodeType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object. 
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of BarcodeReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            BarcodeReport other = (BarcodeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _text.GetHashCode() ^ _outputChar1.GetHashCode() ^ _outputChar2.GetHashCode() ^ _confidenceLevel.GetHashCode() ^ _barcodeType.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "BarcodeReport: Text=" + _text + ", ConfidenceLevel=" + _confidenceLevel.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides advanced options for reading a barcode.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DataMatrixAdvancedOptions : IEquatable<DataMatrixAdvancedOptions>
    {
        private DataMatrixAdvancedProcessing _type;
        private double _value;

        public DataMatrixAdvancedOptions(DataMatrixAdvancedProcessing type, double value)
        {
            this._type = type;
            this._value = value;
        }
        
        public DataMatrixAdvancedProcessing Type
        {
            get { return _type; }
            set { _type = value; }
        }

        public double Value
        {
            get { return _value; }
            set { _value = value; }
        }

        public bool Equals(DataMatrixAdvancedOptions other)
        {
            return other != null && _type == other._type && _value == other._value;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DataMatrixAdvancedOptions other = (DataMatrixAdvancedOptions)obj;
            return Equals(other);
        }
        
        public override int GetHashCode()
        {
            return _type.GetHashCode() ^ _value.GetHashCode();
        }

    }
 
    //==============================================================================================
    /// <summary>
    /// Provides information about a PDF417 barcode.
    /// </summary>

    [Serializable]
    public sealed class Pdf417Report
    {
        private bool _binary;
        private byte[] _binaryData;
        private string _stringData;
        private Collection<PointContour> _corners;
        private UInt32 _errorsCorrected;
        private UInt32 _erasuresCorrected;
        private UInt32 _rows;
        private UInt32 _columns;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the Pdf417Report class.
        /// </summary>

        public Pdf417Report()
        {
            _corners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of columns in the barcode.
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of rows in the barcode.
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 Rows
        {
            get { return _rows; }
            set { _rows = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of erasures the method corrected when decoding the barcode.
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 ErasuresCorrected
        {
            get { return _erasuresCorrected; }
            set { _erasuresCorrected = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of errors the method corrected when decoding the barcode.
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 ErrorsCorrected
        {
            get { return _errorsCorrected; }
            set { _errorsCorrected = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the coordinates of the corners of the rectangle surrounding the barcode.
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the string containing the decoded barcode data.
        /// </summary>

        public string StringData
        {
            get { return _stringData; }
            set { _stringData = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the binary data containing the raw Pdf417 barcode data.
        /// </summary>
        /// <returns>
        /// </returns>

        public byte[] GetBinaryData()
        {
            return _binaryData;
        }
        //==========================================================================================
        /// <summary>
        /// Sets the binary data containing the raw Pdf417 barcode data.
        /// </summary>
        /// <param name="binaryData">
        /// The binary data to set.
        /// </param>

        public void SetBinaryData(byte[] binaryData)
        {
            _binaryData = binaryData;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the data in the barcode is binary. If <see langword="true"/>, the 
        /// data in the barcode is binary. If <see langword="false"/>, the data in the barcode is ASCII text.
        /// </summary>

        public bool Binary
        {
            get { return _binary; }
            set { _binary = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Pdf417Report.
        /// </summary>
        /// <param name="other">
        /// A Pdf417Report instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(Pdf417Report other)
        {
            return other != null && _binary == other._binary && _binaryData == other._binaryData && _stringData == other._stringData && Utilities.CollectionsEqual(_corners, other._corners) && _rows == other._rows && _columns == other._columns && _erasuresCorrected == other._erasuresCorrected && _errorsCorrected == other._errorsCorrected;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Pdf417Report.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of Pdf417Report
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            Pdf417Report other = (Pdf417Report)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _binary.GetHashCode() ^ _stringData.GetHashCode() ^ _errorsCorrected.GetHashCode() ^ _erasuresCorrected.GetHashCode() ^ _rows.GetHashCode() ^ _columns.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "Pdf417Report: StringData=" + ((_stringData != null) ? _stringData : "");
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the description options the method uses when searching for the QR code in the image. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class QRDescriptionOptions
    {
        private QRDimension _dimension;
        private QRPolarity _polarity;
        private QRMirrorMode _mirrorMode;
        private QRModelType _modelType;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDescriptionOptions class.
        /// </summary>

        public QRDescriptionOptions() : this (QRDimension.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDescriptionOptions class.
        /// </summary>
        /// <param name="dimension">
        /// The number of rows and columns that are populated for the QR code, measured in cells. 
        /// </param>

        public QRDescriptionOptions(QRDimension dimension) : this (dimension, QRPolarity.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDescriptionOptions class.
        /// </summary>
        /// <param name="dimension">
        /// The number of rows and columns that are populated for the QR code, measured in cells. 
        /// </param>
        /// <param name="polarity">
        /// The data-to-background contrast for the QR code.
        /// </param>

        public QRDescriptionOptions(QRDimension dimension, QRPolarity polarity) : this (dimension, polarity, QRMirrorMode.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDescriptionOptions class.
        /// </summary>
        /// <param name="dimension">
        /// The number of rows and columns that are populated for the QR code, measured in cells. 
        /// </param>
        /// <param name="polarity">
        /// The data-to-background contrast for the QR code.
        /// </param>
        /// <param name="mirror">
        /// Specifies if the QR code appears mirrored in the image.
        /// </param>

        public QRDescriptionOptions(QRDimension dimension, QRPolarity polarity, QRMirrorMode mirror) : this (dimension, polarity, mirror, QRModelType.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDescriptionOptions class.
        /// </summary>
        /// <param name="dimension">
        /// The number of rows and columns that are populated for the QR code, measured in cells. 
        /// </param>
        /// <param name="polarity">
        /// The data-to-background contrast for the QR code.
        /// </param>
        /// <param name="mirror">
        /// Specifies if the QR code appears mirrored in the image.
        /// </param>
        /// <param name="modelType">
        /// The type of QR code. Micro QR codes have only one target in the top left. Model 1 codes have alignment "dashes" along the bottom and right side of the symbol. 
        /// </param>

        public QRDescriptionOptions(QRDimension dimension, QRPolarity polarity, QRMirrorMode mirror, QRModelType modelType)
        {
            _dimension = dimension;
            _polarity = polarity;
            _mirrorMode = mirror;
            _modelType = modelType;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of QR code. Micro QR codes have only one target in the top left. 
        /// Model 1 QR codes have alignment dashes along the bottom and right side of the code. Most 
        /// QR codes are Model 2. 
        /// </summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRModelType ModelType
        {
            get { return _modelType; }
            set { _modelType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the QR code appears mirrored in the image.</summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRMirrorMode MirrorMode
        {
            get { return _mirrorMode; }
            set { _mirrorMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the data-to-background contrast for the QR code.
        /// </summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRPolarity Polarity
        {
            get { return _polarity; }
            set { _polarity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of rows and columns that are populated for the QR code, measured in cells. 
        /// </summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRDimension Dimensions
        {
            get { return _dimension; }
            set { _dimension = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRDescriptionOptions.
        /// </summary>
        /// <param name="other">
        /// A QRDescriptionOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QRDescriptionOptions other)
        {
            return other != null && _dimension == other._dimension && _polarity == other._polarity && _mirrorMode == other._mirrorMode && _modelType == other._modelType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRDescriptionOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QRDescriptionOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QRDescriptionOptions other = (QRDescriptionOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _dimension.GetHashCode() ^ _polarity.GetHashCode() ^ _mirrorMode.GetHashCode() ^ _modelType.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QRDescriptionOptions: Dimensions=" + _dimension.ToString() + ", Polarity=" + _polarity.ToString() + ", MirrorMode=" + _mirrorMode.ToString() + ", ModelType=" + _modelType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains the size options the method uses when searching for a QR code in the image. 
    /// </summary>

    [Serializable]
    public sealed class QRSizeOptions
    {
        private UInt32 _minSize;
        private UInt32 _maxSize;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum size (in pixels) of the cells in a QR code.
        /// </summary>
        /// <value>
        /// The default is 7.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 MaximumSize
        {
            get { return _maxSize; }
            set { _maxSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum size (in pixels) of the cells in a QR code.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 MinimumSize
        {
            get { return _minSize; }
            set { _minSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSizeOptions class.
        /// </summary>

        public QRSizeOptions()
            : this(3, 7)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSizeOptions class.
        /// </summary>
        /// <param name="minimumSize">
        /// Specifies the minimum size (in pixels) of the cells in a QR code. The default is 3.
        /// </param>
        /// <param name="maximumSize">
        /// Specifies the maximum size (in pixels) of the cells in a QR code. The default is 7.
        /// </param>

        [CLSCompliant(false)]
        public QRSizeOptions(UInt32 minimumSize, UInt32 maximumSize)
        {
            _minSize = minimumSize;
            _maxSize = maximumSize;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRSizeOptions.
        /// </summary>
        /// <param name="other">
        /// A QRSizeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QRSizeOptions other)
        {
            return other != null && _minSize == other._minSize && _maxSize == other._maxSize;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRSizeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QRSizeOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QRSizeOptions other = (QRSizeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _minSize.GetHashCode() ^ _maxSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QRSizeOptions: MinimumSize=" + _minSize + ", MaximumSize=" + _maxSize;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the search options the method uses when searching for the QR code in the image. 
    /// </summary>

    [Serializable]
    public sealed class QRSearchOptions {
        private QRRotationMode _rotationMode;
        private bool _skipLocation;
        private UInt32 _edgeThreshold;
        private QRDemodulationMode _demodulationMode;
        private QRCellSampleSize _cellSampleSize;
        private QRCellFilterMode _cellFilterMode;
        private UInt32 _skewDegreesAllowed;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSearchOptions class.
        /// </summary>

        public QRSearchOptions()
            : this(QRRotationMode.Unlimited)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSearchOptions class.
        /// </summary>
        /// <param name="rotationMode">
        /// Specifies the amount of QR code rotation the function should allow for.
        /// </param>

        public QRSearchOptions(QRRotationMode rotationMode)
            : this(rotationMode, QRDemodulationMode.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSearchOptions class.
        /// </summary>
        /// <param name="rotationMode">
        /// Specifies the amount of QR code rotation the function should allow for.
        /// </param>
        /// <param name="demodulationMode">
        /// Specifies the mode the method should use to demodulate (determine which cells are on 
        /// and which cells are off) the QR code. 
        /// </param>

        public QRSearchOptions(QRRotationMode rotationMode, QRDemodulationMode demodulationMode)
            : this(rotationMode, demodulationMode, QRCellSampleSize.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSearchOptions class.
        /// </summary>
        /// <param name="rotationMode">
        /// Specifies the amount of QR code rotation the method should allow for.
        /// </param>
        /// <param name="demodulationMode">
        /// Specifies the mode the method should use to demodulate (determine which cells are on 
        /// and which cells are off) the QR code. 
        /// </param>
        /// <param name="cellSampleSize">
        /// Specifies the sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </param>

        public QRSearchOptions(QRRotationMode rotationMode, QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize)
            : this(rotationMode, demodulationMode, cellSampleSize, QRCellFilterMode.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRSearchOptions class.
        /// </summary>
        /// <param name="rotationMode">
        /// Specifies the amount of QR code rotation the method should allow for.
        /// </param>
        /// <param name="demodulationMode">
        /// Specifies the mode the method should use to demodulate (determine which cells are on 
        /// and which cells are off) the QR code. 
        /// </param>
        /// <param name="cellSampleSize">
        /// Specifies the sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </param>
        /// <param name="cellFilterMode">
        /// Specifies the mode the method uses to determine the pixel value for each cell.
        /// </param>

        public QRSearchOptions(QRRotationMode rotationMode, QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize, QRCellFilterMode cellFilterMode)
        {
            _rotationMode = rotationMode;
            _demodulationMode = demodulationMode;
            _cellSampleSize = cellSampleSize;
            _cellFilterMode = cellFilterMode;
            _skipLocation = false;
            _edgeThreshold = 30;
            _skewDegreesAllowed = 5;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the amount, in degrees, of skew in the QR code the method should allow for.
        /// </summary>
        /// <value>
        /// The default is 5.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 SkewDegreesAllowed
        {
            get { return _skewDegreesAllowed; }
            set { _skewDegreesAllowed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the mode the method uses to determine the pixel value for each cell.
        /// </summary>
        /// <value>
        ///  The default value is AutoDetect.
        /// </value>
        /// <remarks>
        /// If CellSampleSize is Size1x1, the value of the single sampled pixel always determines 
        /// the pixel value for the cell and the method ignores this property.
        /// </remarks>

        public QRCellFilterMode CellFilterMode
        {
            get { return _cellFilterMode; }
            set { _cellFilterMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRCellSampleSize CellSampleSize
        {
            get { return _cellSampleSize; }
            set { _cellSampleSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the mode the method should use to demodulate (determine which cells are on and which cells are off) the QR code. 
        /// </summary>
        /// <value>
        /// The default is AutoDetect.
        /// </value>

        public QRDemodulationMode DemodulationMode
        {
            get { return _demodulationMode; }
            set { _demodulationMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast a pixel must have in order to be considered part of a QR code cell edge.
        /// </summary>
        /// <value>
        /// The default 
        /// value is 30.
        /// </value>
        /// <remarks>
        /// The lower this value, the more potential edge candidates the method will examine during the location phase. 
        /// Setting this value too low will decrease the performance of the method because the method will examine too 
        /// many potential edge candidates. Setting this value too high may also decrease the performance of the method 
        /// by removing valid edge candidates, making location require more iterations. Setting this value too high may 
        /// also cause the method to fail to identify the QR code because all edge candidates are eliminated.
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 EdgeThreshold
        {
            get { return _edgeThreshold; }
            set { _edgeThreshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets if the method should locate the code. If <see langword="true"/>, specifies that the 
        /// method should assume that the QR code occupies the entire image (or the entire 
        /// search region). The method then skips the location phase, moving immediately to 
        /// extraction and decoding. If <see langword="false"/>, the method does not make any assumptions about 
        /// the percentage of the image occupied by the QR code.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SkipLocation
        {
            get { return _skipLocation; }
            set { _skipLocation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the amount of QR code rotation the method should allow for.
        /// </summary>
        /// <value>
        /// The default is Unlimited.
        /// </value>

        public QRRotationMode RotationMode
        {
            get { return _rotationMode; }
            set { _rotationMode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRSearchOptions.
        /// </summary>
        /// <param name="other">
        /// A QRSearchOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QRSearchOptions other)
        {
            return other != null && _rotationMode == other._rotationMode && _skipLocation == other._skipLocation && _edgeThreshold == other._edgeThreshold && _demodulationMode == other._demodulationMode && _cellSampleSize == other._cellSampleSize && _cellFilterMode == other._cellFilterMode && _skewDegreesAllowed == other._skewDegreesAllowed;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRSearchOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QRSearchOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QRSearchOptions other = (QRSearchOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rotationMode.GetHashCode() ^ _skipLocation.GetHashCode() ^ _edgeThreshold.GetHashCode() ^ _demodulationMode.GetHashCode() ^ _cellSampleSize.GetHashCode() ^ _cellFilterMode.GetHashCode() ^ _skewDegreesAllowed.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QRSearchOptions: RotationMode=" + _rotationMode.ToString() + ", DemodulationMode=" + _demodulationMode.ToString() + ", CellSampleSize=" + _cellSampleSize.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains contains the data tokenized in exactly the way it was encoded in the QR code. This is useful if the symbol is encoded using multiple languages. 
    /// </summary>

    [Serializable]
    public sealed class QRDataToken
    {
        private QRStreamMode _mode;
        private UInt32 _modeData;
        private byte[] _data;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRDataToken class.
        /// </summary>

        public QRDataToken()
        {
        }
        //==========================================================================================
        /// <summary>
        /// Gets the encoded data in the QR code.
        /// </summary>
        /// <returns>
        /// The data encoded in the QR code.
        /// </returns>

        public byte[] GetData()
        {
            return _data;
        }
        //==========================================================================================
        /// <summary>
        /// Sets the encoded data in the QR code.
        /// </summary>
        /// <param name="data">
        /// The encoded data in the QR code.
        /// </param>

        public void SetData(byte[] data)
        {
            _data = data;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets specifiers used by the user to postprocess the data if it requires it. 
        /// Typically this represents size, but sometimes represents the language for ECI Stream Mode, and 
        /// Application ID for EAN-128 codes. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 ModeData
        {
            get { return _modeData; }
            set { _modeData = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the stream mode or the format of the data that is encoded in the QR code. 
        /// </summary>

        public QRStreamMode Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRDataToken.
        /// </summary>
        /// <param name="other">
        /// A QRDataToken instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QRDataToken other)
        {
            return other != null && _mode == other._mode && _modeData == other._modeData && Utilities.ArraysEqual(_data, other._data);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRDataToken.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QRDataToken
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QRDataToken other = (QRDataToken)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _mode.GetHashCode() ^ _modeData.GetHashCode() ^ _data.Length.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QRDataToken: Mode=" + _mode.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the QR code that the method read. 
    /// </summary>

    [Serializable]
    public sealed class QRReport
    {
        private bool _found;
        private byte[] _data;
        private Collection<PointContour> _corners;
        private Collection<QRDataToken> _tokenizedData;
        private UInt32 _errorsCorrected;
        private UInt32 _dimensions;
        private UInt32 _version;
        private QRModelType _modelType;
        private QRStreamMode _streamMode;
        private QRPolarity _matrixPolarity;
        private bool _mirrored;
        private UInt32 _appendStreamPosition;
        private UInt32 _appendStreamSize;
        private Int32 _firstEan128ApplicationId;
        private Int32 _firstEciDesignator;
        private UInt32 _appendStreamIdentifier;
        private UInt32 _minimumEdgeStrength;
        private QRDemodulationMode _demodulationMode;
        private QRCellSampleSize _cellSampleSize;
        private QRCellFilterMode _cellFilterMode;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QRReport class.
        /// </summary>

        public QRReport() {
            _corners = new Collection<PointContour>();
            _tokenizedData = new Collection<QRDataToken>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the cell filter mode the method used to locate the QR code.
        /// </summary>

        public QRCellFilterMode CellFilterMode
        {
            get { return _cellFilterMode; }
            set { _cellFilterMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the cell sample size the method used to locate the QR code.
        /// </summary>

        public QRCellSampleSize CellSampleSize
        {
            get { return _cellSampleSize; }
            set { _cellSampleSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the demodulation mode the function used to locate the QR code.
        /// </summary>

        public QRDemodulationMode DemodulationMode
        {
            get { return _demodulationMode; }
            set { _demodulationMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the strength of the weakest edge the method used to find the coarse location of the QR code in the image.
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 MinimumEdgeStrength
        {
            get { return _minimumEdgeStrength; }
            set { _minimumEdgeStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets what stream the QR code is in relation to when the code is part of a larger array of codes. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 AppendStreamIdentifier
        {
            get { return _appendStreamIdentifier; }
            set { _appendStreamIdentifier = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the first alternate language designator for ECI codes.
        /// </summary>

        public Int32 FirstEciDesignator
        {
            get { return _firstEciDesignator; }
            set { _firstEciDesignator = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the first application ID for EAN-128 codes.
        /// </summary>

        public Int32 FirstEan128ApplicationId
        {
            get { return _firstEan128ApplicationId; }
            set { _firstEan128ApplicationId = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how many QR codes are part of a larger array of codes. 
        /// Sometimes a QR code is part of a larger array of codes. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 AppendStreamSize
        {
            get { return _appendStreamSize; }
            set { _appendStreamSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets what position the QR code is in with respect to the stream of data in all codes. 
        /// It is possible for a QR code to be part of a larger array of codes. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 AppendStreamPosition
        {
            get { return _appendStreamPosition; }
            set { _appendStreamPosition = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the QR code appears mirrored in the image. If <see langword="true"/>, 
        /// the QR code appears mirrored in the image. If <see langword="false"/>, the QR code appears 
        /// normally in the image.
        /// </summary>

        public bool Mirrored
        {
            get { return _mirrored; }
            set { _mirrored = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the polarity of the QR code.
        /// </summary>

        public QRPolarity MatrixPolarity
        {
            get { return _matrixPolarity; }
            set { _matrixPolarity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the format of the data encoded in the stream. 
        /// </summary>

        public QRStreamMode StreamMode
        {
            get { return _streamMode; }
            set { _streamMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of the QR code.
        /// </summary>

        public QRModelType ModelType
        {
            get { return _modelType; }
            set { _modelType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the version of the QR code. The version indicates how much information can be 
        /// encoded and how much redundancy is included inside the code. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 Version
        {
            get { return _version; }
            set { _version = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of rows and columns that are populated for the QR code, measured in cells. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 Dimensions
        {
            get { return _dimensions; }
            set { _dimensions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of errors the function corrected when decoding the QR code. 
        /// </summary>

        [CLSCompliant(false)]
        public UInt32 ErrorsCorrected
        {
            get { return _errorsCorrected; }
            set { _errorsCorrected = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the data tokenized in exactly the way it was encoded in the code. 
        /// This is useful if the code is encoded using multiple languages. 
        /// </summary>

        public Collection<QRDataToken> TokenizedData
        {
            get { return _tokenizedData; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_tokenizedData = value;  }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the corners of the rectangle surrounding the QR code.
        /// </summary>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets the raw data encoded in the QR code.
        /// </summary>
        /// <returns>
        /// The raw data encoded in the QR code.
        /// </returns>

        public byte[] GetData()
        {
            return _data;
        }
        //==========================================================================================
        /// <summary>
        /// Sets the raw data encoded in the QR code.
        /// </summary>
        /// <param name="data">
        /// The raw data encoded in the QR code.
        /// </param>

        public void SetData(byte[] data)
        {
            _data = data;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method located and decoded a QR code. If <see langword="true"/>, 
        /// the method located and decoded a QR code. If <see langword="false"/>, the method failed to 
        /// locate and decode a QR code.
        /// </summary>

        public bool Found
        {
            get { return _found; }
            set { _found = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRReport.
        /// </summary>
        /// <param name="other">
        /// A QRReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QRReport other)
        {
            return other != null && _found == other._found && Utilities.ArraysEqual(_data, other._data) && Utilities.CollectionsEqual(_corners, other._corners) && Utilities.CollectionsEqual(_tokenizedData, other._tokenizedData) && _errorsCorrected == other._errorsCorrected && _dimensions == other._dimensions && _version == other._version && _modelType == other._modelType && _streamMode == other._streamMode && _matrixPolarity == other._matrixPolarity && _mirrored == other._mirrored && _appendStreamPosition == other._appendStreamPosition && _appendStreamSize == other._appendStreamSize && _firstEan128ApplicationId == other._firstEan128ApplicationId && _firstEciDesignator == other._firstEciDesignator && _appendStreamIdentifier == other._appendStreamIdentifier && _minimumEdgeStrength == other._minimumEdgeStrength && _demodulationMode == other._demodulationMode && _cellSampleSize == other._cellSampleSize && _cellFilterMode == other._cellFilterMode;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QRReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QRReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QRReport other = (QRReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _found.GetHashCode() ^ _data.Length.GetHashCode() ^ _corners.Count.GetHashCode() ^ _tokenizedData.Count.GetHashCode() ^ _errorsCorrected.GetHashCode() ^ _dimensions.GetHashCode() ^ _version.GetHashCode() ^ _modelType.GetHashCode() ^ _streamMode.GetHashCode() ^ _matrixPolarity.GetHashCode() ^ _mirrored.GetHashCode() ^ _appendStreamPosition.GetHashCode() ^ _appendStreamSize.GetHashCode() ^ _firstEan128ApplicationId.GetHashCode() ^ _firstEciDesignator.GetHashCode() ^ _appendStreamIdentifier.GetHashCode() ^ _minimumEdgeStrength.GetHashCode() ^ _demodulationMode.GetHashCode() ^ _cellSampleSize.GetHashCode() ^ _cellFilterMode.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QRReport: Found=" + _found.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the description options the function uses when searching for the Data Matrix barcode in the image. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DataMatrixDescriptionOptions
    {
        private double _aspectRatio;
        private UInt32 _rows;
        private UInt32 _columns;
        private bool _rectangle;
        private DataMatrixEcc _ecc;
        private DataMatrixPolarity _polarity;
        private DataMatrixCellFillMode _cellFill;
        private double _minimumBorderIntegrity;
        private DataMatrixMirrorMode _mirrorMode;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixDescriptionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public DataMatrixDescriptionOptions() : this(0,0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixDescriptionOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="rows">The number of rows in the Data Matrix barcode.
        /// </param>
        /// <param name="columns">The number of columns in the Data Matrix barcode.
        /// </param>

        [CLSCompliant(false)]
        public DataMatrixDescriptionOptions(UInt32 rows, UInt32 columns)
        {
            _rows = rows;
            _columns = columns;
            _aspectRatio = 0;
            _rectangle = false;
            _ecc = DataMatrixEcc.AutoDetect;
            _polarity = DataMatrixPolarity.AutoDetect;
            _cellFill = DataMatrixCellFillMode.AutoDetect;
            _minimumBorderIntegrity = 80;
            _mirrorMode = DataMatrixMirrorMode.AutoDetect;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the Data Matrix barcode appears normally in the image or if the barcode appears mirrored in the image.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.Analysis.DataMatrixMirrorMode.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixMirrorMode.AutoDetect" crefType="Unqualified"/>The method should determine if the Data Matrix barcode is mirrored.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixMirrorMode.Mirrored" crefType="Unqualified"/>The method should expect the Data Matrix barcode to appear mirrored.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixMirrorMode.Normal" crefType="Unqualified"/>-The method should expect the Data Matrix barcode to appear normal.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixMirrorMode MirrorMode
        {
            get { return _mirrorMode; }
            set { _mirrorMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum percentage of the border (locator pattern and timing pattern) the method should expect in the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default is 80.0.
        /// </value>
        /// <remarks>
        /// During the location phase, the method will ignore possible Data Matrix barcode candidates that do not have at least this level of border integrity.
        /// </remarks>

        public double MinimumBorderIntegrity
        {
            get { return _minimumBorderIntegrity; }
            set { _minimumBorderIntegrity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the fill percentage for a cell of the Data Matrix barcode that is in the "on" state.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFillMode.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFillMode.AutoDetect" crefType="Unqualified"/>The method determines the Data Matrix barcode cell fill percentage automatically.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFillMode.Low" crefType="Unqualified"/>The method reads Data Matrix barcodes with a cell fill percentage of less than 30 percent.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFillMode.Normal" crefType="Unqualified"/>The method reads Data Matrix barcodes with a cell fill percentage greater than or equal to 30 percent.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixCellFillMode CellFill
        {
            get { return _cellFill; }
            set { _cellFill = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the data-to-background contrast for the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.Analysis.DataMatrixPolarity.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixPolarity.AutoDetect" crefType="Unqualified"/>The method should determine the polarity of the Data Matrix barcode.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixPolarity.BlackDataOnWhiteBackground" crefType="Unqualified"/>-The method should search for a Data Matrix barcode with dark data on a bright background.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixPolarity.WhiteDataOnBlackBackground" crefType="Unqualified"/>The method should search for a Data Matrix barcode with bright data on a dark background.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixPolarity Polarity
        {
            get { return _polarity; }
            set { _polarity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the ECC used for this Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.AutoDetect" crefType="PartiallyQualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc000" crefType="PartiallyQualified"/>Sets the method to read Data Matrix barcodes of ECC 000 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc000To140" crefType="PartiallyQualified"/>-Sets the method to read Data Matrix barcodes of ECC 000, ECC 050, ECC 080, ECC 100, and ECC 140 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc050" crefType="PartiallyQualified"/>-Sets the method to read Data Matrix barcodes of ECC 050 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc080" crefType="PartiallyQualified"/>-Sets the method to read Data Matrix barcodes of ECC 080 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc100" crefType="PartiallyQualified"/>Sets the method to read Data Matrix barcodes of ECC 100 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc140" crefType="PartiallyQualified"/>-Sets the method to read Data Matrix barcodes of ECC 140 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc200" crefType="PartiallyQualified"/>-Sets the method to read Data Matrix barcodes of ECC 200 only. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.AutoDetect" crefType="PartiallyQualified"/>The method determines the barcode ECC automatically. 
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixEcc Ecc
        {
            get { return _ecc; }
            set { _ecc = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the Data Matrix barcode is rectangular.
        /// </summary>
        /// <value>
        /// If this element is <see langword="true"/>, the method will look for Data Matrix barcodes of all shapes.  If this element is <see langword="false"/>, the method will only look for 
        /// Data Matrix barcodes that are square. The default is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If both Rows and Columns are non-zero, the method will ignore this property.
        /// </remarks>

        public bool Rectangle
        {
            get { return _rectangle; }
            set { _rectangle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of columns in the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default is 0, which specifies that the method should determine the number of columns.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of rows in the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default is 0, which specifies that the method should determine the number of rows.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 Rows
        {
            get { return _rows; }
            set { _rows = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Gets or sets the ratio of the width of a Data Matrix barcode cell (in pixels) divided by the height of a Data Matrix barcode cell (in pixels).
        /// </summary>
        /// <value>
        /// The default is 0.0, which specifies that the method should determine the aspect ratio.
        /// </value>

        public double AspectRatio
        {
            get { return _aspectRatio; }
            set { _aspectRatio = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixDescriptionOptions.
        /// </summary>
        /// <param name="other">
        /// A DataMatrixDescriptionOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DataMatrixDescriptionOptions other)
        {
            return other != null && _aspectRatio == other._aspectRatio && _rows == other._rows && _columns == other._columns && _rectangle == other._rectangle && _ecc == other._ecc && _polarity == other._polarity && _cellFill == other._cellFill && _minimumBorderIntegrity == other._minimumBorderIntegrity && _mirrorMode == other._mirrorMode;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixDescriptionOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DataMatrixDescriptionOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DataMatrixDescriptionOptions other = (DataMatrixDescriptionOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _aspectRatio.GetHashCode() ^ _rows.GetHashCode() ^ _columns.GetHashCode() ^ _rectangle.GetHashCode() ^ _ecc.GetHashCode() ^ _polarity.GetHashCode() ^ _cellFill.GetHashCode() ^ _minimumBorderIntegrity.GetHashCode() ^ _mirrorMode.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DataMatrixDescriptionOptions: AspectRatio=" + _aspectRatio.ToString(CultureInfo.CurrentCulture) + ", Columns=" + _columns.ToString(CultureInfo.CurrentCulture) + ", Rows=" + _rows.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the size options the method uses when searching for a Data Matrix barcode in the image. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DataMatrixSizeOptions
    {
        private UInt32 _minimumSize;
        private UInt32 _maximumSize;
        private UInt32 _quietZoneWidth;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSizeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public DataMatrixSizeOptions()
            : this(0, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSizeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="minimumSize">The minimum size in pixels of the Data Matrix barcode in the image. 
        /// </param>
        /// <param name="maximumSize">The maximum size in pixels of the Data Matrix barcode in the image.
        /// </param>

        [CLSCompliant(false)]
        public DataMatrixSizeOptions(UInt32 minimumSize, UInt32 maximumSize)
            : this(minimumSize, maximumSize, 10)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSizeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="minimumSize">The minimum size in pixels of the Data Matrix barcode in the image. 
        /// </param>
        /// <param name="maximumSize">The maximum size in pixels of the Data Matrix barcode in the image.
        /// </param>
        /// <param name="quietZoneWidth">The expected minimum size of the quiet zone, in pixels. 
        /// </param>

        [CLSCompliant(false)]
        public DataMatrixSizeOptions(UInt32 minimumSize, UInt32 maximumSize, UInt32 quietZoneWidth)
        {
            _minimumSize = minimumSize;
            _maximumSize = maximumSize;
            _quietZoneWidth = quietZoneWidth;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the expected minimum size of the quiet zone, in pixels. 
        /// </summary>
        /// <value>
        /// The default value is 10.
        /// </value>
        /// <remarks>
        /// The function ignores Data Matrix barcode candidates that have quiet zones smaller than this value. 
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 QuietZoneWidth
        {
            get { return _quietZoneWidth; }
            set { _quietZoneWidth = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum size in pixels of the Data Matrix barcode in the image.
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>
        /// <remarks>
        /// The default is 0, which specifies that the method should never exclude a Data Matrix barcode candidate because it is too large.
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 MaximumSize
        {
            get { return _maximumSize; }
            set { _maximumSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum size in pixels of the Data Matrix barcode in the image. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>
        /// <remarks>
        /// The default is 0, which specifies that the method should never exclude a Data Matrix barcode candidate because it is too small.
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 MinimumSize
        {
            get { return _minimumSize; }
            set { _minimumSize = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixSizeOptions.
        /// </summary>
        /// <param name="other">
        /// A DataMatrixSizeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DataMatrixSizeOptions other)
        {
            return other != null && _minimumSize == other._minimumSize && _maximumSize == other._maximumSize && _quietZoneWidth == other._quietZoneWidth;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixSizeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DataMatrixSizeOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DataMatrixSizeOptions other = (DataMatrixSizeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _minimumSize.GetHashCode() ^ _maximumSize.GetHashCode() ^ _quietZoneWidth.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DataMatrixSizeOptions: MinimumSize=" + _minimumSize.ToString(CultureInfo.CurrentCulture) + ", MaximumSize=" + _maximumSize.ToString(CultureInfo.CurrentCulture) + ", QuietZoneWidth=" + _quietZoneWidth.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the search options the method uses when searching for the Data Matrix barcode in the image. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DataMatrixSearchOptions
    {
        private DataMatrixRotationMode _rotationMode;
        private bool _skipLocation;
        private UInt32 _edgeThreshold;
        private DataMatrixDemodulationMode _demodulationMode;
        private DataMatrixCellSampleSize _cellSampleSize;
        private DataMatrixCellFilterMode _cellFilterMode;
        private UInt32 _skewDegreesAllowed;
        private UInt32 _maximumIterations;
        private UInt32 _initialSearchVectorWidth;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSearchOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public DataMatrixSearchOptions()
            : this(DataMatrixRotationMode.Unlimited)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSearchOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="rotationMode">The amount of Data Matrix barcode rotation the function should allow for.
        /// </param>

        public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode)
            : this(rotationMode, DataMatrixDemodulationMode.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSearchOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="rotationMode">The amount of Data Matrix barcode rotation the function should allow for.
        /// </param>
        /// <param name="demodulationMode">The mode the method should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode. 
        /// </param>

        public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode, DataMatrixDemodulationMode demodulationMode)
            : this(rotationMode, demodulationMode, DataMatrixCellSampleSize.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSearchOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="rotationMode">The amount of Data Matrix barcode rotation the function should allow for.
        /// </param>
        /// <param name="demodulationMode">The mode the method should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode. 
        /// </param>
        /// <param name="cellSampleSize">The sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </param>

        public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode, DataMatrixDemodulationMode demodulationMode, DataMatrixCellSampleSize cellSampleSize)
            : this(rotationMode, demodulationMode, cellSampleSize, DataMatrixCellFilterMode.AutoDetect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixSearchOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="rotationMode">The amount of Data Matrix barcode rotation the function should allow for.
        /// </param>
        /// <param name="demodulationMode">The mode the method should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode. 
        /// </param>
        /// <param name="cellSampleSize">The sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </param>
        /// <param name="cellFilterMode">The the mode the method uses to determine the pixel value for each cell.
        /// </param>

        public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode, DataMatrixDemodulationMode demodulationMode, DataMatrixCellSampleSize cellSampleSize, DataMatrixCellFilterMode cellFilterMode)
        {
            _rotationMode = rotationMode;
            _demodulationMode = demodulationMode;
            _cellSampleSize = cellSampleSize;
            _cellFilterMode = cellFilterMode;
            _skipLocation = false;
            _edgeThreshold = 30;
            _skewDegreesAllowed = 5;
            _maximumIterations = 500;
            _initialSearchVectorWidth = 5;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of pixels the method should average together to determine the location of an edge.
        /// </summary>
        /// <value>
        /// The default value is 5.
        /// </value>
        /// <remarks>
        /// You may need to increase this value when the Data Matrix barcode has cells with a low fill percentage. 
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 InitialSearchVectorWidth
        {
            get { return _initialSearchVectorWidth; }
            set { _initialSearchVectorWidth = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum number of iterations before the method stops looking for the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// The default value is 500.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 MaximumIterations
        {
            get { return _maximumIterations; }
            set { _maximumIterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the amount of skew in the Data Matrix barcode that the method should allow for.
        /// </summary>
        /// <value>
        /// The default value is 5.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 SkewDegreesAllowed
        {
            get { return _skewDegreesAllowed; }
            set { _skewDegreesAllowed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the the mode the method uses to determine the pixel value for each cell.
        /// </summary>
        /// <value>
        /// The default value is <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.All" crefType="Unqualified"/>The method tries each filter mode, starting with cwimaqDataMatrixCellFilterModeAverage and ending with cwimaqDataMatrixCellFilterModeVeryLowAverage, stopping once a filter mode decodes correctly.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.AutoDetect" crefType="Unqualified"/>The method will try all filter modes and uses the one that decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.Average" crefType="Unqualified"/>The method sets the pixel value for the cell to the average of the sampled pixels. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.CentralAverage" crefType="Unqualified"/>The method sets the pixel value for the cell to the average of the pixels in the center of the cell sample. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.HighAverage" crefType="Unqualified"/>The method sets the pixel value for the cell to the average value of the half of the sampled pixels with the highest pixel values. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.LowAverage" crefType="Unqualified"/>The method sets the pixel value for the cell to the average value of the half of the sampled pixels with the lowest pixel values.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.Median" crefType="Unqualified"/>The method sets the pixel value for the cell to the median of the sampled pixels. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.VeryHighAverage" crefType="Unqualified"/>The method sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.VeryLowAverage" crefType="Unqualified"/>The method sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the lowest pixel values.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// 	<note type="note">
        /// If CellSampleSize is <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size1x1" crefType="Unqualified"/>, the value of the single sampled pixel always determines the pixel value for the cell and the method ignores this property. 
        /// </note>
        /// </remarks>

        public DataMatrixCellFilterMode CellFilterMode
        {
            get { return _cellFilterMode; }
            set { _cellFilterMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the sample size, in pixels, the method should take to determine if each cell is on or off.
        /// </summary>
        /// <value>
        /// The default value is <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size1x1" crefType="Unqualified"/>The method will use a 11 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size2x2" crefType="Unqualified"/>The method will use a 22 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size3x3" crefType="Unqualified"/>The method will use a 33 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size4x4" crefType="Unqualified"/>The method will use a 44 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size5x5" crefType="Unqualified"/>The method will use a 55 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size6x6" crefType="Unqualified"/>The method will use a 66 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.Size7x7" crefType="Unqualified"/>The method will use a 77 sized sample from each cell.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.AutoDetect" crefType="Unqualified"/>The method will try each sample size and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixCellSampleSize CellSampleSize
        {
            get { return _cellSampleSize; }
            set { _cellSampleSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the mode the method should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode. 
        /// </summary>
        /// <value>
        /// The default value is <see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.AutoDetect" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.All" crefType="Unqualified"/>The method tries DataMatrixDemodulationModeHistogram, then DataMatrixDemodulationModeLocalContrast and then DataMatrixDemodulationModeCombined, stopping once one mode is successful.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.AutoDetect" crefType="Unqualified"/>The method will try each demodulation mode and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.Combined" crefType="Unqualified"/>The method uses the histogram of the Data Matrix barcode to calculate a threshold. For cells with pixel values that are sufficiently below or above this threshold, the method will use the threshold to determine if the cell is on or off. If the cell pixel values are close to the threshold, the method will use the DataMatrixDemodulationModeLocalContrast mode to determine if the cell is on or off. This mode is slower, but works with images that contain a Data Matrix barcode with extremely low cell fill percentages or gross print growth errors.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.Histogram" crefType="Unqualified"/>The method uses a histogram of all of the Data Matrix cells to calculate a threshold. This threshold determines if a cell is on or off. This is the fastest mode, but requires images with consistent levels of contrast.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.LocalContrast" crefType="Unqualified"/>The method examines each of the cell's neighbors to determine if the cell is on or off. This mode is slower, but works with images that have inconsistent levels of contrast. 
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixDemodulationMode DemodulationMode
        {
            get { return _demodulationMode; }
            set { _demodulationMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast a pixel must have in order to be considered part of a Data Matrix barcode cell edge.
        /// </summary>
        /// <value>
        /// The default value is 30.
        /// </value>
        /// <remarks>
        /// The lower this value, the more potential edge candidates the method will examine during the location phase. Setting this value too low will decrease the performance of the method because the method will examine too many potential edge candidates. Setting this value too high may also decrease the performance of the method by removing valid edge candidates, making location require more iterations. Setting this value too high may also cause the method to fail to identify the Data Matrix barcode because all edge candidates are eliminated. 
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 EdgeThreshold
        {
            get { return _edgeThreshold; }
            set { _edgeThreshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method should locate the barcode.
        /// </summary>
        /// <value>
        /// The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, specifies that the method should assume that the Data Matrix barcode occupies the entire image (or the entire search region). The method then skips the location phase, moving immediately to extraction and decoding. If <see langword="false"/>, the method does not make any assumptions about the percentage of the image occupied by the Data Matrix barcode. 
        /// </remarks>

        public bool SkipLocation
        {
            get { return _skipLocation; }
            set { _skipLocation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the amount of Data Matrix barcode rotation the function should allow for.
        /// </summary>
        /// <value>
        /// The default value is <see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Unlimited" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Degrees0" crefType="Unqualified"/>The method allows for  5 degrees of rotation.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Degrees180" crefType="Unqualified"/>The method allows for between 175 and 185 degrees of rotation.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Degrees270" crefType="Unqualified"/>The method allows for between 265 and 275 degrees of rotation.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Degrees90" crefType="Unqualified"/>The method allows for between 85 and 95 degrees of rotation.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.DataMatrixRotationMode.Unlimited" crefType="Unqualified"/>The method allows for unlimited rotation.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public DataMatrixRotationMode RotationMode
        {
            get { return _rotationMode; }
            set { _rotationMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixSearchOptions.
        /// </summary>
        /// <param name="other">
        /// A DataMatrixSearchOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DataMatrixSearchOptions other)
        {
            return other != null && _rotationMode == other._rotationMode && _skipLocation == other._skipLocation && _edgeThreshold == other._edgeThreshold && _demodulationMode == other._demodulationMode && _cellSampleSize == other._cellSampleSize && _cellFilterMode == other._cellFilterMode && _skewDegreesAllowed == other._skewDegreesAllowed && _maximumIterations == other._maximumIterations && _initialSearchVectorWidth == other._initialSearchVectorWidth;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixSearchOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DataMatrixSearchOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DataMatrixSearchOptions other = (DataMatrixSearchOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rotationMode.GetHashCode() ^ _skipLocation.GetHashCode() ^ _edgeThreshold.GetHashCode() ^ _demodulationMode.GetHashCode() ^ _cellSampleSize.GetHashCode() ^ _cellFilterMode.GetHashCode() ^ _skewDegreesAllowed.GetHashCode() ^ _maximumIterations.GetHashCode() ^ _initialSearchVectorWidth.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DataMatrixSearchOptions: RotationMode=" + _rotationMode.ToString() + ", DemodulationMode=" + _demodulationMode.ToString() + ", CellSampleSize=" + _cellSampleSize.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides parameters that describe the results of  reading the data matrix barcode. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DataMatrixReport
    {
        private bool _found;
        private bool _binary;
        private byte[] _binaryData;
        private string _stringData;
        private Collection<PointContour> _corners;
        private UInt32 _errorsCorrected;
        private UInt32 _erasuresCorrected;
        private double _aspectRatio;
        private UInt32 _rows;
        private UInt32 _columns;
        private DataMatrixEcc _ecc;
        private DataMatrixPolarity _polarity;
        private DataMatrixCellFillMode _cellFill;
        private double _borderIntegrity;
        private bool _mirrored;
        private UInt32 _minimumEdgeStrength;
        private DataMatrixDemodulationMode _demodulationMode;
        private DataMatrixCellSampleSize _cellSampleSize;
        private DataMatrixCellFilterMode _cellFilterMode;
        private UInt32 _iterations;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DataMatrixReport class.
        /// </summary>

        public DataMatrixReport()
        {
            _corners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of iterations the method took in attempting to locate the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// If this number is equal to the <see cref="NationalInstruments.Vision.Analysis.DataMatrixSearchOptions.MaximumIterations" crefType="Unqualified"/> 
        /// property of the DataMatrixSearchOptions input parameter and the method failed to locate the Data Matrix barcode, 
        /// you may be able to locate the Data Matrix barcode by increasing <see cref="NationalInstruments.Vision.Analysis.DataMatrixSearchOptions.MaximumIterations" crefType="Unqualified"/>.
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 Iterations
        {
            get { return _iterations; }
            set { _iterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the cell filter mode the method used to locate the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// 	<para>If CellFill is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFilterMode.AutoDetect" crefType="Unqualified"/> for the 
        /// <paramref name="DataMatrixSearchOptions"/>
        /// parameter, this property indicates the
        ///  recommended cell fill  mode for this image.
        /// </para>
        /// </remarks>

        public DataMatrixCellFilterMode CellFilterMode
        {
            get { return _cellFilterMode; }
            set { _cellFilterMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the cell sample size the method used to locate the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// 	<para>If CellSample is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellSampleSize.AutoDetect" crefType="Unqualified"/> for the 
        /// <paramref name="DataMatrixSearchOptions"/>
        /// parameter, this property indicates the
        ///  recommended cell fill  mode for this image.
        /// </para>
        /// </remarks>

        public DataMatrixCellSampleSize CellSampleSize
        {
            get { return _cellSampleSize; }
            set { _cellSampleSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the demodulation mode the function used to locate the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// 	
        /// If DemodulationMode is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixDemodulationMode.AutoDetect" crefType="Unqualified"/> 
        /// in the <paramref name="DataMatrixSearchOptions"/> parameter, this property indicates the recommended demodulation mode for this image.
        ///  
        /// </remarks>

        public DataMatrixDemodulationMode DemodulationMode
        {
            get { return _demodulationMode; }
            set { _demodulationMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the strength of the weakest edge the method used to find the coarse location of the Data Matrix barcode in the image.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// Use this value as a guide for setting the EdgeThreshold property of the DataMatrixSearchOptions input parameter. 
        /// </remarks>

        [CLSCompliant(false)]
        public UInt32 MinimumEdgeStrength
        {
            get { return _minimumEdgeStrength; }
            set { _minimumEdgeStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the Data Matrix barcode appears mirrored in the image. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the Data Matrix barcode appears mirrored in the image. If <see langword="false"/>, the Data Matrix barcode appears normally in the image.
        /// </remarks>

        public bool Mirrored
        {
            get { return _mirrored; }
            set { _mirrored = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the percentage of the Data Matrix barcode border that appears correctly in the image.
        /// </summary>
        /// <value>
        /// </value>

        public double BorderIntegrity
        {
            get { return _borderIntegrity; }
            set { _borderIntegrity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the cell fill percentage of the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// 	<para>If CellFill is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixCellFillMode.AutoDetect" crefType="Unqualified"/> for the 
        /// <paramref name="DataMatrixDescriptionOptions"/>
        /// parameter, this property indicates the
        ///  recommended cell fill  mode for this image.
        /// </para>
        /// </remarks>

        public DataMatrixCellFillMode CellFill
        {
            get { return _cellFill; }
            set { _cellFill = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the polarity of the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>If Polarity is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixPolarity.AutoDetect" crefType="Unqualified"/> in the
        ///  DataMatrixDescriptionOptions parameter, this property indicates the recommended polarity for this image.
        /// </remarks>

        public DataMatrixPolarity Polarity
        {
            get { return _polarity; }
            set { _polarity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the ECC (error correction code) used by the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        ///  If Ecc is set to <see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.AutoDetect" crefType="Unqualified"/> or 
        /// <see cref="NationalInstruments.Vision.Analysis.DataMatrixEcc.Ecc000To140" crefType="Unqualified"/> in the <paramref name=" DataMatrixDescriptionOptions"/> parameter, this property indicates the recommended ECC for this image.
        /// </remarks>

        public DataMatrixEcc Ecc
        {
            get { return _ecc; }
            set { _ecc = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of columns in the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>

        [CLSCompliant(false)]
        public UInt32 Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of rows in the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>

        [CLSCompliant(false)]
        public UInt32 Rows
        {
            get { return _rows; }
            set { _rows = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the aspect ratio of the Data Matrix barcode in the image, which equals the ratio of the width of a Data Matrix barcode cell (in pixels) divided by the height of a Data Matrix barcode cell (in pixels).
        /// </summary>
        /// <value>
        /// </value>

        public double AspectRatio
        {
            get { return _aspectRatio; }
            set { _aspectRatio = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of erasures the method corrected when decoding the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>

        [CLSCompliant(false)]
        public UInt32 ErasuresCorrected
        {
            get { return _erasuresCorrected; }
            set { _erasuresCorrected = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of errors the method corrected when decoding the DataMatrix barcode.
        /// </summary>
        /// <value>
        /// </value>

        [CLSCompliant(false)]
        public UInt32 ErrorsCorrected
        {
            get { return _errorsCorrected; }
            set { _errorsCorrected = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the coordinates of the corners of the rectangle surrounding the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// </remarks>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the string containing the decoded Data Matrix barcode data.
        /// </summary>
        /// <value>
        /// </value>

        public string StringData
        {
            get { return _stringData; }
            set { _stringData = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the binary data containing the raw Data Matrix barcode data.
        /// </summary>
        /// <returns>
        /// </returns>

        public byte[] GetBinaryData()
        {
            return _binaryData;
        }
        //==========================================================================================
        /// <summary>
        /// Sets the binary data containing the raw Data Matrix barcode data.
        /// </summary>
        /// <param name="binaryData">
        /// The binary data to set.
        /// </param>

        public void SetBinaryData(byte[] binaryData)
        {
            _binaryData = binaryData;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the data in the Data Matrix barcode is binary.
        /// </summary>
        /// <value>
        /// </value>

        public bool Binary
        {
            get { return _binary; }
            set { _binary = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method located and decoded a Data Matrix barcode. 
        /// </summary>
        /// <value>
        /// </value>

        public bool Found
        {
            get { return _found; }
            set { _found = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixReport.
        /// </summary>
        /// <param name="other">
        /// A DataMatrixReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DataMatrixReport other)
        {
            return other != null && _found == other._found && _binary == other._binary && Utilities.ArraysEqual(_binaryData, other._binaryData) && _stringData == other._stringData && Utilities.CollectionsEqual(_corners, other._corners) && _errorsCorrected == other._errorsCorrected && _erasuresCorrected == other._erasuresCorrected && _aspectRatio == other._aspectRatio && _rows == other._rows && _columns == other._columns && _ecc == other._ecc && _polarity == other._polarity && _cellFill == other._cellFill && _borderIntegrity == other._borderIntegrity && _mirrored == other._mirrored && _minimumEdgeStrength == other._minimumEdgeStrength && _demodulationMode == other._demodulationMode && _cellSampleSize == other._cellSampleSize && _cellFilterMode == other._cellFilterMode && _iterations == other._iterations;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DataMatrixReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DataMatrixReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DataMatrixReport other = (DataMatrixReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _found.GetHashCode() ^ _binary.GetHashCode() ^ _binaryData.Length.GetHashCode() ^ _stringData.GetHashCode() ^ _errorsCorrected.GetHashCode() ^ _erasuresCorrected.GetHashCode() ^ _aspectRatio.GetHashCode() ^ _rows.GetHashCode() ^ _columns.GetHashCode() ^ _ecc.GetHashCode() ^ _polarity.GetHashCode() ^ _cellFill.GetHashCode() ^ _borderIntegrity.GetHashCode() ^ _mirrored.GetHashCode() ^ _minimumEdgeStrength.GetHashCode() ^ _demodulationMode.GetHashCode() ^ _cellSampleSize.GetHashCode() ^ _cellFilterMode.GetHashCode() ^ _iterations.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DataMatrixReport: Found=" + _found.ToString() + ", StringData=" + ((_stringData != null) ? _stringData : "");
        }
    }

    //==============================================================================================
    /// <summary>Contains the results of grading a Data Matrix barcode.</summary>
    /// <remarks>
    /// If a Data Matrix barcode cannot be located by <see cref="NationalInstruments.Vision.Analysis.Algorithms.ReadDataMatrixBarcode" crefType="Unqualified"/>, the function assigns the Data Matrix barcode the value <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/> for all grades and the value 0 for all raw scores.</remarks>

    [Serializable]
    public sealed class AimGradeReport
    {
        private AimGrade _overallGrade;
        private AimGrade _decodingGrade;
        private AimGrade _symbolContrastGrade;
        private double _symbolContrast;
        private AimGrade _printGrowthGrade;
        private double _printGrowth;
        private AimGrade _axialNonuniformityGrade;
        private double _axialNonuniformity;
        private AimGrade _unusedErrorCorrectionGrade;
        private double _unusedErrorCorrection;

        //==========================================================================================
        /// <summary>Initializes a new instance of the AIMGradeReport class.
        /// </summary>

        public AimGradeReport()
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the unused error correction raw score for the Data Matrix barcode, which is based on the extent to which regional or spot damage in the Data Matrix barcode has eroded the reading safety margin provided by the error correction.
        /// </summary>
        /// <value>
        /// 	The default value is 0.0.
        /// </value>

        public double UnusedErrorCorrection
        {
            get { return _unusedErrorCorrection; }
            set { _unusedErrorCorrection = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the unused error correction letter grade for the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// 	The default value is <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/>.
        /// </value>

        public AimGrade UnusedErrorCorrectionGrade
        {
            get { return _unusedErrorCorrectionGrade; }
            set { _unusedErrorCorrectionGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the axial nonuniformity raw score for the Data Matrix barcode, which is based on how much the sampling point spacing differs from one axis to another.
        /// </summary>
        /// <value>
        /// 	The default value is 0.0.
        /// </value>

        public double AxialNonuniformity
        {
            get { return _axialNonuniformity; }
            set { _axialNonuniformity = value; }
        }

        //==========================================================================================
        /// <summary>Gets or sets the axial nonuniformity grade for the Data Matrix barcode.</summary>
        /// <value>
        /// 	The default value is F.
        /// </value>

        public AimGrade AxialNonuniformityGrade
        {
            get { return _axialNonuniformityGrade; }
            set { _axialNonuniformityGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the print growth raw score for the Data Matrix barcode, which is based on the extent to which dark or light markings appropriately fill their module boundaries.
        /// </summary>
        /// <value>
        /// 	The default value is 0.0.
        /// </value>

        public double PrintGrowth
        {
            get { return _printGrowth; }
            set { _printGrowth = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the print growth letter grade for the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// 	The default value is <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/>.
        /// </value>

        public AimGrade PrintGrowthGrade
        {
            get { return _printGrowthGrade; }
            set { _printGrowthGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the symbol contrast raw score representing the percentage difference between the mean of the reflectance of the darkest 10 percent and lightest 10 percent of the Data Matrix barcode.
        /// </summary>
        /// <value>
        /// 	The default value is 0.0.
        /// </value>

        public double SymbolContrast
        {
            get { return _symbolContrast; }
            set { _symbolContrast = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the letter grade assigned to a Data Matrix barcode based on the symbol contrast raw score.
        /// </summary>
        /// <value>
        /// 	The default value is <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/>.
        /// </value>

        public AimGrade SymbolContrastGrade
        {
            get { return _symbolContrastGrade; }
            set { _symbolContrastGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the letter grade assigned to a Data Matrix barcode based on the success in decoding the Data Matrix barcode. 
        /// </summary>
        /// <value>
        /// 	The default value is F.
        /// </value>
        /// <remarks>
        /// The method sets this grade to <see cref="NationalInstruments.Vision.Analysis.AimGrade.A" crefType="PartiallyQualified"/> if the method could decode the Data Matrix barcode, otherwise the function sets this grade to <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/>.
        /// </remarks>

        public AimGrade DecodingGrade
        {
            get { return _decodingGrade; }
            set { _decodingGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overall letter grade, which is equal to the lowest of the other five letter grades.</summary>
        /// <value>
        /// 	The default value is <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/>.
        /// </value>

        public AimGrade OverallGrade
        {
            get { return _overallGrade; }
            set { _overallGrade = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified AimGradeReport.
        /// </summary>
        /// <param name="other">
        /// An AimGradeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(AimGradeReport other)
        {
            return other != null && _overallGrade == other._overallGrade && _decodingGrade == other._decodingGrade && _symbolContrastGrade == other._symbolContrastGrade && _symbolContrast == other._symbolContrast && _printGrowthGrade == other._printGrowthGrade && _printGrowth == other._printGrowth && _axialNonuniformityGrade == other._axialNonuniformityGrade && _axialNonuniformity == other._axialNonuniformity && _unusedErrorCorrectionGrade == other._unusedErrorCorrectionGrade && _unusedErrorCorrection == other._unusedErrorCorrection;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified AimGradeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of AimGradeReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            AimGradeReport other = (AimGradeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _overallGrade.GetHashCode() ^ _decodingGrade.GetHashCode() ^ _symbolContrastGrade.GetHashCode() ^ _symbolContrast.GetHashCode() ^ _printGrowthGrade.GetHashCode() ^ _printGrowth.GetHashCode() ^ _axialNonuniformityGrade.GetHashCode() ^ _axialNonuniformity.GetHashCode() ^ _unusedErrorCorrectionGrade.GetHashCode() ^ _unusedErrorCorrection.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "AimGradeReport: OverallGrade=" + _overallGrade.ToString();
        }
    }

    //==============================================================================================
    /// <summary>Contains the results of grading a Data Matrix barcode.</summary>
    /// <remarks>
    /// If a Data Matrix barcode cannot be located by <see cref="NationalInstruments.Vision.Analysis.Algorithms.ReadDataMatrixBarcode" crefType="Unqualified"/>, the function assigns the Data Matrix barcode the value <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/> for all grades and the value 0 for all raw scores.</remarks>

    [Serializable]
    public sealed class CalibReflectanceStruct
    {
        private double _rcal;
        private double _srcal;
        private double _mlcal;
        private double _srtarget;

        //==========================================================================================
        // Default Constructor
        //==========================================================================================
        public CalibReflectanceStruct()
        {
            this._rcal = this._srcal = this._mlcal = this._srtarget = 0.0;
        }
        //==========================================================================================
        /// <summary>
        /// 
        /// </summary>
        /// <value>The default value is .
        /// </value>

        public double Srtarget
        {
            get { return _srtarget; }
            set { _srtarget = value; }
        }
        //==========================================================================================
        /// <summary>
        /// 
        /// </summary>
        /// <value>The default value is .
        /// </value>

        public double Mlcal
        {
            get { return _mlcal; }
            set { _mlcal = value; }
        }
        //==========================================================================================
        /// <summary>
        /// 
        /// </summary>
        /// <value>The default value is .
        /// </value>

        public double Srcal
        {
            get { return _srcal; }
            set { _srcal = value; }
        }
        //==========================================================================================
        /// <summary>
        /// 
        /// </summary>
        /// <value>The default value is .
        /// </value>

        public double Rcal
        {
            get { return _rcal; }
            set { _rcal = value; }
        }
    }

    //==============================================================================================
    /// <summary>Contains the results of grading a Data Matrix barcode.</summary>
    /// <remarks>
    /// If a Data Matrix barcode cannot be located by <see cref="NationalInstruments.Vision.Analysis.Algorithms.ReadDataMatrixBarcode" crefType="Unqualified"/>, the function assigns the Data Matrix barcode the value <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/> for all grades and the value 0 for all raw scores.</remarks>

    [Serializable]
    public sealed class AimDpmGradeReport
    {
        private AimGrade _overallGrade;
        private AimGrade _decodingGrade;
        private AimGrade _cellContrastGrade;
        private float _cellContrast;
        private AimGrade _printGrowthGrade;
        private float _printGrowth;
        private AimGrade _axialNonUniformityGrade;
        private float _axialNonUniformity;
        private AimGrade _unusedErrorCorrectionGrade;
        private float _unusedErrorCorrection;
        private AimGrade _gridNonUniformityGrade;
        private float _gridNonUniformity;
        private AimGrade _cellModulationGrade;
        private AimGrade _fixedPatternDamageGrade;
        private float _fixedPatternDamage;
        private AimGrade _minimumReflectanceGrade;
        private float _minimumReflectance;

        /// <summary>
        /// The minimum reflectance raw score for the Data Matrix code, which is the ratio of the parts reflectance to the calibrated reflectance.
        /// </summary>

        public float MinimumReflectance
        {
            get { return _minimumReflectance; }
            set { _minimumReflectance = value; }
        }
        /// <summary>
        /// The fixed pattern damage raw score for the Data Matrix code, which is the extent of damage in the finder pattern and quiet zone pattern.
        /// </summary>

        public float FixedPatternDamage
        {
            get { return _fixedPatternDamage; }
            set { _fixedPatternDamage = value; }
        }
        /// <summary>
        /// The grid nonuniformity raw score for the Data Matrix code, which is the largest vector deviation of the grid intersections, determined by the reference decode algorithm from the binarized image of a given symbol, from their ideal theoretical position.
        /// </summary>

        public float GridNonUniformity
        {
            get { return _gridNonUniformity; }
            set { _gridNonUniformity = value; }
        }
        /// <summary>
        /// The unused error correction raw score for the Data Matrix code, which is based on the extent to which regional or spot damage in the Data Matrix code has eroded the reading safety margin provided by the error correction.
        /// </summary>

        public float UnusedErrorCorrection
        {
            get { return _unusedErrorCorrection; }
            set { _unusedErrorCorrection = value; }
        }
        /// <summary>
        /// The axial nonuniformity raw score for the Data Matrix code, which is based on how much the sampling point spacing differs from one axis to another.
        /// </summary>

        public float AxialNonUniformity
        {
            get { return _axialNonUniformity; }
            set { _axialNonUniformity = value; }
        }
        /// <summary>
        /// The print growth raw score for the Data Matrix code, which is based on the extent to which dark or light markings appropriately fill their cell boundaries.
        /// </summary>

        public float PrintGrowth
        {
            get { return _printGrowth; }
            set { _printGrowth = value; }
        }
        /// <summary>
        /// The cell contrast raw score representing the difference between the mean light and the mean dark of the symbol histogram.
        /// </summary>

        public float CellContrast
        {
            get { return _cellContrast; }
            set { _cellContrast = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the minimum reflectance raw score.
        /// </summary>

        public AimGrade MinimumReflectanceGrade
        {
            get { return _minimumReflectanceGrade; }
            set { _minimumReflectanceGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the fixed pattern damage. Fixed pattern damage measures the damage in the finder pattern, quiet zone, clock pattern, and solid area segment regions.
        /// </summary>

        public AimGrade FixedPatternDamageGrade
        {
            get { return _fixedPatternDamageGrade; }
            set { _fixedPatternDamageGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the modulation raw score. Modulation is the measure of the uniformity of reflectance of the dark and light modules in the barcode.
        /// </summary>

        public AimGrade CellModulationGrade
        {
            get { return _cellModulationGrade; }
            set { _cellModulationGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the grid nonuniformity raw score.
        /// </summary>

        public AimGrade GridNonUniformityGrade
        {
            get { return _gridNonUniformityGrade; }
            set { _gridNonUniformityGrade = value; }
        }
        /// <summary>
        /// The unused error correction letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade UnusedErrorCorrectionGrade
        {
            get { return _unusedErrorCorrectionGrade; }
            set { _unusedErrorCorrectionGrade = value; }
        }
        /// <summary>
        /// The axial nonuniformity grade for the Data Matrix code.
        /// </summary>

        public AimGrade AxialNonUniformityGrade
        {
            get { return _axialNonUniformityGrade; }
            set { _axialNonUniformityGrade = value; }
        }
        /// <summary>
        /// The print growth letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade PrintGrowthGrade
        {
            get { return _printGrowthGrade; }
            set { _printGrowthGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the cell contrast raw score.
        /// </summary>

        public AimGrade CellContrastGrade
        {
            get { return _cellContrastGrade; }
            set { _cellContrastGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the success of the function in decoding the Data Matrix code. The function sets this grade to A if the function could decode the Data Matrix code, otherwise the function sets this grade to F.
        /// </summary>

        public AimGrade DecodingGrade
        {
            get { return _decodingGrade; }
            set { _decodingGrade = value; }
        }
        /// <summary>
        /// The overall letter grade, which is equal to the lowest of the other five letter grades.
        /// </summary>

        public AimGrade OverallGrade
        {
            get { return _overallGrade; }
            set { _overallGrade = value; }
        }
    }

    //==============================================================================================
    /// <summary>Contains the results of grading a Data Matrix barcode.</summary>
    /// <remarks>
    /// If a Data Matrix barcode cannot be located by <see cref="NationalInstruments.Vision.Analysis.Algorithms.ReadDataMatrixBarcode" crefType="Unqualified"/>, the function assigns the Data Matrix barcode the value <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/> for all grades and the value 0 for all raw scores.</remarks>

    [Serializable]
    public sealed class GradeReportISO15415
    {
        private AimGrade _overallGrade;
        private AimGrade _decodingGrade;
        private AimGrade _symbolContrastGrade;
        private float _symbolContrast;
        private AimGrade _printGrowthGrade;
        private float _printGrowth;
        private AimGrade _axialNonUniformityGrade;
        private float _axialNonUniformity;
        private AimGrade _unusedErrorCorrectionGrade;
        private float _unusedErrorCorrection;
        private AimGrade _gridNonUniformityGrade;
        private float _gridNonUniformity;
        private AimGrade _modulationGrade;
        private AimGrade _fixedPatternDamageGrade;
        private float _fixedPatternDamage;

        /// <summary>
        /// The fixed pattern damage raw score for the Data Matrix code, which is the extent of damage in the finder pattern and quiet zone pattern.
        /// </summary>

        public float FixedPatternDamage
        {
            get { return _fixedPatternDamage; }
            set { _fixedPatternDamage = value; }
        }
        /// <summary>
        /// The grid nonuniformity raw score for the Data Matrix code, which is the largest vector deviation of the grid intersections, determined by the reference decode algorithm from the binarized image of a given symbol, from their ideal theoretical position.
        /// </summary>

        public float GridNonUniformity
        {
            get { return _gridNonUniformity; }
            set { _gridNonUniformity = value; }
        }
        /// <summary>
        /// The unused error correction raw score for the Data Matrix code, which is based on the extent to which regional or spot damage in the Data Matrix code has eroded the reading safety margin provided by the error correction.
        /// </summary>

        public float UnusedErrorCorrection
        {
            get { return _unusedErrorCorrection; }
            set { _unusedErrorCorrection = value; }
        }
        /// <summary>
        /// The axial nonuniformity raw score for the Data Matrix code, which is based on how much the sampling point spacing differs from one axis to another.
        /// </summary>

        public float AxialNonUniformity
        {
            get { return _axialNonUniformity; }
            set { _axialNonUniformity = value; }
        }
        /// <summary>
        /// The print growth raw score for the Data Matrix code, which is based on the extent to which dark or light markings appropriately fill their cell boundaries.
        /// </summary>

        public float PrintGrowth
        {
            get { return _printGrowth; }
            set { _printGrowth = value; }
        }
        /// <summary>
        /// The symbol contrast raw score representing the percentage difference between the mean of the reflectance of the darkest 10 percent and lightest 10 percent of the Data Matrix code.
        /// </summary>

        public float SymbolContrast
        {
            get { return _symbolContrast; }
            set { _symbolContrast = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the fixed pattern damage. Fixed pattern damage measures the damage in the finder pattern, quiet zone, clock pattern, and solid area segment regions.
        /// </summary>

        public AimGrade FixedPatternDamageGrade
        {
            get { return _fixedPatternDamageGrade; }
            set { _fixedPatternDamageGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the modulation raw score. Modulation is the measure of the uniformity of reflectance of the dark and light modules in the barcode.
        /// </summary>

        public AimGrade ModulationGrade
        {
            get { return _modulationGrade; }
            set { _modulationGrade = value; }
        }
        /// <summary>
        /// The axial nonuniformity grade for the Data Matrix code.
        /// </summary>

        public AimGrade GridNonUniformityGrade
        {
            get { return _gridNonUniformityGrade; }
            set { _gridNonUniformityGrade = value; }
        }
        /// <summary>
        /// The unused error correction letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade UnusedErrorCorrectionGrade
        {
            get { return _unusedErrorCorrectionGrade; }
            set { _unusedErrorCorrectionGrade = value; }
        }
        /// <summary>
        /// The axial nonuniformity grade for the Data Matrix code.
        /// </summary>

        public AimGrade AxialNonUniformityGrade
        {
            get { return _axialNonUniformityGrade; }
            set { _axialNonUniformityGrade = value; }
        }
        /// <summary>
        /// The print growth letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade PrintGrowthGrade
        {
            get { return _printGrowthGrade; }
            set { _printGrowthGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the symbol contrast raw score.
        /// </summary>

        public AimGrade SymbolContrastGrade
        {
            get { return _symbolContrastGrade; }
            set { _symbolContrastGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the success of the function in decoding the Data Matrix code. The function sets this grade to A if the function could decode the Data Matrix code, otherwise the function sets this grade to F.
        /// </summary>

        public AimGrade DecodingGrade
        {
            get { return _decodingGrade; }
            set { _decodingGrade = value; }
        }
        /// <summary>
        /// The overall letter grade, which is equal to the lowest of the other five letter grades.
        /// </summary>

        public AimGrade OverallGrade
        {
            get { return _overallGrade; }
            set { _overallGrade = value; }
        }
    }

    //==============================================================================================
    /// <summary>Contains the results of grading a Data Matrix barcode.</summary>
    /// <remarks>
    /// If a Data Matrix barcode cannot be located by <see cref="NationalInstruments.Vision.Analysis.Algorithms.ReadDataMatrixBarcode" crefType="Unqualified"/>, the function assigns the Data Matrix barcode the value <see cref="NationalInstruments.Vision.Analysis.AimGrade.F" crefType="PartiallyQualified"/> for all grades and the value 0 for all raw scores.</remarks>

    [Serializable]
    public sealed class GradeReportISO16022
    {
        private AimGrade _overallGrade;
        private AimGrade _decodingGrade;
        private AimGrade _symbolContrastGrade;
        private float _symbolContrast;
        private AimGrade _printGrowthGrade;
        private float _printGrowth;
        private AimGrade _axialNonUniformityGrade;
        private float _axialNonUniformity;
        private AimGrade _unusedErrorCorrectionGrade;
        private float _unusedErrorCorrection;

        /// <summary>
        /// The unused error correction raw score for the Data Matrix code, which is based on the extent to which regional or spot damage in the Data Matrix code has eroded the reading safety margin provided by the error correction.
        /// </summary>

        public float UnusedErrorCorrection
        {
            get { return _unusedErrorCorrection; }
            set { _unusedErrorCorrection = value; }
        }
        /// <summary>
        /// The axial nonuniformity raw score for the Data Matrix code, which is based on how much the sampling point spacing differs from one axis to another.
        /// </summary>

        public float AxialNonUniformity
        {
            get { return _axialNonUniformity; }
            set { _axialNonUniformity = value; }
        }
        /// <summary>
        /// The print growth raw score for the Data Matrix code, which is based on the extent to which dark or light markings appropriately fill their cell boundaries.
        /// </summary>

        public float PrintGrowth
        {
            get { return _printGrowth; }
            set { _printGrowth = value; }
        }
        //==========================================================================================
        /// <summary>
        /// 
        /// </summary>
        /// <value>The default value is .
        /// </value>

        public float SymbolContrast
        {
            get { return _symbolContrast; }
            set { _symbolContrast = value; }
        }
        /// <summary>
        /// The unused error correction letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade UnusedErrorCorrectionGrade
        {
            get { return _unusedErrorCorrectionGrade; }
            set { _unusedErrorCorrectionGrade = value; }
        }
        /// <summary>
        /// The axial nonuniformity grade for the Data Matrix code.
        /// </summary>

        public AimGrade AxialNonUniformityGrade
        {
            get { return _axialNonUniformityGrade; }
            set { _axialNonUniformityGrade = value; }
        }
        /// <summary>
        /// The print growth letter grade for the Data Matrix code.
        /// </summary>

        public AimGrade PrintGrowthGrade
        {
            get { return _printGrowthGrade; }
            set { _printGrowthGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the symbol contrast raw score.
        /// </summary>

        public AimGrade SymbolContrastGrade
        {
            get { return _symbolContrastGrade; }
            set { _symbolContrastGrade = value; }
        }
        /// <summary>
        /// The letter grade assigned to a Data Matrix code based on the success of the function in decoding the Data Matrix code. The function sets this grade to A if the function could decode the Data Matrix code, otherwise the function sets this grade to F.
        /// </summary>

        public AimGrade DecodingGrade
        {
            get { return _decodingGrade; }
            set { _decodingGrade = value; }
        }
        /// <summary>
        /// The overall letter grade, which is equal to the lowest of the other five letter grades.
        /// </summary>

        public AimGrade OverallGrade
        {
            get { return _overallGrade; }
            set { _overallGrade = value; }
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines how the method will find edges.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class EdgeOptions
    {
        private EdgePolaritySearchMode _polarity;
        private UInt32 _kernelSize;
        private UInt32 _width;
        private double _minimumThreshold;
        private InterpolationMethod _interpolationType;
        private ColumnProcessingMode _columnProcessingMode;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public EdgeOptions()
            : this(EdgePolaritySearchMode.All)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="polarity">The polarity of the edges to be found. 
        /// </param>

        public EdgeOptions(EdgePolaritySearchMode polarity)
            : this(polarity, 10)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="polarity">The polarity of the edges to be found. 
        /// </param>
        /// <param name="minimumThreshold">The minimum edge strength, also known as the gradient magnitude, required for a detected edge. 
        /// </param>

        public EdgeOptions(EdgePolaritySearchMode polarity, double minimumThreshold)
            : this(polarity, minimumThreshold, InterpolationMethod.BilinearFixed)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="polarity">The polarity of the edges to be found. 
        /// </param>
        /// <param name="minimumThreshold">The minimum edge strength, also known as the gradient magnitude, required for a detected edge. 
        /// </param>
        /// <param name="interpolationType">The interpolation method used to locate the edge position.
        /// </param>

        public EdgeOptions(EdgePolaritySearchMode polarity, double minimumThreshold, InterpolationMethod interpolationType)
        {
            _polarity = polarity;
            _minimumThreshold = minimumThreshold;
            _interpolationType = interpolationType;
            _kernelSize = 3;
            _width = 3;
            _columnProcessingMode = ColumnProcessingMode.Average;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the processing mode used to find the straight edge. 
        /// </summary>
        /// <value>The default value is Average.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// AverageUses the average of a column.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// MedianUses the median of a column.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public ColumnProcessingMode ColumnProcessingMode
        {
            get { return _columnProcessingMode; }
            set { _columnProcessingMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the interpolation method used to locate the edge position.
        /// </summary>
        /// <value>
        /// The default value is BilinearFixed.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// BilinearThe function uses an interpolation method that interpolates new pixel values using a bidirectional average of the neighboring pixels. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// BilinearFixedThe function uses an interpolation method that interpolates new pixel values using bilinear fixed interpolation.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// CubicThe function uses an interpolation method that interpolates new pixel values by fitting them to a cubic spline curve, where the curve is based on known pixel values from the image. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// QuadraticThe function uses an interpolation method that interpolates new pixel values using a quadratic approximating polynomial. 
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// ZeroOrderThe function uses an interpolation method that interpolates new pixel values using the nearest valid neighboring pixel. 
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public InterpolationMethod InterpolationType
        {
            get { return _interpolationType; }
            set { _interpolationType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum edge strength, also known as the gradient magnitude, required for a detected edge. 
        /// </summary>
        /// <value>
        /// The default value is 10.0.
        /// </value>

        public double MinimumThreshold
        {
            get { return _minimumThreshold; }
            set { _minimumThreshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of pixels averaged perpendicular to the search direction to compute the edge profile strength at each point along the search region. 
        /// </summary>
        /// <value>
        /// The default value is 3.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the edge detection kernel. 
        /// </summary>
        /// <value>
        /// The default value is 3.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 KernelSize
        {
            get { return _kernelSize; }
            set { _kernelSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the polarity of the edges to be found. 
        /// </summary>
        /// <value>The default value is All.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// AllSearch for all edges.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// FallingSearch for falling edges.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// RisingSearch for rising edges.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public EdgePolaritySearchMode Polarity
        {
            get { return _polarity; }
            set { _polarity = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A EdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EdgeOptions other)
        {
            return other != null && _polarity == other._polarity && _kernelSize == other._kernelSize && _width == other._width && _minimumThreshold == other._minimumThreshold && _interpolationType == other._interpolationType && _columnProcessingMode == other._columnProcessingMode;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EdgeOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EdgeOptions other = (EdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _polarity.GetHashCode() ^ _kernelSize.GetHashCode() ^ _width.GetHashCode() ^ _minimumThreshold.GetHashCode() ^ _interpolationType.GetHashCode() ^ _columnProcessingMode.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EdgeOptions: Polarity=" + _polarity + ", MinimumThreshold=" + _minimumThreshold;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a detected edge.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class EdgeInfo
    {
        private PointContour _position;
        private PointContour _calibratedPosition;
        private double _distance;
        private double _calibratedDistance;
        private double _magnitude;
        private double _noisePeak;
        private EdgePolarity _polarity;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeInfo class.
        /// </summary>

        public EdgeInfo()
        {
            _position = new PointContour();
            _calibratedPosition = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the polarity of the edges to be found. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgePolarity Polarity
        {
            get { return _polarity; }
            set { _polarity = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the strength of the noise associated with the current edge.
        /// </summary>
        /// <value>
        /// </value>

        public double NoisePeak
        {
            get { return _noisePeak; }
            set { _noisePeak = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the intensity contrast at the edge.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This property can be used as the noise level for the detected edge.
        /// </remarks>

        public double Magnitude
        {
            get { return _magnitude; }
            set { _magnitude = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the edge from the first point along the boundary of the input region in calibrated units.
        /// </summary>
        /// <value>
        /// </value>

        public double CalibratedDistance
        {
            get { return _calibratedDistance; }
            set { _calibratedDistance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the edge from the first point along the boundary of the input region in pixels.
        /// </summary>
        /// <value>
        /// </value>

        public double Distance
        {
            get { return _distance; }
            set { _distance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the position of the edge in the image in real-world coordinates.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour CalibratedPosition
        {
            get { return _calibratedPosition; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _calibratedPosition = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the position of the edge in the image in pixel coordinates.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Position
        {
            get { return _position; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _position = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeInfo.
        /// </summary>
        /// <param name="other">
        /// An EdgeInfo instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EdgeInfo other)
        {
            return other != null && Object.Equals(_position, other._position) && Object.Equals(_calibratedPosition, other._calibratedPosition) && _distance == other._distance && _calibratedDistance == other._calibratedDistance && _magnitude == other._magnitude && _noisePeak == other._noisePeak && _polarity == other._polarity;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeInfo.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EdgeInfo and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EdgeInfo other = (EdgeInfo)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _position.GetHashCode() ^ _calibratedPosition.GetHashCode() ^ _distance.GetHashCode() ^ _calibratedDistance.GetHashCode() ^ _magnitude.GetHashCode() ^ _noisePeak.GetHashCode() ^ _polarity.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EdgeInfo: Position=" + _position.ToString() + ", Distance=" + _distance.ToString(CultureInfo.CurrentCulture) + ", Polarity=" + _polarity.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a detected edge.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class EdgeReport
    {
        private Collection<EdgeInfo> _edges;
        private Collection<double> _gradientInfo;
        private bool _calibrationValid;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgeReport class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public EdgeReport()
        {
            _edges = new Collection<EdgeInfo>();
            _gradientInfo = new Collection<double>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the edges contained in this report have valid calibration data.
        /// </summary>
        /// <value>
        /// </value>

        public bool CalibrationValid
        {
            get { return _calibrationValid; }
            set { _calibrationValid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of double-precision values that correspond to the intensity profile of the region used to detect edges.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<double> GradientInfo
        {
            get { return _gradientInfo; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_gradientInfo = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the collection of edges found during edge detection.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<EdgeInfo> Edges
        {
            get { return _edges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_edges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeReport.
        /// </summary>
        /// <param name="other">
        /// An EdgeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EdgeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_edges, other._edges) && Utilities.CollectionsEqual(_gradientInfo, other._gradientInfo) && _calibrationValid == other._calibrationValid;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EdgeReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EdgeReport other = (EdgeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _edges.Count.GetHashCode() ^ _gradientInfo.Count.GetHashCode() ^ _calibrationValid.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EdgeReport: Edges=" + _edges.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a search arc used for finding edges.
    /// </summary>

    [Serializable]
    public sealed class SearchArcInfo
    {
        private Arc _arc;
        private EdgeReport _edgeReport;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SearchArcInfo class.
        /// </summary>

        public SearchArcInfo()
        {
            _arc = new Arc();
            _edgeReport = new EdgeReport();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets information about the edges found in this search line. 
        /// </summary>

        public EdgeReport EdgeReport
        {
            get { return _edgeReport; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeReport = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the arc used for edge detection. 
        /// </summary>
        /// <value>
        /// </value>

        public Arc Arc
        {
            get { return _arc; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _arc = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SearchArcInfo.
        /// </summary>
        /// <param name="other">
        /// A SearchArcInfo instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SearchArcInfo other)
        {
            return other != null && Object.Equals(_arc, other._arc) && Object.Equals(_edgeReport, other._edgeReport);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SearchArcInfo.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SearchArcInfo
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SearchArcInfo other = (SearchArcInfo)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _arc.GetHashCode() ^ _edgeReport.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SearchArcInfo: Arc=" + _arc.ToString() + ", EdgeReport=" + _edgeReport.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing the concentric rake and the edges calculated with the concentric rake.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ConcentricRakeReport
    {
        private Collection<EdgeInfo> _firstEdges;
        private Collection<EdgeInfo> _lastEdges;
        private Collection<SearchArcInfo> _searchArcs;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConcentricRakeReport class.
        /// </summary>

        public ConcentricRakeReport()
        {
            _firstEdges = new Collection<EdgeInfo>();
            _lastEdges = new Collection<EdgeInfo>();
            _searchArcs = new Collection<SearchArcInfo>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the arcs used for edge detection and the edge information for each arc.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<SearchArcInfo> SearchArcs
        {
            get { return _searchArcs; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_searchArcs = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the last edge point detected along each search line in the ROI. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<EdgeInfo> LastEdges
        {
            get { return _lastEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_lastEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the first edge point detected along each search line in the ROI. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<EdgeInfo> FirstEdges
        {
            get { return _firstEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_firstEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConcentricRakeReport.
        /// </summary>
        /// <param name="other">
        /// A ConcentricRakeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ConcentricRakeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_searchArcs, other._searchArcs) && Utilities.CollectionsEqual(_firstEdges, other._firstEdges) && Utilities.CollectionsEqual(_lastEdges, other._lastEdges);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConcentricRakeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ConcentricRakeReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ConcentricRakeReport other = (ConcentricRakeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstEdges.Count.GetHashCode() ^ _lastEdges.Count.GetHashCode() ^ _searchArcs.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ConcentricRakeReport: FirstEdges=" + _firstEdges.ToString() + ", LastEdges=" + _lastEdges.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains information about a threshold range.
    /// </summary>

    [Serializable]
    public sealed class ThresholdData
    {
        private Range _range;
        private double _newValue;
        private bool _useNewValue;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ThresholdData class.
        /// </summary>
        /// <param name="range">
        /// The range of pixel values to keep.
        /// </param>

        public ThresholdData(Range range) : this(range, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ThresholdData class.
        /// </summary>
        /// <param name="range">
        /// The range of pixel values to keep.
        /// </param>
        /// <param name="useNewValue">
        /// Set this parameter to <see langword="true"/> to set the pixel values within the <format type="italics">range</format> 
        /// to the value specified in <format type="italics">newValue</format>. Set this parameter to <see langword="false"/> to 
        /// leave the pixel values unchanged. This parameter has a default value of <see langword="true"/>.
        /// </param>

        public ThresholdData(Range range, bool useNewValue) : this(range, useNewValue, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ThresholdData class.
        /// </summary>
        /// <param name="range">
        /// The range of pixel values to keep.
        /// </param>
        /// <param name="useNewValue">
        /// Set this parameter to <see langword="true"/> to set the pixel values within the <format type="italics">range</format> 
        /// to the value specified in <format type="italics">newValue</format>. Set this parameter to <see langword="false"/> to 
        /// leave the pixel values unchanged. This parameter has a default value of <see langword="true"/>.
        /// </param>
        /// <param name="newValue">
        /// If <format type="italics">useNewValue</format> is set to true, 
        /// <format type="italics">newValue</format> is the replacement value for pixels within the 
        /// <format type="italics">range</format>. If <format type="italics">useNewValue</format> is set to 
        /// false, the pixel values are not changed. The default value is 1.
        /// </param>

        public ThresholdData(Range range, bool useNewValue, double newValue)
        {
            if (range == null) { throw new ArgumentNullException("range"); }
            _range = range;
            _newValue = newValue;
            _useNewValue = useNewValue;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method sets pixel values within the Range to the value specified in NewValue. 
        /// </summary>
        /// <value>
        /// 	<see langword="true"/> sets the pixel values to to the value specified in NewValue. 
        /// </value>

        public bool UseNewValue
        {
            get { return _useNewValue; }
            set { _useNewValue = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the replacement value for pixels within the Range.
        /// </summary>
        /// <value>
        /// </value>

        public double NewValue
        {
            get { return _newValue; }
            set { _newValue = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of pixel values to keep.
        /// </summary>
        /// <value>
        /// The default is (128, 255).
        /// </value>

        public Range Range
        {
            get { return _range; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _range = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ThresholdData.
        /// </summary>
        /// <param name="other">
        /// A ThresholdData instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ThresholdData other)
        {
            return other != null && Object.Equals(_range, other._range) && _useNewValue == other._useNewValue && _newValue == other._newValue;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ThresholdData.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ThresholdData and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ThresholdData other = (ThresholdData)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _range.GetHashCode() ^ _useNewValue.GetHashCode() ^ _newValue.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ThresholdData: Range=" + _range.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the options to use when performing a local threshold.
    /// </summary>

    [Serializable]
    public sealed class LocalThresholdOptions
    {
        private LocalThresholdMethod _method;
        private ParticleType _particleType;
        private double _replaceValue;
        private UInt32 _windowWidth;
        private UInt32 _windowHeight;
        private double _deviationWeight;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LocalThresholdOptions class.
        /// </summary>

        public LocalThresholdOptions()
            : this(ParticleType.Bright)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LocalThresholdOptions class.
        /// </summary>
        /// <param name="particleType">
        /// The type of objects to be detected.
        /// </param>

        public LocalThresholdOptions(ParticleType particleType)
            : this(particleType, LocalThresholdMethod.NiBlack)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LocalThresholdOptions class.
        /// </summary>
        /// <param name="particleType">
        /// The type of objects to be detected.
        /// </param>
        /// <param name="method">
        /// The local thresholding method.
        /// </param>

        public LocalThresholdOptions(ParticleType particleType, LocalThresholdMethod method)
            : this(particleType, method, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LocalThresholdOptions class.
        /// </summary>
        /// <param name="particleType">
        /// The type of objects to be detected.
        /// </param>
        /// <param name="method">
        /// The local thresholding method.
        /// </param>
        /// <param name="replaceValue">
        /// The replacement value for the pixels of the kept objects in the destination image.
        /// </param>

        public LocalThresholdOptions(ParticleType particleType, LocalThresholdMethod method, double replaceValue)
            : this(particleType, method, replaceValue, 32, 32)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LocalThresholdOptions class.
        /// </summary>
        /// <param name="particleType">
        /// The type of objects to be detected.
        /// </param>
        /// <param name="method">
        /// The local thresholding method.
        /// </param>
        /// <param name="replaceValue">
        /// The replacement value for the pixels of the kept objects in the destination image.
        /// </param>
        /// <param name="windowWidth">
        /// The width of the rectangular window around the pixel on which the method performs the local threshold. This number must be at least 3 and cannot be larger than the height of the source image.
        /// </param>
        /// <param name="windowHeight">
        /// The height of the rectangular window around the pixel on which the method performs the local threshold. This number must be at least 3 and cannot be larger than the height of the source image.
        /// </param>

        [CLSCompliant(false)]
        public LocalThresholdOptions(ParticleType particleType, LocalThresholdMethod method, double replaceValue, UInt32 windowWidth, UInt32 windowHeight)
        {
            _particleType = particleType;
            _method = method;
            _replaceValue = replaceValue;
            _windowWidth = windowWidth;
            _windowHeight = windowHeight;
            _deviationWeight = .2;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the weight applied to the variance calculation. 
        /// </summary>
        /// <value>
        /// The default is 0.2.
        /// </value>
        /// <remarks>
        /// Valid k constants range from 0 to 1. Settings this value to 0 will increase the performance of the method because the method will not calculate the variance for any of the pixels.
        /// </remarks>

        public double DeviationWeight
        {
            get { return _deviationWeight; }
            set { _deviationWeight = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the rectangular window around the pixel on which the method performs the local threshold. This number must be at least 3 and cannot be larger than the height of the source image.
        /// </summary>
        /// <value>
        ///  The default value is 32.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 WindowHeight
        {
            get { return _windowHeight; }
            set { _windowHeight = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the rectangular window around the pixel on which the method performs the local threshold. This number must be at least 3 and cannot be larger than the width of the source image.
        /// </summary>
        /// <value>
        ///  The default value is 32.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 WindowWidth
        {
            get { return _windowWidth; }
            set { _windowWidth = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the replacement value for the pixels of the kept objects in the destination image.
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public double ReplaceValue
        {
            get { return _replaceValue; }
            set { _replaceValue = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of objects to be detected.
        /// </summary>
        /// <value>
        /// The default is Bright.
        /// </value>

        public ParticleType ParticleType
        {
            get { return _particleType; }
            set { _particleType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the local thresholding method.
        /// </summary>
        /// <value>
        /// The default is NiBlack.
        /// </value>

        public LocalThresholdMethod Method
        {
            get { return _method; }
            set { _method = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LocalThresholdOptions.
        /// </summary>
        /// <param name="other">
        /// A LocalThresholdOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LocalThresholdOptions other)
        {
            return other != null && _method == other._method && _particleType == other._particleType && _replaceValue == other._replaceValue && _windowWidth == other._windowWidth && _windowHeight == other._windowHeight && _deviationWeight == other._deviationWeight;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LocalThresholdOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LocalThresholdOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LocalThresholdOptions other = (LocalThresholdOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _method.GetHashCode() ^ _particleType.GetHashCode() ^ _replaceValue.GetHashCode() ^ _windowWidth.GetHashCode() ^ _windowHeight.GetHashCode() ^ _deviationWeight.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LocalThresholdOptions: ParticleType=" + _particleType.ToString() + ", Method=" + _method.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a detected circle.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CircleReport
    {
        private PointContour _center;
        private int _radius;
        private int _area;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a CircleReport class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public CircleReport() :this(new PointContour())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a CircleReport class.
        /// </summary>
        /// <param name="center">
        /// Center point of the circle.
        /// </param>
        /// <remarks>
        /// </remarks>

        public CircleReport(PointContour center)
        {
            if (center == null) { throw new ArgumentNullException("center"); }
            _center = center;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the surface area, in pixels, of the nucleus of the circle as defined by the Danielsson distance map.
        /// </summary>
        /// <value>
        /// </value>

        public int Area
        {
            get { return _area; }
            set { _area = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the radius of the circle, in pixels.
        /// </summary>
        /// <value>
        /// </value>

        public int Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets ot sets the center point of the circle.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleReport.</summary>
        /// <param name="other">
        /// A CircleReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CircleReport other)
        {
            return other != null && Object.Equals(_center, other._center) && _radius == other._radius && _area == other._area;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleReport. </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CircleReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CircleReport other = (CircleReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _radius.GetHashCode() ^ _area.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CircleReport: Center=" + _center.ToString() + ", Radius=" + _radius.ToString(CultureInfo.CurrentCulture) + ", Area=" + _area.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides parameters used by various methods to find curves in an image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CurveOptions
    {
        private ExtractionMode _extractionMode;
        private int _threshold;
        private EdgeFilterSize _filterSize;
        private int _minimumLength;
        private int _rowStepSize;
        private int _columnStepSize;
        private int _maximumEndPointGap;
        private bool _onlyClosed;
        private bool _subpixelAccuracy;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>

        public CurveOptions()
            : this(false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>
        /// <param name="onlyClosed">Whether the method identifies only closed curves in the image.
        /// </param>

        public CurveOptions(bool onlyClosed)
            : this(onlyClosed, ExtractionMode.NormalImage)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>
        /// <param name="onlyClosed">Whether the method identifies only closed curves in the image.
        /// </param>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>

        public CurveOptions(bool onlyClosed, ExtractionMode extractionMode)
            : this(onlyClosed, extractionMode, EdgeFilterSize.Normal)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>
        /// <param name="onlyClosed">Whether the method identifies only closed curves in the image.
        /// </param>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>
        /// <param name="filterSize">The width of the edge filter the method uses to identify curves in the image.
        /// </param>

        public CurveOptions(bool onlyClosed, ExtractionMode extractionMode, EdgeFilterSize filterSize)
            : this(onlyClosed, extractionMode, filterSize, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>
        /// <param name="onlyClosed">Whether the method identifies only closed curves in the image.
        /// </param>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>
        /// <param name="filterSize">The width of the edge filter the method uses to identify curves in the image.
        /// </param>
        /// <param name="subpixelAccuracy">Whether the method identifies the location of curves with subpixel accuracy by interpolating between points to find the crossing of the threshold.
        /// </param>

        public CurveOptions(bool onlyClosed, ExtractionMode extractionMode, EdgeFilterSize filterSize, bool subpixelAccuracy)
        {
            _onlyClosed = onlyClosed;
            _subpixelAccuracy = subpixelAccuracy;
            _extractionMode = extractionMode;
            _filterSize = filterSize;
            _threshold = 75;
            _rowStepSize = 15;
            _columnStepSize = 15;
            _maximumEndPointGap = 10;
            _minimumLength = 25;
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveOptions class.
        /// </summary>
        /// <param name="onlyClosed">Whether the method identifies only closed curves in the image.
        /// </param>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>
        /// <param name="filterSize">The width of the edge filter the method uses to identify curves in the image.
        /// </param>
        /// <param name="subpixelAccuracy">Whether the method identifies the location of curves with subpixel accuracy by interpolating between points to find the crossing of the threshold.
        /// </param>
        /// <param name="threshold">Specifies the threshold.
        /// </param>
        /// <param name="rowStepSize">Specifies the row step size.
        /// </param>
        /// <param name="colStepSize">Specifies the column step size.
        /// </param>
        /// <param name="maximumEndPointGap">Specifies the maximum End Point Gap.
        /// </param>
        /// <param name="minimumLength">Specifies the minimum Length.
        /// </param>

        public CurveOptions(bool onlyClosed, ExtractionMode extractionMode, EdgeFilterSize filterSize, bool subpixelAccuracy, int threshold, int rowStepSize, int colStepSize, int maximumEndPointGap, int minimumLength)
        {
            _onlyClosed = onlyClosed;
            _subpixelAccuracy = subpixelAccuracy;
            _extractionMode = extractionMode;
            _filterSize = filterSize;
            _threshold = threshold;
            _rowStepSize = rowStepSize;
            _columnStepSize = colStepSize;
            _maximumEndPointGap = maximumEndPointGap;
            _minimumLength = minimumLength;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method identifies the location of curves with subpixel accuracy by interpolating between points to find the crossing of the threshold.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method identifies only closed curves in the image.
        /// </summary>
        /// <value>
        /// The default value is <see langword="false"/>, which specifies that the method identifies both open and closed curves.
        /// </value>

        public bool OnlyClosed
        {
            get { return _onlyClosed; }
            set { _onlyClosed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve.
        /// </summary>
        /// <value>The default value is 10.
        /// </value>

        public int MaximumEndPointGap
        {
            get { return _maximumEndPointGap; }
            set { _maximumEndPointGap = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance, in the x direction, between columns of pixels in the image that the method inspects for curve seed points.
        /// </summary>
        /// <value>
        /// Valid values for this property range from 1 to 255. The default value is 15.
        /// </value>
        /// <remarks>
        /// Set this value to be smaller than the minimum width of the object you want to detect in the image.
        /// </remarks>

        public int ColumnStepSize
        {
            get { return _columnStepSize; }
            set { _columnStepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance, in the y direction, between lines that the method inspects for curve seed points.
        /// </summary>
        /// <value>The default value is 15.
        /// Valid values for this property range from 1 to 255. 
        /// </value>
        /// <remarks>
        /// Set this value to be smaller than the minimum height of objects you want to detect in the image. 
        /// </remarks>

        public int RowStepSize
        {
            get { return _rowStepSize; }
            set { _rowStepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length, in pixels, of the smallest curve the method will extract.
        /// </summary>
        /// <value>The default value is 25.
        /// </value>
        /// <remarks>
        /// This property ignores curves that have a length less than MinimumLength pixels.
        /// </remarks>

        public int MinimumLength
        {
            get { return _minimumLength; }
            set { _minimumLength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the edge filter the method uses to identify curves in the image.
        /// </summary>
        /// <value>The default value for this property is <see cref="NationalInstruments.Vision.Analysis.EdgeFilterSize.Normal" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>You can use the following enumeration values with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.EdgeFilterSize.Fine" crefType="Unqualified"/>Specifies that the function uses a fine, or narrow, edge filter.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.EdgeFilterSize.Normal" crefType="Unqualified"/>Specifies that the function uses a normal edge filter.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public EdgeFilterSize FilterSize
        {
            get { return _filterSize; }
            set { _filterSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast a seed point must have for the method to begin a curve.
        /// </summary>
        /// <value>The default value is 75. Valid values for this property range from 1 to 360. 
        /// </value>

        public int Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method identifies curves in the image.
        /// </summary>
        /// <value>The default value is <see cref="NationalInstruments.Vision.Analysis.ExtractionMode.NormalImage" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following enumeration values with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.ExtractionMode.NormalImage" crefType="Unqualified"/>Specifies that the method makes no assumptions about the uniformity of objects in the image or the image background.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.Analysis.ExtractionMode.UniformRegions" crefType="Unqualified"/>Specifies that the method assumes that either the objects in the image or the image background consists of uniform pixel values. 
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public ExtractionMode ExtractionMode
        {
            get { return _extractionMode; }
            set { _extractionMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveOptions.
        /// </summary>
        /// <param name="other">
        /// A CurveOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CurveOptions other)
        {
            return other != null && _extractionMode == other._extractionMode && _threshold == other._threshold && _filterSize == other._filterSize && _minimumLength == other._minimumLength && _rowStepSize == other._rowStepSize && _columnStepSize == other._columnStepSize && _maximumEndPointGap == other._maximumEndPointGap && _onlyClosed == other._onlyClosed && _subpixelAccuracy == other._subpixelAccuracy;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CurveOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CurveOptions other = (CurveOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _extractionMode.GetHashCode() ^ _threshold.GetHashCode() ^ _filterSize.GetHashCode() ^ _minimumLength.GetHashCode() ^ _rowStepSize.GetHashCode() ^ _columnStepSize.GetHashCode() ^ _maximumEndPointGap.GetHashCode() ^ _onlyClosed.GetHashCode() ^ _subpixelAccuracy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CurveOptions: OnlyClosed=" + _onlyClosed + ", ExtractionMode=" + _extractionMode.ToString() + ", FilterSize=" + _filterSize.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a curve found by the <see cref="NationalInstruments.Vision.Analysis.Algorithms.ExtractCurves" crefType="Unqualified"/> method.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CurveReport
    {
        private Collection<PointContour> _points;
        private bool _closed;
        private double _curveLength;
        private double _minimumEdgeStrength;
        private double _maximumEdgeStrength;
        private double _averageEdgeStrength;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveReport class.
        /// </summary>

        public CurveReport()
        {
            _points = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the average of all edge strengths detected on the curve.
        /// </summary>
        /// <value>
        /// </value>

        public double AverageEdgeStrength
        {
            get { return _averageEdgeStrength; }
            set { _averageEdgeStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the highest edge strength detected on the curve.
        /// </summary>
        /// <value>
        /// </value>

        public double MaximumEdgeStrength
        {
            get { return _maximumEdgeStrength; }
            set { _maximumEdgeStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the lowest edge strength detected on the curve.
        /// </summary>
        /// <value>
        /// </value>

        public double MinimumEdgeStrength
        {
            get { return _minimumEdgeStrength; }
            set { _minimumEdgeStrength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the curve.
        /// </summary>
        /// <value>
        /// </value>

        public double CurveLength
        {
            get { return _curveLength; }
            set { _curveLength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the distance between the endpoints of the curve is less than or equal to <see cref="NationalInstruments.Vision.Analysis.CurveOptions.MaximumEndPointGap" crefType="Unqualified"/>.
        /// </summary>
        /// <value>
        /// </value>

        public bool Closed
        {
            get { return _closed; }
            set { _closed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of every point detected on the curve.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Points
        {
            get { return _points; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_points = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveReport.
        /// </summary>
        /// <param name="other">
        /// A CurveReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CurveReport other)
        {
            return other != null && Utilities.CollectionsEqual(_points, other._points) && _closed == other._closed && _curveLength == other._curveLength && _minimumEdgeStrength == other._minimumEdgeStrength && _maximumEdgeStrength == other._maximumEdgeStrength && _averageEdgeStrength == other._averageEdgeStrength;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CurveReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CurveReport other = (CurveReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _points.Count.GetHashCode() ^ _closed.GetHashCode() ^ _curveLength.GetHashCode() ^ _minimumEdgeStrength.GetHashCode() ^ _maximumEdgeStrength.GetHashCode() ^ _averageEdgeStrength.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CurveReport: Closed=" + _closed.ToString() + ", CurveLength=" + _curveLength.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about the linear averages of an image.
    /// </summary>

    [Serializable]
    public sealed class LinearAveragesReport
    {
        private Collection<double> _columnAverages;
        private Collection<double> _rowAverages;
        private Collection<double> _risingDiagonalAverages;
        private Collection<double> _fallingDiagonalAverages;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LinearAveragesReport class.
        /// </summary>

        public LinearAveragesReport()
        {
            _columnAverages = new Collection<double>();
            _rowAverages = new Collection<double>();
            _risingDiagonalAverages = new Collection<double>();
            _fallingDiagonalAverages = new Collection<double>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection containing the mean pixel value of each diagonal running from the upper left to the lower right of the inspected area of the image. 
        /// </summary>

        public Collection<double> FallingDiagonalAverages
        {
            get { return _fallingDiagonalAverages; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_fallingDiagonalAverages = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection containing the mean pixel value of each diagonal running from the lower left to the upper right of the inspected area of the image. 
        /// </summary>

        public Collection<double> RisingDiagonalAverages
        {
            get { return _risingDiagonalAverages; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_risingDiagonalAverages = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection containing the mean pixel value of each row. 
        /// </summary>

        public Collection<double> RowAverages
        {
            get { return _rowAverages; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_rowAverages = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection containing the mean pixel value of each column.
        /// </summary>

        public Collection<double> ColumnAverages
        {
            get { return _columnAverages; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_columnAverages = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LinearAveragesReport.
        /// </summary>
        /// <param name="other">
        /// A LinearAveragesReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LinearAveragesReport other)
        {
            return other != null && Utilities.CollectionsEqual(_columnAverages, other._columnAverages) && Utilities.CollectionsEqual(_rowAverages, other._rowAverages) && Utilities.CollectionsEqual(_risingDiagonalAverages, other._risingDiagonalAverages) && Utilities.CollectionsEqual(_fallingDiagonalAverages, other._fallingDiagonalAverages);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LinearAveragesReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LinearAveragesReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LinearAveragesReport other = (LinearAveragesReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _columnAverages.Count.GetHashCode() ^ _rowAverages.Count.GetHashCode() ^ _risingDiagonalAverages.Count.GetHashCode() ^ _fallingDiagonalAverages.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LinearAveragesReport: RowAverages=" + _rowAverages.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains quantification data relative to a region within the image passed to the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.Quantify" crefType="Unqualified"/> method.
    /// </summary>

    [Serializable]
    public sealed class QuantifyReportItem
    {
        private double _mean;
        private double _standardDeviation;
        private Range _pixelRange;
        private double _calibratedArea;
        private Int32 _pixelArea;
        private double _relativeSize;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QuantifyReportItem class.
        /// </summary>

        public QuantifyReportItem()
        {
            _pixelRange = new Range();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the proportion, expressed as a percentage, of the associated region relative to the whole image. 
        /// </summary>

        public double RelativeSize
        {
            get { return _relativeSize; }
            set { _relativeSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the analyzed surface area in pixel values.
        /// </summary>

        public Int32 PixelArea
        {
            get { return _pixelArea; }
            set { _pixelArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the analyzed surface area in real-world values.
        /// </summary>

        public double CalibratedArea
        {
            get { return _calibratedArea; }
            set { _calibratedArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of pixel values.
        /// </summary>

        public Range PixelRange
        {
            get { return _pixelRange; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the standard deviation of the pixel values. Pixel values are distributed more evenly as 
        /// the standard deviation increases.
        /// </summary>

        public double StandardDeviation
        {
            get { return _standardDeviation; }
            set { _standardDeviation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the mean of the pixel values.
        /// </summary>

        public double Mean
        {
            get { return _mean; }
            set { _mean = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QuantifyReportItem.
        /// </summary>
        /// <param name="other">
        /// A QuantifyReportItem instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QuantifyReportItem other)
        {
            return other != null && _mean == other._mean && _standardDeviation == other._standardDeviation && Object.Equals(_pixelRange, other._pixelRange) && _calibratedArea == other._calibratedArea && _pixelArea == other._pixelArea && _relativeSize == other._relativeSize;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QuantifyReportItem.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QuantifyReportItem
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QuantifyReportItem other = (QuantifyReportItem)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _mean.GetHashCode() ^ _standardDeviation.GetHashCode() ^ _pixelRange.GetHashCode() ^ _calibratedArea.GetHashCode() ^ _pixelArea.GetHashCode() ^ _relativeSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QuantifyReportItem: Mean=" + _mean.ToString(CultureInfo.CurrentCulture) + ", StandardDeviation=" + _standardDeviation.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// A collection of 
    /// <see cref="NationalInstruments.Vision.Analysis.QuantifyReportItem" crefType="Unqualified"/> 
    /// objects. It contains one item for each region supplied to the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.Quantify" crefType="Unqualified"/> method.
    /// </summary>

    [Serializable]
    public sealed class QuantifyReport
    {
        private QuantifyReportItem _global;
        private Collection<QuantifyReportItem> _regions;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the QuantifyReport class.
        /// </summary>

        public QuantifyReport()
        {
            _global = new QuantifyReportItem();
            _regions = new Collection<QuantifyReportItem>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of QuantifyReportItem structures containing statistical data about 
        /// each region of the image. Refer to the mask parameter of the 
        /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.Quantify" crefType="Unqualified"/> method 
        /// for more information about the regions. 
        /// </summary>

        public Collection<QuantifyReportItem> Regions
        {
            get { return _regions; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_regions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets statistical data about the whole image. 
        /// </summary>

        public QuantifyReportItem Global
        {
            get { return _global; }
            set { if (value == null) { throw new ArgumentNullException("value"); }_global = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QuantifyReport.
        /// </summary>
        /// <param name="other">
        /// A QuantifyReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(QuantifyReport other)
        {
            return other != null && Object.Equals(_global, other._global) && Utilities.CollectionsEqual(_regions, other._regions);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified QuantifyReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of QuantifyReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            QuantifyReport other = (QuantifyReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _global.GetHashCode() ^ _regions.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "QuantifyReport: Global=" + _global.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a mask to ROI transformation.
    /// </summary>

    public sealed class MaskToRoiReport
    {
        private Roi _roi;
        private bool _withinLimit;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaskToRoiReport class.
        /// </summary>

        public MaskToRoiReport()
        {
            _roi = null;
            _withinLimit = false;
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaskToRoiReport class.
        /// </summary>
        /// <param name="roi">
        /// The ROI descriptor.
        /// </param>
        /// <param name="withinLimit">
        /// Specifies whether the ROI is a true representation of the mask. If <see langword="true"/>, 
        /// the number of points is within the maximum point limit. If <see langword="false"/>, the number 
        /// of points exceeds the maximum point limit, and the ROI may not represent the mask completely. 
        /// </param>

        public MaskToRoiReport(Roi roi, bool withinLimit)
        {
            _roi = roi;
            _withinLimit = withinLimit;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the ROI is a true representation of the mask. If <see langword="true"/>, 
        /// the number of points is within the maximum point limit. If <see langword="false"/>, the number 
        /// of points exceeds the maximum point limit, and the ROI may not represent the mask completely. 
        /// </summary>

        public bool WithinLimit
        {
            get { return _withinLimit; }
            set { _withinLimit = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the ROI descriptor.
        /// </summary>

        public Roi Roi
        {
            get { return _roi; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _roi = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MaskToRoiReport.
        /// </summary>
        /// <param name="other">
        /// A MaskToRoiReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MaskToRoiReport other)
        {
            return other != null && Object.Equals(_roi, other._roi) && _withinLimit == other._withinLimit;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MaskToRoiReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MaskToRoiReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MaskToRoiReport other = (MaskToRoiReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _roi.GetHashCode() ^ _withinLimit.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MaskToRoiReport: Roi=" + ((_roi != null) ? _roi.ToString() : "");
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about the points along the edge of each contour in the region of interest (ROI).
    /// </summary>

    [Serializable]
    public sealed class RoiProfileReport
    {
        private LineProfileReport _report;
        private Collection<PointContour> _pixels;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RoiProfileReport class.
        /// </summary>

        public RoiProfileReport()
        {
            _report = new LineProfileReport();
            _pixels = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the points along the edge of each contour in the ROI.
        /// </summary>

        public Collection<PointContour> Pixels
        {
            get { return _pixels; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_pixels = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets quantifying information about the points along the edge of each contour in the ROI. 
        /// </summary>

        public LineProfileReport Report
        {
            get { return _report; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _report = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RoiProfileReport.
        /// </summary>
        /// <param name="other">
        /// An RoiProfileReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RoiProfileReport other)
        {
            return other != null && Object.Equals(_report, other._report) && Utilities.CollectionsEqual(_pixels, other._pixels);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RoiProfileReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RoiProfileReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RoiProfileReport other = (RoiProfileReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _report.GetHashCode() ^ _pixels.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RoiProfileReport: Report=" + _report.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies how to convert an image to a three-dimensional representation.
    /// </summary>

    [Serializable]
    public sealed class View3DOptions
    {
        private Int32 _sizeReduction;
        private Int32 _maximumHeight;
        private Direction3D _direction;
        private double _alpha;
        private double _beta;
        private Int32 _border;
        private byte _background;
        private Plane3D _plane;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the View3DOptions class.
        /// </summary>

        public View3DOptions() :
            this (Direction3D.NorthWest)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the View3DOptions class.
        /// </summary>
        /// <param name="direction">
        /// Defines the 3D orientation. 
        /// </param>

        public View3DOptions(Direction3D direction) :
            this (direction, 2)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the View3DOptions class.
        /// </summary>
        /// <param name="direction">
        /// Defines the 3D orientation. 
        /// </param>
        /// <param name="sizeReduction">
        /// A divisor the function uses when determining the final height and width of the 3D image. The function coerces the 
        /// value if it is negative or greater then one-eighth the height or width of the original image. 
        /// </param>

        public View3DOptions(Direction3D direction, Int32 sizeReduction) :
            this (direction, sizeReduction, 64)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the View3DOptions class.
        /// </summary>
        /// <param name="direction">
        /// Defines the 3D orientation. 
        /// </param>
        /// <param name="sizeReduction">
        /// A divisor the function uses when determining the final height and width of the 3D image. The function coerces the 
        /// value if it is negative or greater then one-eighth the height or width of the original image. 
        /// </param>
        /// <param name="maximumHeight">
        /// Defines the maximum height of a pixel from the image source drawn in 3D. Valid values range from 2 to 256. 
        /// </param>

        public View3DOptions(Direction3D direction, Int32 sizeReduction, Int32 maximumHeight)
        {
            _direction = direction;
            _sizeReduction = sizeReduction;
            _maximumHeight = maximumHeight;
            _alpha = 30;
            _beta = 30;
            _border = 20;
            _background = 85;
            _plane = Plane3D.Magnitude;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the view a function uses to show complex images. 
        /// </summary>
        /// <value>
        /// The default is Magnitude.
        /// </value>

        public Plane3D Plane
        {
            get { return _plane; }
            set { _plane = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the background color. 
        /// </summary>
        /// <value>
        /// The default is 85.
        /// </value>

        public byte Background
        {
            get { return _background; }
            set { _background = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the border size. 
        /// </summary>
        /// <value>
        /// The default is 20.
        /// </value>

        public Int32 Border
        {
            get { return _border; }
            set { _border = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle between the horizontal and the second baseline. 
        /// </summary>
        /// <value>
        /// The default is 30.
        /// </value>
        /// <remarks>
        /// Valid values range from 15 to 45. 
        /// </remarks>

        public double Beta
        {
            get { return _beta; }
            set { _beta = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle between the horizontal and the baseline. 
        /// </summary>
        /// <value>
        /// The default is 30.
        /// </value>
        /// <remarks>
        /// Valid values range from 15 to 45 degrees.
        /// </remarks>

        public double Alpha
        {
            get { return _alpha; }
            set { _alpha = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the 3D orientation. 
        /// </summary>
        /// <value>
        /// The default is NorthWest.
        /// </value>

        public Direction3D Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum height of a pixel from the image source drawn in 3D. 
        /// </summary>
        /// <value>
        /// The default is 64.
        /// </value>
        /// <remarks>
        /// Valid values range from 2 to 256. 
        /// </remarks>

        public Int32 MaximumHeight
        {
            get { return _maximumHeight; }
            set { _maximumHeight = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a divisor the function uses when determining the final height and width of the 3D image. The function coerces the 
        /// value if it is negative or greater then one-eighth the height or width of the original image. 
        /// </summary>
        /// <value>
        /// The default is 2.
        /// </value>

        public Int32 SizeReduction
        {
            get { return _sizeReduction; }
            set { _sizeReduction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified View3DOptions.
        /// </summary>
        /// <param name="other">
        /// A View3DOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(View3DOptions other)
        {
            return other != null && _sizeReduction == other._sizeReduction && _maximumHeight == other._maximumHeight && _direction == other._direction && _alpha == other._alpha && _beta == other._beta && _border == other._border && _background == other._background && _plane == other._plane;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified View3DOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of View3DOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            View3DOptions other = (View3DOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _sizeReduction.GetHashCode() ^ _maximumHeight.GetHashCode() ^ _direction.GetHashCode() ^ _alpha.GetHashCode() ^ _beta.GetHashCode() ^ _border.GetHashCode() ^ _background.GetHashCode() ^ _plane.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "View3DOptions: Direction=" + _direction.ToString() + ", SizeReduction=" + _sizeReduction.ToString(CultureInfo.CurrentCulture) + ", MaximumHeight=" + _maximumHeight.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines the options to use when performing a BCGTransform or a ColorBCGTransform.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class BcgOptions
    {
        private double _brightness;
        private double _contrast;
        private double _gamma;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the BcgOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public BcgOptions()
            : this(128)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the BcgOptions class.
        /// </summary>
        /// <param name="brightness">The brightness of an image. 
        /// </param>

        public BcgOptions(double brightness)
            : this(brightness, 45)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the BcgOptions class.
        /// </summary>
        /// <param name="brightness">The brightness of an image. 
        /// </param>
        /// <param name="contrast">The contrast of an image. 
        /// </param>

        public BcgOptions(double brightness, double contrast)
            : this(brightness, contrast, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the BcgOptions class.
        /// </summary>
        /// <param name="brightness">The brightness of an image. 
        /// </param>
        /// <param name="contrast">The contrast of an image.
        /// </param>
        /// <param name="gamma">The gamma correction of an image. 
        /// </param>

        public BcgOptions(double brightness, double contrast, double gamma)
        {
            _brightness = brightness;
            _contrast = contrast;
            _gamma = gamma;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the gamma correction of an image. 
        /// </summary>
        /// <value>
        /// The default value is 1. 
        /// </value>
        /// <remarks>
        /// The default value of 1.0 is neutral. Values below 1.0 enhance contrast for darker pixels at the expense of brighter pixels. Values above 1.0 enhance contrast for brighter pixels at the expense of darker pixels.
        /// </remarks>

        public double Gamma
        {
            get { return _gamma; }
            set { _gamma = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the contrast of an image. 
        /// </summary>
        /// <value>
        /// The default value is 45. 
        /// </value>
        /// <remarks>
        /// The default value of 45 leaves the contrast unchanged. Values below 45 decrease the contrast, and values above 45 increase the contrast.
        /// </remarks>

        public double Contrast
        {
            get { return _contrast; }
            set { _contrast = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the brightness of an image. 
        /// </summary>
        /// <value>
        /// The default value is 128.
        /// </value>
        /// <remarks>
        /// The default value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.
        /// </remarks>

        public double Brightness
        {
            get { return _brightness; }
            set { _brightness = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified BcgOptions.
        /// </summary>
        /// <param name="other">
        /// A BcgOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(BcgOptions other)
        {
            return other != null && _brightness == other._brightness && _contrast == other._contrast && _gamma == other._gamma;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified BCGOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance.
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of BCGOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            BcgOptions other = (BcgOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _brightness.GetHashCode() ^ _contrast.GetHashCode() ^ _gamma.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "BcgOptions: Brightness=" + _brightness.ToString(CultureInfo.CurrentCulture) + ", Contrast=" + _contrast.ToString(CultureInfo.CurrentCulture) + ", Gamma=" + _gamma.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the options to use when calling FitCircle.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitCircleOptions
    {
        private bool _rejectOutliers;
        private double _minimumScore;
        private double _pixelRadius;
        private int _maximumIterations;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitCircleOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public FitCircleOptions()
            : this(3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitCircleOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the circle can be from the circumference of the circle.
        /// </param>

        public FitCircleOptions(double pixelRadius)
            : this(pixelRadius, 500)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitCircleOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the circle can be from the circumference of the circle.
        /// </param>
        /// <param name="minimumScore">The minimum score that the fitted circle can have.
        /// </param>

        public FitCircleOptions(double pixelRadius, double minimumScore)
            : this(pixelRadius, minimumScore, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitCircleOptions class.
        /// </summary>
        /// &gt;
        /// <remarks>
        /// </remarks>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the circle can be from the circumference of the circle.
        /// </param>
        /// <param name="minimumScore">The minimum score that the fitted circle can have.
        /// </param>
        /// <param name="rejectOutliers">A Boolean indicating whether the algorithm should reject outlying points.
        /// </param>

        public FitCircleOptions(double pixelRadius, double minimumScore, bool rejectOutliers)
        {
            _pixelRadius = pixelRadius;
            _minimumScore = minimumScore;
            _rejectOutliers = rejectOutliers;
            _maximumIterations = 500;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of refining steps the algorithm takes to ensure that the quality of the fit is better than MinimumScore.
        /// </summary>
        /// <value>
        /// The default is 500.
        /// </value>
        /// <remarks>
        /// This is valid only when RejectOutliers is <see langword="true"/>. 
        /// </remarks>

        public int MaximumIterations
        {
            get { return _maximumIterations; }
            set { _maximumIterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the acceptable distance, in pixels, that a point determined to belong to the circle can be from the circumference of the circle.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public double PixelRadius
        {
            get { return _pixelRadius; }
            set { _pixelRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score that the fitted circle can have.
        /// </summary>
        /// <value>
        /// The default is 500.
        /// </value>
        /// <remarks>
        /// This can vary between 0 and 1000, with 1000 representing a perfect circle. 
        /// </remarks>

        public double MinimumScore
        {
            get { return _minimumScore; }
            set { _minimumScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the algorithm should reject outlying points.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RejectOutliers
        {
            get { return _rejectOutliers; }
            set { _rejectOutliers = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitCircleOptions.
        /// </summary>
        /// <param name="other">
        /// A  FitCircleOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitCircleOptions other)
        {
            return other != null && _rejectOutliers == other._rejectOutliers && _minimumScore == other._minimumScore && _maximumIterations == other._maximumIterations && _pixelRadius == other._pixelRadius;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitCircleOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitCircleOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitCircleOptions other = (FitCircleOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rejectOutliers.GetHashCode() ^ _minimumScore.GetHashCode() ^ _maximumIterations.GetHashCode() ^ _pixelRadius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitCircleOptions: PixelRadius=" + _pixelRadius.ToString(CultureInfo.CurrentCulture) + ", MinimumScore=" + _minimumScore.ToString(CultureInfo.CurrentCulture) + ", RejectOutliers=" + _rejectOutliers.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the circle that best represents a set of points. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitCircleReport
    {
        private OvalContour _circle;
        private PointContour _center;
        private double _radius;
        private double _area;
        private double _perimeter;
        private double _error;
        private bool _valid;
        private Collection<PointContour> _pointsUsed;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitCircleReport class.
        /// </summary>

        public FitCircleReport()
        {
            _circle = new OvalContour();
            _center = new PointContour();
            _pointsUsed = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the circle detected.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        ///  This property is useful for passing directly to <see cref="NationalInstruments.Vision.Overlay.AddOval" crefType="Unqualified"/>. 
        /// </remarks>

        public OvalContour Circle
        {
            get { return _circle; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _circle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the collection of points that the algorithm used when fitting the circle.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This is valid only if RejectOutliers is <see langword="true"/>.
        /// </remarks>

        public Collection<PointContour> PointsUsed
        {
            get { return _pointsUsed; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_pointsUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the fit is valid.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This is <see langword="true"/> if the quality of the fit is better than MinScore and the fit was attained within MaxIterations. When you call FitCircle, this property is always <see langword="false"/>.
        /// </remarks>

        public bool Valid
        {
            get { return _valid; }
            set { _valid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the least square error of the fitted circle to the entire set of points. 
        /// </summary>
        /// <value>
        /// </value>

        public double Error
        {
            get { return _error; }
            set { _error = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the perimeter of the circle.
        /// </summary>
        /// <value>
        /// </value>

        public double Perimeter
        {
            get { return _perimeter; }
            set { _perimeter = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets  the area of the circle.
        /// </summary>
        /// <value>
        /// </value>

        public double Area
        {
            get { return _area; }
            set { _area = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the radius of the circle.
        /// </summary>
        /// <value>
        /// </value>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the center of the circle.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitCircleReport.
        /// </summary>
        /// <param name="other">
        /// A FitCircleReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitCircleReport other)
        {
            return other != null && Object.Equals(_circle, other._circle) && Object.Equals(_center, other._center) && _radius == other._radius && _area == other._area && _perimeter == other._perimeter && _error == other._error && _valid == other._valid && Utilities.CollectionsEqual(_pointsUsed, other._pointsUsed);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitCircleReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitCircleReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitCircleReport other = (FitCircleReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _circle.GetHashCode() ^ _center.GetHashCode() ^ _radius.GetHashCode() ^ _area.GetHashCode() ^ _perimeter.GetHashCode() ^ _error.GetHashCode() ^ _valid.GetHashCode() ^ _pointsUsed.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitCircleReport: Center=" + _center.ToString() + ", Radius=" + _radius.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines the options to use when calling FitEllipse.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitEllipseOptions
    {
        private bool _rejectOutliers;
        private double _minimumScore;
        private double _pixelRadius;
        private int _maximumIterations;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitEllipseOptions class.
        /// </summary>

        public FitEllipseOptions()
            : this(3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitEllipseOptions class.
        /// </summary>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the ellipse can be from the circumference of the ellipse.
        /// </param>

        public FitEllipseOptions(double pixelRadius)
            : this(pixelRadius, 500)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitEllipseOptions class.
        /// </summary>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the ellipse can be from the circumference of the ellipse.
        /// </param>
        /// <param name="minimumScore">The minimum score that the fitted ellipse can have.
        /// </param>

        public FitEllipseOptions(double pixelRadius, double minimumScore)
            : this(pixelRadius, minimumScore, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitEllipseOptions class.
        /// </summary>
        /// <param name="pixelRadius">The acceptable distance, in pixels, that a point determined to belong to the ellipse can be from the circumference of the ellipse.
        /// </param>
        /// <param name="minimumScore">The minimum score that the fitted ellipse can have.
        /// </param>
        /// <param name="rejectOutliers">A Boolean indicating whether the algorithm should reject outlying points.
        /// </param>

        public FitEllipseOptions(double pixelRadius, double minimumScore, bool rejectOutliers)
        {
            _pixelRadius = pixelRadius;
            _minimumScore = minimumScore;
            _rejectOutliers = rejectOutliers;
            _maximumIterations = 2000;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of refining steps the algorithm takes to ensure that the quality of the fit is better than MinimumScore.
        /// </summary>
        /// <value>
        /// The default is 2000.
        /// </value>
        /// <remarks>
        /// This is valid only when RejectOutliers is <see langword="true"/>. 
        /// </remarks>

        public int MaximumIterations
        {
            get { return _maximumIterations; }
            set { _maximumIterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the acceptable distance, in pixels, that a point determined to belong to the ellipse can be from the circumference of the ellipse.
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public double PixelRadius
        {
            get { return _pixelRadius; }
            set { _pixelRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score that the fitted ellipse can have.
        /// </summary>
        /// <value>
        /// The default is 500.
        /// </value>
        /// <remarks>
        /// This can vary between 0 and 1000, with 1000 representing a perfect ellipse.
        /// </remarks>

        public double MinimumScore
        {
            get { return _minimumScore; }
            set { _minimumScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the algorithm should reject outlying points.
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool RejectOutliers
        {
            get { return _rejectOutliers; }
            set { _rejectOutliers = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitEllipseOptions.
        /// </summary>
        /// <param name="other">
        /// A FitEllipseOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitEllipseOptions other)
        {
            return other != null && _rejectOutliers == other._rejectOutliers && _minimumScore == other._minimumScore && _maximumIterations == other._maximumIterations && _pixelRadius == other._pixelRadius;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitEllipseOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitEllipseOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitEllipseOptions other = (FitEllipseOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _rejectOutliers.GetHashCode() ^ _minimumScore.GetHashCode() ^ _maximumIterations.GetHashCode() ^ _pixelRadius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitEllipseOptions: PixelRadius=" + _pixelRadius.ToString(CultureInfo.CurrentCulture) + ", MinimumScore=" + _minimumScore.ToString(CultureInfo.CurrentCulture) + ", RejectOutliers=" + _rejectOutliers.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines the ellipse that best represents a set of points. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitEllipseReport
    {
        private PointContour _center;
        private LineContour _majorAxis;
        private LineContour _minorAxis;
        private double _area;
        private double _perimeter;
        private double _error;
        private bool _valid;
        private Collection<PointContour> _pointsUsed;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitEllipseReport class. 
        /// </summary>
        /// <remarks>
        /// You must supply at least six non-colinear points to fit to the edge of the ellipse.
        /// </remarks>

        public FitEllipseReport()
        {
            _center = new PointContour();
            _majorAxis = new LineContour();
            _minorAxis = new LineContour();
            _pointsUsed = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the collection of points that the algorithm used when fitting the circle.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This property is valid only if RejectOutliers is <see langword="true"/>.
        /// </remarks>

        public Collection<PointContour> PointsUsed
        {
            get { return _pointsUsed; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_pointsUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the fit is valid.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This is <see langword="true"/> if the quality of the fit is better than MinimumScore and the fit was attained within MaximumIterations. 
        /// </remarks>

        public bool Valid
        {
            get { return _valid; }
            set { _valid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the least square error of the fitted ellipse over every given radial point.
        /// </summary>
        /// <value>
        /// </value>

        public double Error
        {
            get { return _error; }
            set { _error = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the perimeter of the ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public double Perimeter
        {
            get { return _perimeter; }
            set { _perimeter = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the area of the ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public double Area
        {
            get { return _area; }
            set { _area = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minor axis of the ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public LineContour MinorAxis
        {
            get { return _minorAxis; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _minorAxis = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the major axis of the ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public LineContour MajorAxis
        {
            get { return _majorAxis; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _majorAxis = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the center of the ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitEllipseReport.
        /// </summary>
        /// <param name="other">
        /// A FitEllipseReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitEllipseReport other)
        {
            return other != null && Object.Equals(_center, other._center) &&  _area == other._area && _perimeter == other._perimeter && _error == other._error && _valid == other._valid && Utilities.CollectionsEqual(_pointsUsed, other._pointsUsed) && Object.Equals(_majorAxis, other._majorAxis) && Object.Equals(_minorAxis, other._minorAxis);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitEllipseReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitEllipseReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitEllipseReport other = (FitEllipseReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _area.GetHashCode() ^ _perimeter.GetHashCode() ^ _error.GetHashCode() ^ _valid.GetHashCode() ^ _pointsUsed.Count.GetHashCode() ^ _majorAxis.GetHashCode() ^ _minorAxis.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitEllipseReport: Center=" + _center.ToString() + ", MajorAxis=" + _majorAxis.ToString() + ", MinorAxis=" + _minorAxis.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how to calculate the best fit line.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitLineOptions
    {
        private double _minimumScore;
        private double _pixelRadius;
        private int _maximumIterations;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitLineOptions class.
        /// </summary>

        public FitLineOptions()
            : this(3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitLineOptions class.
        /// </summary>
        /// <param name="pixelRadius">The neighborhood pixel relationship for the initial subset of points being used. 
        /// </param>

        public FitLineOptions(double pixelRadius)
            : this(pixelRadius, 900)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitLineOptions class.
        /// </summary>
        /// <param name="pixelRadius">The neighborhood pixel relationship for the initial subset of points being used. 
        /// </param>
        /// <param name="minimumScore">The required quality of the fitted line. 
        /// </param>

        public FitLineOptions(double pixelRadius, double minimumScore)
        {
            _pixelRadius = pixelRadius;
            _minimumScore = minimumScore;
            _maximumIterations = 0;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of refinement iterations you allow the function to perform on the initial subset of points. 
        /// </summary>
        /// <value>The default value is 0.
        /// </value>
        /// <remarks>
        /// You must allow at least one iteration. If this property is set to 0, the method will perform the number of points -2 refinement iterations.
        /// </remarks>

        public int MaximumIterations
        {
            get { return _maximumIterations; }
            set { _maximumIterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the neighborhood pixel relationship for the initial subset of points being used. 
        /// </summary>
        /// <value>The default value is 3.0.
        /// </value>
        /// <remarks>
        /// During refinement iterations the function ignores points that are farther from the line than <paramref name="PixelRadius"/>. 
        /// </remarks>

        public double PixelRadius
        {
            get { return _pixelRadius; }
            set { _pixelRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the required quality of the fitted line. 
        /// </summary>
        /// <value>The default value is 900.0.
        /// </value>
        /// <remarks>
        /// Acceptable values range from 0 to 1,000. A score of 1,000 indicates a perfect fit. 
        /// </remarks>

        public double MinimumScore
        {
            get { return _minimumScore; }
            set { _minimumScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitLineOptions.
        /// </summary>
        /// <param name="other">
        /// A FitLineOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitLineOptions other)
        {
            return other != null && _minimumScore == other._minimumScore && _maximumIterations == other._maximumIterations && _pixelRadius == other._pixelRadius;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitLineOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitLineOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitLineOptions other = (FitLineOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _minimumScore.GetHashCode() ^ _maximumIterations.GetHashCode() ^ _pixelRadius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitLineOptions: PixelRadius=" + _pixelRadius.ToString(CultureInfo.CurrentCulture) + ", MinimumScore=" + _minimumScore.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines the three coefficients of the equation in the normal form (ax+by+c=0) of a line.
    /// </summary>

    [Serializable]
    public sealed class LineEquation
    {
        private double _a;
        private double _b;
        private double _c;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineEquation class.
        /// </summary>

        public LineEquation()
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the c coefficient of the line equation. 
        /// </summary>

        public double C
        {
            get { return _c; }
            set { _c = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the b coefficient of the line equation. 
        /// </summary>

        public double B
        {
            get { return _b; }
            set { _b = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the a coefficient of the line equation. 
        /// </summary>

        public double A
        {
            get { return _a; }
            set { _a = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineEquation.
        /// </summary>
        /// <param name="other">
        /// A LineEquation instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LineEquation other)
        {
            return other != null && _a == other._a && _b == other._b && _c == other._c;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineEquation.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LineEquation
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LineEquation other = (LineEquation)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _a.GetHashCode() ^ _b.GetHashCode() ^ _c.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LineEquation: " + _a.ToString(CultureInfo.CurrentCulture) + "*x + " + _b.ToString(CultureInfo.CurrentCulture) + "*y + " + _c.ToString(CultureInfo.CurrentCulture) + " = 0";
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the line best representing a set of points.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FitLineReport
    {
        private LineContour _lineSegment;
        private LineEquation _equation;
        private bool _valid;
        private double _error;
        private Collection<PointContour> _pointsUsed;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FitLineReport class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public FitLineReport()
        {
            _lineSegment = new LineContour();
            _equation = new LineEquation();
            _pointsUsed = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array returning a subset of the points passed to FitLine that were used to fit the line. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// Some points may be excluded based on the MinimumScore specified.
        /// </remarks>

        public Collection<PointContour> PointsUsed
        {
            get { return _pointsUsed; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_pointsUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the least-square error of the fitted line to the entire set of points.
        /// </summary>
        /// <value>
        /// </value>

        public double Error
        {
            get { return _error; }
            set { _error = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the MinimumScore was attained within the given MaximumIterations.
        /// </summary>
        /// <value>
        /// </value>

        public bool Valid
        {
            get { return _valid; }
            set { _valid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the equation of the best line. 
        /// </summary>
        /// <value>
        /// </value>

        public LineEquation Equation
        {
            get { return _equation; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _equation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the line that represents the intersection of the line equation and the bounding rectangle of the input points.
        /// </summary>
        /// <value>
        /// </value>

        public LineContour LineSegment
        {
            get { return _lineSegment; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _lineSegment = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitLineReport.
        /// </summary>
        /// <param name="other">
        /// A FitLineReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FitLineReport other)
        {
            return other != null && Object.Equals(_lineSegment, other._lineSegment) && Object.Equals(_equation, other._equation) && _valid == other._valid && _error == other._error && Object.Equals(_pointsUsed, other._pointsUsed);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FitLineReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FitLineReport and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FitLineReport other = (FitLineReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _lineSegment.GetHashCode() ^ _equation.GetHashCode() ^ _error.GetHashCode() ^ _valid.GetHashCode() ^ _pointsUsed.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FitLineReport: LineSegment=" + _lineSegment.ToString() + ", Equation=" + _equation.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a point along an edge segment.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ContourPoint
    {
        private PointContour _point;
        private double _curvature;
        private double _xDisplacement;
        private double _yDisplacement;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourPoint class.
        /// </summary>

        public ContourPoint()
        {
            _point = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the y displacement of the current edge pixel from a cubic spline fit of the current edge segment. 
        /// </summary>
        /// <value>
        /// </value>

        public double YDisplacement
        {
            get { return _yDisplacement; }
            set { _yDisplacement = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the x displacement of the current edge pixel from a cubic spline fit of the current edge segment.
        /// </summary>
        /// <value>
        /// </value>

        public double XDisplacement
        {
            get { return _xDisplacement; }
            set { _xDisplacement = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the change in slope at this edge point of the segment. 
        /// </summary>
        /// <value>
        /// </value>

        public double Curvature
        {
            get { return _curvature; }
            set { _curvature = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the value of the coordinate point in the image. 
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Point
        {
            get { return _point; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _point = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourPoint.
        /// </summary>
        /// <param name="other">
        /// A ContourPoint instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourPoint other)
        {
            return other != null && Object.Equals(_point, other._point) && _curvature == other._curvature && _xDisplacement == other._xDisplacement && _yDisplacement == other._yDisplacement;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourPoint.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourPoint and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourPoint other = (ContourPoint)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _point.GetHashCode() ^ _curvature.GetHashCode() ^ _xDisplacement.GetHashCode() ^ _yDisplacement.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourPoint: Point=" + _point.ToString() + ", Curvature=" + _curvature.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains information about a segment.
    /// </summary>

    [Serializable]
    public sealed class SegmentReport
    {
        private Collection<ContourPoint> _points;
        private bool _isOpen;
        private double _weight;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SegmentReport class.
        /// </summary>

        public SegmentReport()
        {
            _points = new Collection<ContourPoint>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the significance of the edge in terms of the gray values that constitute the edge. 
        /// </summary>

        public double Weight
        {
            get { return _weight; }
            set { _weight = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether a segment is open. When <see langword="true"/>, 
        /// the segment is open. When <see langword="false"/>, the segment is closed. 
        /// </summary>

        public bool IsOpen
        {
            get { return _isOpen; }
            set { _isOpen = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the points in the segment.
        /// </summary>

        public Collection<ContourPoint> Points
        {
            get { return _points; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_points = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SegmentReport.
        /// </summary>
        /// <param name="other">
        /// A SegmentReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SegmentReport other)
        {
            return other != null && Object.Equals(_points, other._points) && _isOpen == other._isOpen && _weight == other._weight;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SegmentReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SegmentReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SegmentReport other = (SegmentReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _points.Count.GetHashCode() ^ _isOpen.GetHashCode() ^ _weight.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SegmentReport: Points=" + _points.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the location, amplitude, and second derivative of peaks or valleys in the input array. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DetectPeaksOrValleysOptions
    {
        private double _threshold;
        private int _width;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DetectPeaksOrValleysOptions class.
        /// </summary>

        public DetectPeaksOrValleysOptions()
            : this(3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DetectPeaksOrValleysOptions class.
        /// </summary>
        /// <param name="width">
        /// The number of consecutive data points to use in the quadratic least-squares fit. The value must be greater than or equal to 3 but should be no larger than one-quarter of the approximate width of the peaks or valleys. Large widths may reduce the apparent amplitude and shift the apparent location of peaks.
        /// This parameter has a default value of 3.
        /// </param>

        public DetectPeaksOrValleysOptions(int width)
            : this(width, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DetectPeaksOrValleysOptions class.
        /// </summary>
        /// <param name="width">
        /// The number of consecutive data points to use in the quadratic least-squares fit. The value must be greater than or equal to 3 but should be no larger than one-quarter of the approximate width of the peaks or valleys. Large widths may reduce the apparent amplitude and shift the apparent location of peaks.
        /// This parameter has a default value of 3.
        /// </param>
        /// <param name="threshold">
        /// Rejects peaks or valleys that are too small. Any peak found with a fitted amplitude that is less than threshold is ignored. Valleys are ignored if the fitted trough is greater than threshold.
        /// This parameter has a default value of 0.
        /// </param>

        public DetectPeaksOrValleysOptions(int width, double threshold)
        {
            _threshold = threshold;
            _width = width;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of consecutive data points to use in the quadratic least-squares fit. 
        /// </summary>
        /// <value>
        /// The default value is 3.
        /// </value>
        /// <remarks>
        /// The property value must be greater than or equal to 3 but should be no larger than one-quarter of the approximate width of the peaks or valleys. Large widths may reduce the apparent amplitude and shift the apparent location of peaks.
        /// </remarks>

        public int Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the fitted amplitude of peaks and valleys.
        /// </summary>
        /// <value>
        /// The default value is 0.0.
        /// </value>
        /// <remarks>
        /// Rejects peaks or valleys that are too small. Any peak found with a fitted amplitude that is less than Threshold is ignored. Valleys are ignored if the fitted trough is greater than Threshold.
        /// </remarks>

        public double Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DetectPeaksOrValleysOptions.
        /// </summary>
        /// <param name="other">
        /// A DetectPeaksOrValleysOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DetectPeaksOrValleysOptions other)
        {
            return other != null && _width == other._width && _threshold == other._threshold;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DetectPeaksOrValleysOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DetectPeaksOrValleysOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DetectPeaksOrValleysOptions other = (DetectPeaksOrValleysOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _width.GetHashCode() ^ _threshold.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DetectPeaksOrValleysOptions: Width=" + _width.ToString(CultureInfo.CurrentCulture) + ", Threshold=" + _threshold.ToString(CultureInfo.CurrentCulture);
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides information about a particular peak or valley.
    /// </summary>

    [Serializable]
    public sealed class PeakValleyReportItem
    {
        private double _location;
        private double _amplitude;
        private double _secondDerivative;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PeakValleyReportItem class.
        /// </summary>

        public PeakValleyReportItem()
        {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the second derivative of a peak or valley.
        /// </summary>

        public double SecondDerivative
        {
            get { return _secondDerivative; }
            set { _secondDerivative = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the amplitude of a peak or valley.
        /// </summary>

        public double Amplitude
        {
            get { return _amplitude; }
            set { _amplitude = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the peak or valley found in the current block of data. Locations 
        /// are reported in indices from the beginning of processing.
        /// </summary>

        public double Location
        {
            get { return _location; }
            set { _location = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PeakValleyReportItem.
        /// </summary>
        /// <param name="other">
        /// A PeakValleyReportItem instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PeakValleyReportItem other)
        {
            return other != null && _location == other._location && _amplitude == other._amplitude && _secondDerivative == other._secondDerivative;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PeakValleyReportItem.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PeakValleyReportItem
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PeakValleyReportItem other = (PeakValleyReportItem)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _location.GetHashCode() ^ _amplitude.GetHashCode() ^ _secondDerivative.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PeakValleyReportItem: Location=" + _location.ToString(CultureInfo.CurrentCulture) + ", Amplitude=" + _amplitude.ToString(CultureInfo.CurrentCulture);
        }
    }
    //==============================================================================================
    /// <summary>
    /// Describes how you want to search for edges and the information the function overlays to the image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindEdgeOptions
    {
        private RakeDirection _direction;
        private bool _showSearchArea;
        private bool _showSearchLines;
        private bool _showEdgesFound;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _searchLinesColor;
        private Rgb32Value _searchEdgesColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        private EdgeOptions _edgeOptions;
        private StraightEdgeOptions _straightEdgeOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>

        public FindEdgeOptions()
            : this(RakeDirection.LeftToRight)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>

        public FindEdgeOptions(RakeDirection direction)
            : this(direction, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>

        public FindEdgeOptions(RakeDirection direction, bool showSearchArea)
            : this(direction, showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>

        public FindEdgeOptions(RakeDirection direction, bool showSearchArea, bool showSearchLines)
            : this(direction, showSearchArea, showSearchLines, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>

        public FindEdgeOptions(RakeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound)
            : this(direction, showSearchArea, showSearchLines, showEdgesFound, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>
        /// <param name="showResult">A Boolean indicating whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </param>

        public FindEdgeOptions(RakeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound, bool showResult)
        {
            _direction = direction;
            _showSearchArea = showSearchArea;
            _showSearchLines = showSearchLines;
            _showEdgesFound = showEdgesFound;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.GreenColor;
            _searchLinesColor = Rgb32Value.BlueColor;
            _searchEdgesColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
            _edgeOptions = new EdgeOptions();
            _straightEdgeOptions = new StraightEdgeOptions();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to fit a line in the ROI.
        /// </summary>
        /// <value>
        /// </value>

        public StraightEdgeOptions StraightEdgeOptions
        {
            get { return _straightEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _straightEdgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the edge detection options along a single search line. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions EdgeOptions
        {
            get { return _edgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. 
        /// </summary>
        /// <value>
        /// The default value is blank.
        /// Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </value>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default value is R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search edges. 
        /// </summary>
        /// <value>The default value is R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchEdgesColor
        {
            get { return _searchEdgesColor; }
            set { _searchEdgesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search lines. 
        /// </summary>
        /// <value>The default value is R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value SearchLinesColor
        {
            get { return _searchLinesColor; }
            set { _searchLinesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default value is R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the locations of the edges found on the image.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>If <see langword="true"/>, the function overlays the locations of the edges found on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowEdgesFound
        {
            get { return _showEdgesFound; }
            set { _showEdgesFound = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search lines used to locate the edges on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchLines
        {
            get { return _showSearchLines; }
            set { _showSearchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the direction to search in the ROI. 
        /// </summary>
        /// <value>The default value is LeftToRight.
        /// </value>

        public RakeDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindEdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A FindEdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindEdgeOptions other)
        {
            return other != null && _direction == other._direction && _showSearchArea == other._showSearchArea && _showSearchLines == other._showSearchLines && _showEdgesFound == other._showEdgesFound && _showResult == other._showResult && _searchAreaColor == other._searchAreaColor && _searchLinesColor == other._searchLinesColor && _searchEdgesColor == other._searchEdgesColor && _resultColor == other._resultColor && _overlayGroupName == other._overlayGroupName;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindEdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindEdgeOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindEdgeOptions other = (FindEdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _direction.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showSearchLines.GetHashCode() ^ _showEdgesFound.GetHashCode() ^ _showResult.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _searchLinesColor.GetHashCode() ^ _searchEdgesColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _overlayGroupName.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindEdgeOptions: Direction=" + _direction.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how you want to search for Circular edges and the information the function
    /// overlays to the image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindCircularEdgeOptions
    {
        private SpokeDirection _direction;
        private bool _showSearchArea;
        private bool _showSearchLines;
        private bool _showEdgesFound;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _searchLinesColor;
        private Rgb32Value _searchEdgesColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        private EdgeOptions _edgeOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>

        public FindCircularEdgeOptions()
            : this(SpokeDirection.OutsideToInside)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>

        public FindCircularEdgeOptions(SpokeDirection direction)
            : this(direction, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>

        public FindCircularEdgeOptions(SpokeDirection direction, bool showSearchArea)
            : this(direction, showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>

        public FindCircularEdgeOptions(SpokeDirection direction, bool showSearchArea, bool showSearchLines)
            : this(direction, showSearchArea, showSearchLines, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>

        public FindCircularEdgeOptions(SpokeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound)
            : this(direction, showSearchArea, showSearchLines, showEdgesFound, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>
        /// <param name="showResult">A Boolean indicating whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </param>

        public FindCircularEdgeOptions(SpokeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound, bool showResult)
        {
            _direction = direction;
            _showSearchArea = showSearchArea;
            _showSearchLines = showSearchLines;
            _showEdgesFound = showEdgesFound;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.GreenColor;
            _searchLinesColor = Rgb32Value.BlueColor;
            _searchEdgesColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
            _edgeOptions = new EdgeOptions();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the edge detection options along a single search line. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions EdgeOptions
        {
            get { return _edgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. 
        /// </summary>
        /// <value>
        /// The default value is blank.
        /// Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </value>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default value is R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search edges. 
        /// </summary>
        /// <value>The default value is R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchEdgesColor
        {
            get { return _searchEdgesColor; }
            set { _searchEdgesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search lines. 
        /// </summary>
        /// <value>The default value is R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value SearchLinesColor
        {
            get { return _searchLinesColor; }
            set { _searchLinesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default value is R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the locations of the edges found on the image.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>If <see langword="true"/>, the function overlays the locations of the edges found on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowEdgesFound
        {
            get { return _showEdgesFound; }
            set { _showEdgesFound = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search lines used to locate the edges on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchLines
        {
            get { return _showSearchLines; }
            set { _showSearchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the direction to search in the ROI. 
        /// </summary>
        /// <value>The default value is LeftToRight.
        /// </value>

        public SpokeDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindCircularEdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A FindCircularEdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindCircularEdgeOptions other)
        {
            return other != null && _direction == other._direction && _showSearchArea == other._showSearchArea && _showSearchLines == other._showSearchLines && _showEdgesFound == other._showEdgesFound && _showResult == other._showResult && _searchAreaColor == other._searchAreaColor && _searchLinesColor == other._searchLinesColor && _searchEdgesColor == other._searchEdgesColor && _resultColor == other._resultColor && _overlayGroupName == other._overlayGroupName;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindCircularEdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindCircularEdgeOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindCircularEdgeOptions other = (FindCircularEdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _direction.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showSearchLines.GetHashCode() ^ _showEdgesFound.GetHashCode() ^ _showResult.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _searchLinesColor.GetHashCode() ^ _searchEdgesColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _overlayGroupName.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindCircularEdgeOptions: Direction = " + _direction.ToString();
        }

    }

    //==============================================================================================
    /// <summary>
    /// Describes how you want to search for edges and the information the function
    /// overlays to the image using Annulus ROI.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindConcentricEdgeOptions
    {
        private ConcentricRakeDirection _direction;
        private bool _showSearchArea;
        private bool _showSearchLines;
        private bool _showEdgesFound;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _searchLinesColor;
        private Rgb32Value _searchEdgesColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        private EdgeOptions _edgeOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>

        public FindConcentricEdgeOptions()
            : this(ConcentricRakeDirection.CounterClockwise)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>

        public FindConcentricEdgeOptions(ConcentricRakeDirection direction)
            : this(direction, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>

        public FindConcentricEdgeOptions(ConcentricRakeDirection direction, bool showSearchArea)
            : this(direction, showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>

        public FindConcentricEdgeOptions(ConcentricRakeDirection direction, bool showSearchArea, bool showSearchLines)
            : this(direction, showSearchArea, showSearchLines, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>

        public FindConcentricEdgeOptions(ConcentricRakeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound)
            : this(direction, showSearchArea, showSearchLines, showEdgesFound, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindConcentricEdgeOptions class.
        /// </summary>
        /// <param name="direction">The direction to search in the ROI. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the function overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the function overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the function overlays the locations of the edges found on the image.
        /// </param>
        /// <param name="showResult">A Boolean indicating whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </param>

        public FindConcentricEdgeOptions(ConcentricRakeDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound, bool showResult)
        {
            _direction = direction;
            _showSearchArea = showSearchArea;
            _showSearchLines = showSearchLines;
            _showEdgesFound = showEdgesFound;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.GreenColor;
            _searchLinesColor = Rgb32Value.BlueColor;
            _searchEdgesColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
            _edgeOptions = new EdgeOptions();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the edge detection options along a single search line. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions EdgeOptions
        {
            get { return _edgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. 
        /// </summary>
        /// <value>
        /// The default value is blank.
        /// Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </value>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default value is R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search edges. 
        /// </summary>
        /// <value>The default value is R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchEdgesColor
        {
            get { return _searchEdgesColor; }
            set { _searchEdgesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search lines. 
        /// </summary>
        /// <value>The default value is R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value SearchLinesColor
        {
            get { return _searchLinesColor; }
            set { _searchLinesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default value is R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the locations of the edges found on the image.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>If <see langword="true"/>, the function overlays the locations of the edges found on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowEdgesFound
        {
            get { return _showEdgesFound; }
            set { _showEdgesFound = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search lines used to locate the edges on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchLines
        {
            get { return _showSearchLines; }
            set { _showSearchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the direction to search in the ROI. 
        /// </summary>
        /// <value>The default value is Counter Clockwise.
        /// </value>

        public ConcentricRakeDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindConcentricEdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A FindConcentricEdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindConcentricEdgeOptions other)
        {
            return other != null && _direction == other._direction && _showSearchArea == other._showSearchArea && _showSearchLines == other._showSearchLines && _showEdgesFound == other._showEdgesFound && _showResult == other._showResult && _searchAreaColor == other._searchAreaColor && _searchLinesColor == other._searchLinesColor && _searchEdgesColor == other._searchEdgesColor && _resultColor == other._resultColor && _overlayGroupName == other._overlayGroupName;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindConcentricEdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindConcentricEdgeOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindConcentricEdgeOptions other = (FindConcentricEdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _direction.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showSearchLines.GetHashCode() ^ _showEdgesFound.GetHashCode() ^ _showResult.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _searchLinesColor.GetHashCode() ^ _searchEdgesColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _overlayGroupName.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindConcentricEdgeOptions: Direction = " + _direction.ToString();
        }

    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options used to detect Circular edges.
    /// </summary>

    [Serializable]
    public sealed class CircularEdgeFitOptions
    {
        private UInt32 _maxPixelRadius;
        private double _stepSize;
        private RakeProcessType _processType;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CircularEdgeFitOptions class.
        /// </summary>

        public CircularEdgeFitOptions()
            : this(RakeProcessType.GetFirstEdges)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CircularEdgeFitOptions class.
        /// </summary>
        /// <param name="processType">
        /// Specifies the Rake Process type to to find the edge.
        /// </param>

        public CircularEdgeFitOptions(RakeProcessType processType)
        {
            _processType = processType;
            _stepSize = 3;
            _maxPixelRadius = 3;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets processType
        /// </summary>
        /// <value>
        /// The default is GetFirstEdges.
        /// </value>

        public RakeProcessType ProcessType
        {
            get { return _processType; }
            set { _processType = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets maxPixelRadius
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public UInt32 MaxPixelRadius
        {
            get { return _maxPixelRadius; }
            set { _maxPixelRadius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets stepSize
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public double StepSize
        {
            get { return _stepSize; }
            set { _stepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircularEdgeFitOptions.
        /// </summary>
        /// <param name="other">
        /// A CircularEdgeFitOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CircularEdgeFitOptions other)
        {
            return other != null && _stepSize == other._stepSize && _maxPixelRadius == other._maxPixelRadius && _processType == other._processType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircularEdgeFitOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CircularEdgeFitOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CircularEdgeFitOptions other = (CircularEdgeFitOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _processType.GetHashCode() ^ _maxPixelRadius.GetHashCode() ^ _stepSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CircularEdgeFitOptions: MaxPixelRadius=" + _maxPixelRadius + ", StepSize=" + _stepSize + ", RakeProcessType=" + _processType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options used to detect Straight edges using Annulus ROI.
    /// </summary>

    [Serializable]
    public sealed class ConcentricEdgeFitOptions
    {
        private UInt32 _maxPixelRadius;
        private double _stepSize;
        private RakeProcessType _processType;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConcentricEdgeFitOptions class.
        /// </summary>

        public ConcentricEdgeFitOptions()
            : this(RakeProcessType.GetFirstEdges)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConcentricEdgeFitOptions class.
        /// </summary>
        /// <param name="processType">
        /// Specifies the Rake Process type to to find the edge.
        /// </param>

        public ConcentricEdgeFitOptions(RakeProcessType processType)
        {
            _processType = processType;
            _stepSize = 3;
            _maxPixelRadius = 3;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets processType
        /// </summary>
        /// <value>
        /// The default is GetFirstEdges.
        /// </value>

        public RakeProcessType ProcessType
        {
            get { return _processType; }
            set { _processType = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets maxPixelRadius
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public UInt32 MaxPixelRadius
        {
            get { return _maxPixelRadius; }
            set { _maxPixelRadius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets stepSize
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public double StepSize
        {
            get { return _stepSize; }
            set { _stepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConcentricEdgeFitOptions.
        /// </summary>
        /// <param name="other">
        /// A ConcentricEdgeFitOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ConcentricEdgeFitOptions other)
        {
            return other != null && _stepSize == other._stepSize && _maxPixelRadius == other._maxPixelRadius && _processType == other._processType;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConcentricEdgeFitOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ConcentricEdgeFitOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ConcentricEdgeFitOptions other = (ConcentricEdgeFitOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _processType.GetHashCode() ^ _maxPixelRadius.GetHashCode() ^ _stepSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ConcentricEdgeFitOptions: MaxPixelRadius=" + _maxPixelRadius + ", StepSize=" + _stepSize + ", RakeProcessType=" + _processType.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the options used to detect straight edges.
    /// </summary>

    [Serializable]
    public sealed class StraightEdgeOptions
    {
        private UInt32 _numberOfLines;
        private StraightEdgeSearchMode _searchMode;
        private Range _scoreRange;
        private double _orientation;
        private double _angleRange;
        private double _angleTolerance;
        private UInt32 _stepSize;
        private double _minimumSignalToNoiseRatio;
        private double _minimumCoverage;
        private UInt32 _houghIterations;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StraightEdgeOptions class.
        /// </summary>

        public StraightEdgeOptions() : this (StraightEdgeSearchMode.BestProjectionEdge)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StraightEdgeOptions class.
        /// </summary>
        /// <param name="searchMode">
        /// Specifies the method used to find the straight edge.
        /// </param>

        public StraightEdgeOptions(StraightEdgeSearchMode searchMode) : this (searchMode, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StraightEdgeOptions class.
        /// </summary>
        /// <param name="searchMode">
        /// Specifies the method used to find the straight edge.
        /// </param>
        /// <param name="numberOfLines">
        /// Specifies the number of straight edges to find. 
        /// </param>

        [CLSCompliant(false)]
        public StraightEdgeOptions(StraightEdgeSearchMode searchMode, UInt32 numberOfLines)
        {
            _numberOfLines = numberOfLines;
            _searchMode = searchMode;
            _scoreRange = new Range(10, 1000);
            _orientation = 0;
            _angleRange = 10;
            _angleTolerance = 1;
            _stepSize = 3;
            _minimumSignalToNoiseRatio = 0;
            _minimumCoverage = 25;
            _houghIterations = 5;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of iterations used in the Hough-based method.
        /// </summary>
        /// <value>
        /// The default is 5.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 HoughIterations
        {
            get { return _houghIterations; }
            set { _houghIterations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum number of points as a percentage of the number of search lines that need to be included in the detected straight edge.
        /// </summary>
        /// <value>
        /// The default is 25.
        /// </value>

        public double MinimumCoverage
        {
            get { return _minimumCoverage; }
            set { _minimumCoverage = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum signal to noise ratio (SNR) of the edge points used to fit the straight edge.
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double MinimumSignalToNoiseRatio
        {
            get { return _minimumSignalToNoiseRatio; }
            set { _minimumSignalToNoiseRatio = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the gap in pixels between the search lines used with the rake-based methods. 
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 StepSize
        {
            get { return _stepSize; }
            set { _stepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the expected angular accuracy of the straight edge.
        /// </summary>
        /// <value>
        /// The default is 1 degree.
        /// </value>

        public double AngleTolerance
        {
            get { return _angleTolerance; }
            set { _angleTolerance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the +/- range around the orientation within which the straight edge is expected to be found. 
        /// </summary>
        /// <value>
        /// The default is 10 degrees.
        /// </value>

        public double AngleRange
        {
            get { return _angleRange; }
            set { _angleRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle at which the straight edge is expected to be found. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public double Orientation
        {
            get { return _orientation; }
            set { _orientation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of scores of a detected edge.
        /// </summary>
        /// <value>
        /// The default is (10, 1000).
        /// </value>

        public Range ScoreRange
        {
            get { return _scoreRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _scoreRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the method used to find the straight edge. 
        /// </summary>
        /// <value>
        /// The default is BestProjectionEdge.
        /// </value>

        public StraightEdgeSearchMode SearchMode
        {
            get { return _searchMode; }
            set { _searchMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of straight edges to find.
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        [CLSCompliant(false)]
        public UInt32 NumberOfLines
        {
            get { return _numberOfLines; }
            set { _numberOfLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A StraightEdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(StraightEdgeOptions other)
        {
            return other != null && _numberOfLines == other._numberOfLines && _searchMode == other._searchMode && Object.Equals(_scoreRange, other._scoreRange) && _orientation == other._orientation && _angleRange == other._angleRange && _angleTolerance == other._angleTolerance && _stepSize == other._stepSize && _minimumSignalToNoiseRatio == other._minimumSignalToNoiseRatio && _minimumCoverage == other._minimumCoverage && _houghIterations == other._houghIterations;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of StraightEdgeOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            StraightEdgeOptions other = (StraightEdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _numberOfLines.GetHashCode() ^ _searchMode.GetHashCode() ^ _scoreRange.GetHashCode() ^ _orientation.GetHashCode() ^ _angleRange.GetHashCode() ^ _angleTolerance.GetHashCode() ^ _stepSize.GetHashCode() ^ _minimumSignalToNoiseRatio.GetHashCode() ^ _minimumCoverage.GetHashCode() ^ _houghIterations.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "StraightEdgeOptions: SearchMode=" + _searchMode.ToString() + ", NumberOfLines=" + _numberOfLines.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains information about the found straight edge(s).
    /// </summary>

    [Serializable]
    public sealed class StraightEdgeReportItem
    {
        private LineContour _straightEdge;
        private LineContour _calibratedStraightEdge;
        private double _angle;
        private double _calibratedAngle;
        private double _score;
        private double _straightness;
        private double _averageSignalToNoiseRatio;
        private bool _calibrationValid;
        private Collection<EdgeInfo> _edgesUsed;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StraightEdgeReportItem class.
        /// </summary>

        public StraightEdgeReportItem()
        {
            _straightEdge = new LineContour();
            _calibratedStraightEdge = new LineContour();
            _edgesUsed = new Collection<EdgeInfo>();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of edges that were used to determine the straight line. 
        /// </summary>

        public Collection<EdgeInfo> EdgesUsed
        {
            get { return _edgesUsed; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_edgesUsed = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the calibration data for the straight edge is valid. 
        /// </summary>

        public bool CalibrationValid
        {
            get { return _calibrationValid; }
            set { _calibrationValid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the average signal to noise ratio (SNR) of the detected edge.
        /// </summary>

        public double AverageSignalToNoiseRatio
        {
            get { return _averageSignalToNoiseRatio; }
            set { _averageSignalToNoiseRatio = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the straightness value of the detected straight edge. Straightness is defined as the root mean squared error of the fitted line that represents the detected straight edge. A value of 0 indicates a perfectly straight line. 
        /// </summary>

        public double Straightness
        {
            get { return _straightness; }
            set { _straightness = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the score of the detected edge. 
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle of the found edge using real-world coordinates. 
        /// </summary>

        public double CalibratedAngle
        {
            get { return _calibratedAngle; }
            set { _calibratedAngle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the angle of the found edge using the pixel coordinates.
        /// </summary>

        public double Angle
        {
            get { return _angle; }
            set { _angle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the end points of the detected straight edge in real-world coordinates. 
        /// </summary>

        public LineContour CalibratedStraightEdge
        {
            get { return _calibratedStraightEdge; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _calibratedStraightEdge = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the end points of the detected straight edge in pixel coordinates. 
        /// </summary>

        public LineContour StraightEdge
        {
            get { return _straightEdge; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _straightEdge = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeReportItem.
        /// </summary>
        /// <param name="other">
        /// A StraightEdgeReportItem instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(StraightEdgeReportItem other)
        {
            return other != null && Object.Equals(_straightEdge, other._straightEdge) && Object.Equals(_calibratedStraightEdge, other._calibratedStraightEdge) && _angle == other._angle && _calibratedAngle == other._calibratedAngle && _score == other._score && _straightness == other._straightness && _averageSignalToNoiseRatio == other._averageSignalToNoiseRatio && _calibrationValid == other._calibrationValid && Utilities.CollectionsEqual(_edgesUsed, other._edgesUsed);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeReportItem.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of StraightEdgeReportItem and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            StraightEdgeReportItem other = (StraightEdgeReportItem)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _straightEdge.GetHashCode() ^ _calibratedStraightEdge.GetHashCode() ^ _angle.GetHashCode() ^ _calibratedAngle.GetHashCode() ^ _score.GetHashCode() ^ _straightness.GetHashCode() ^ _averageSignalToNoiseRatio.GetHashCode() ^ _calibrationValid.GetHashCode() ^ _edgesUsed.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "StraightEdgeReportItem: StraightEdge=" + _straightEdge.ToString() + ", Score=" + _score.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing the circular edges found.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindCircularEdgeReport
    {
        private PointContour _centerCalibrated;
        private PointContour _center;
        private double _radiusCalibrated;
        private double _radius;
        private double _roundness;
        private double _avgStrength;
        private double _avgSNR;
        private bool _circleFound;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeReport class.
        /// </summary>

        public FindCircularEdgeReport()
        {
            _centerCalibrated = new PointContour();
            _center = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the Center
        /// </summary>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the CenterCalibrated
        /// </summary>

        public PointContour CenterCalibrated
        {
            get { return _centerCalibrated; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _centerCalibrated = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Radius
        /// </summary>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the RadiusCalibrated
        /// </summary>

        public double RadiusCalibrated
        {
            get { return _radiusCalibrated; }
            set { _radiusCalibrated = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the avgSNR
        /// </summary>

        public double AvgSNR
        {
            get { return _avgSNR; }
            set { _avgSNR = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the AvgStrength
        /// </summary>

        public double AvgStrength
        {
            get { return _avgStrength; }
            set { _avgStrength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Roundness
        /// </summary>

        public double Roundness
        {
            get { return _roundness; }
            set { _roundness = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the circleFound
        /// </summary>

        public bool CircleFound
        {
            get { return _circleFound; }
            set { _circleFound = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindCircularEdgeReport.
        /// </summary>
        /// <param name="other">
        /// A FindCircularEdgeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindCircularEdgeReport other)
        {
            return other != null && _circleFound == other._circleFound && _center.Equals(other._center) && _centerCalibrated.Equals(other._centerCalibrated) && _radius == other._radius && _radiusCalibrated == other._radiusCalibrated && _avgSNR == other._avgSNR && _avgStrength == other._avgStrength;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindCircularEdgeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindCircularEdgeReport and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindCircularEdgeReport other = (FindCircularEdgeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _centerCalibrated.GetHashCode() ^ _radius.GetHashCode() ^ _radiusCalibrated.GetHashCode() ^ _roundness.GetHashCode() ^ _avgStrength.GetHashCode() ^ _avgSNR.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindCircularEdgeReport: Center=" + _center.ToString() + ", Radius=" + _radius + ", CenterCalibrated=" + _centerCalibrated.ToString() + ", RadiusCalibrated=" + _radiusCalibrated + ", AvgStrength=" + _avgStrength + ", AvgSNR=" + _avgSNR;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing the straight edges found using Annulus ROI.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindConcentricEdgeReport
    {
        private PointContour _startPt;
        private PointContour _endPt;
        private PointContour _startPtCalibrated;
        private PointContour _endPtCalibrated;
        private double _angleCalibrated;
        private double _angle;
        private double _straightness;
        private double _avgStrength;
        private double _avgSNR;
        private bool _lineFound;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindCircularEdgeReport class.
        /// </summary>

        public FindConcentricEdgeReport()
        {
            _startPt = new PointContour();
            _startPtCalibrated = new PointContour();
            _endPt = new PointContour();
            _endPtCalibrated = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the StartPt
        /// </summary>

        public PointContour StartPt
        {
            get { return _startPt; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _startPt = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the EndPt
        /// </summary>

        public PointContour EndPt
        {
            get { return _endPt; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _endPt = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the StartPtCalibrated
        /// </summary>

        public PointContour StartPtCalibrated
        {
            get { return _startPtCalibrated; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _startPtCalibrated = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the EndPtCalibrated
        /// </summary>

        public PointContour EndPtCalibrated
        {
            get { return _endPtCalibrated; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _endPtCalibrated = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Angle
        /// </summary>

        public double Angle
        {
            get { return _angle; }
            set { _angle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the AngleCalibrated
        /// </summary>

        public double AngleCalibrated
        {
            get { return _angleCalibrated; }
            set { _angleCalibrated = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the straightness
        /// </summary>

        public double Straightness
        {
            get { return _straightness; }
            set { _straightness = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the avgSNR
        /// </summary>

        public double AvgSNR
        {
            get { return _avgSNR; }
            set { _avgSNR = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the avgStrength
        /// </summary>

        public double AvgStrength
        {
            get { return _avgStrength; }
            set { _avgStrength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the LineFound
        /// </summary>

        public bool LineFound
        {
            get { return _lineFound; }
            set { _lineFound = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindConcentricEdgeReport.
        /// </summary>
        /// <param name="other">
        /// A FindConcentricEdgeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindConcentricEdgeReport other)
        {
            return other != null && _lineFound == other._lineFound && _startPt == other._startPt && _startPtCalibrated == other._startPtCalibrated && _endPt == other._endPt && _endPtCalibrated == other._endPtCalibrated && _angleCalibrated == other._angleCalibrated && _angle == other._angle && _straightness == other._straightness && _avgSNR == other._avgSNR && _avgStrength == other._avgStrength;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindConcentricEdgeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindConcentricEdgeReport and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindConcentricEdgeReport other = (FindConcentricEdgeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _startPt.GetHashCode() ^ _startPtCalibrated.GetHashCode() ^ _endPtCalibrated.GetHashCode() ^ _endPt.GetHashCode() ^ _angle.GetHashCode() ^ _angleCalibrated.GetHashCode() ^ _straightness.GetHashCode() ^ _avgStrength.GetHashCode() ^ _avgSNR.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindConcentricEdgeReport: StartPt=" + _startPt.ToString() + ", EndPt=" + _endPt.ToString() + ", StartPtCalibrated=" + _startPtCalibrated.ToString() + ", EndPtCalibrated=" + _endPtCalibrated.ToString() + ", Angle=" + _angle + ", AngleCalibrated=" + _angleCalibrated + ", Straightness=" + _straightness + ", AvgStrength=" + _avgStrength + ", AvgSnr=" + _avgSNR;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing the straight edges found.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindEdgeReport
    {
        private Collection<StraightEdgeReportItem> _straightEdges;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindEdgeReport class.
        /// </summary>

        public FindEdgeReport()
        {
            _straightEdges = new Collection<StraightEdgeReportItem>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a collection of straight edges detected. 
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// The number of straight edges detected is determined by <see cref="NationalInstruments.Vision.Analysis.StraightEdgeOptions.NumberOfLines" crefType="Unqualified"/>.
        /// </remarks>

        public Collection<StraightEdgeReportItem> StraightEdges
        {
            get { return _straightEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_straightEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindEdgeReport.
        /// </summary>
        /// <param name="other">
        /// A FindEdgeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindEdgeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_straightEdges, other._straightEdges);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindEdgeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindEdgeReport and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindEdgeReport other = (FindEdgeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _straightEdges.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindEdgeReport: StraightEdges=" + _straightEdges.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the coordinates of the main axis and the secondary axis of a coordinate system.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class AxisReport
    {
        private LineContour _mainAxis;
        private LineContour _secondaryAxis;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the AxisReport class.
        /// </summary>

        public AxisReport()
        {
            _mainAxis = new LineContour();
            _secondaryAxis = new LineContour();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the end of the main axis, which is the result of the computation of the intersection of the main axis with the rectangular search area. 
        /// </summary>
        /// <value>The default value is (0,0) - (0,0).
        /// </value>

        public LineContour MainAxis
        {
            get { return _mainAxis; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _mainAxis = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the end of the secondary axis, which is the result of the computation of the intersection of the secondary axis with the rectangular search area. 
        /// </summary>
        /// <value>The default value is (0,0) - (0,0).
        /// </value>

        public LineContour SecondaryAxis
        {
            get { return _secondaryAxis; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _secondaryAxis = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EqualsReport.
        /// </summary>
        /// <param name="other">
        /// An EqualsReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(AxisReport other)
        {
            return other != null && Object.Equals(_mainAxis, other._mainAxis) && Object.Equals(_secondaryAxis, other._secondaryAxis);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EqualsReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EqualsReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            AxisReport other = (AxisReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _mainAxis.GetHashCode() ^ _secondaryAxis.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "AxisReport: MainAxis=" + _mainAxis.ToString() + ", SecondaryAxis=" + _secondaryAxis.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how you want the function to search for edges and the information the function overlays to the image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindTransformRectOptions
    {
        private FindReferenceDirection _direction;
        private bool _showSearchArea;
        private bool _showSearchLines;
        private bool _showEdgesFound;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _searchLinesColor;
        private Rgb32Value _searchEdgesColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        private EdgeOptions _edgeOptions;
        private StraightEdgeOptions _straightEdgeOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>

        public FindTransformRectOptions()
            : this(FindReferenceDirection.LeftToRightDirect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>

        public FindTransformRectOptions(FindReferenceDirection direction)
            : this(direction, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>

        public FindTransformRectOptions(FindReferenceDirection direction, bool showSearchArea)
            : this(direction, showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>

        public FindTransformRectOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines)
            : this(direction, showSearchArea, showSearchLines, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the method overlays the locations of the edges found on the image. 
        /// </param>

        public FindTransformRectOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound)
            : this(direction, showSearchArea, showSearchLines, showEdgesFound, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the method overlays the locations of the edges found on the image. 
        /// </param>
        /// <param name="showResult">A Boolean indicating whether the method overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </param>

        public FindTransformRectOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound, bool showResult)
        {
            _direction = direction;
            _showSearchArea = showSearchArea;
            _showSearchLines = showSearchLines;
            _showEdgesFound = showEdgesFound;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.GreenColor;
            _searchLinesColor = Rgb32Value.BlueColor;
            _searchEdgesColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
            _edgeOptions = new EdgeOptions();
            _straightEdgeOptions = new StraightEdgeOptions();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to fit a line in the ROI.
        /// </summary>
        /// <value>
        /// </value>

        public StraightEdgeOptions StraightEdgeOptions
        {
            get { return _straightEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _straightEdgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the edge detection options along a single search line. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions EdgeOptions
        {
            get { return _edgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </summary>
        /// <value>The default value is blank.
        /// </value>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default RGB values are R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search edges. 
        /// </summary>
        /// <value>The default RGB values are R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchEdgesColor
        {
            get { return _searchEdgesColor; }
            set { _searchEdgesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search lines. 
        /// </summary>
        /// <value>The default RGB values are R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value SearchLinesColor
        {
            get { return _searchLinesColor; }
            set { _searchLinesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default RGB values are R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method overlays the locations of the edges found on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the locations of the edges found on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowEdgesFound
        {
            get { return _showEdgesFound; }
            set { _showEdgesFound = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search lines used to locate the edges on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the search lines used to locate the edges on the image. If you do not want
        ///  this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowSearchLines
        {
            get { return _showSearchLines; }
            set { _showSearchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the search area on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the direction and orientation in which the function searches for the primary axis. 
        /// </summary>
        /// <value>The default value is LeftToRightDirect.
        /// </value>

        public FindReferenceDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformRectOptions.
        /// </summary>
        /// <param name="other">
        /// A FindTransformRectOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindTransformRectOptions other)
        {
            return other != null && _direction == other._direction && _showSearchArea == other._showSearchArea && _showSearchLines == other._showSearchLines && _showEdgesFound == other._showEdgesFound && _showResult == other._showResult && _searchAreaColor == other._searchAreaColor && _searchLinesColor == other._searchLinesColor && _searchEdgesColor == other._searchEdgesColor && _resultColor == other._resultColor && _overlayGroupName == other._overlayGroupName && Object.Equals(_edgeOptions, other._edgeOptions) && Object.Equals(_straightEdgeOptions, other._straightEdgeOptions);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformRectOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindTransformRectOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindTransformRectOptions other = (FindTransformRectOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _direction.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showSearchLines.GetHashCode() ^ _showEdgesFound.GetHashCode() ^ _showResult.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _searchLinesColor.GetHashCode() ^ _searchEdgesColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _overlayGroupName.GetHashCode() ^ _edgeOptions.GetHashCode() ^ _straightEdgeOptions.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindTransformRectOptions: Direction=" + _direction.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how you want the function to search for edges and the information the function overlays to the image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class FindTransformRectsOptions
    {
        private FindReferenceDirection _direction;
        private bool _showSearchArea;
        private bool _showSearchLines;
        private bool _showEdgesFound;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _searchLinesColor;
        private Rgb32Value _searchEdgesColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        private EdgeOptions _primaryEdgeOptions;
        private EdgeOptions _secondaryEdgeOptions;
        private StraightEdgeOptions _primaryStraightEdgeOptions;
        private StraightEdgeOptions _secondaryStraightEdgeOptions;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>

        public FindTransformRectsOptions()
            : this(FindReferenceDirection.LeftToRightDirect)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>

        public FindTransformRectsOptions(FindReferenceDirection direction)
            : this(direction, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>

        public FindTransformRectsOptions(FindReferenceDirection direction, bool showSearchArea)
            : this(direction, showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>

        public FindTransformRectsOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines)
            : this(direction, showSearchArea, showSearchLines, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the method overlays the locations of the edges found on the image. 
        /// </param>

        public FindTransformRectsOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound)
            : this(direction, showSearchArea, showSearchLines, showEdgesFound, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformRectsOptions class.
        /// </summary>
        /// <param name="direction">The direction and orientation in which the method searches for the primary axis. 
        /// </param>
        /// <param name="showSearchArea">A Boolean indicating whether the method overlays the search area on the image. 
        /// </param>
        /// <param name="showSearchLines">A Boolean indicating whether the method overlays the search lines used to locate the edges on the image. 
        /// </param>
        /// <param name="showEdgesFound">A Boolean indicating whether the method overlays the locations of the edges found on the image. 
        /// </param>
        /// <param name="showResult">A Boolean indicating whether the method overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </param>

        public FindTransformRectsOptions(FindReferenceDirection direction, bool showSearchArea, bool showSearchLines, bool showEdgesFound, bool showResult)
        {
            _direction = direction;
            _showSearchArea = showSearchArea;
            _showSearchLines = showSearchLines;
            _showEdgesFound = showEdgesFound;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.GreenColor;
            _searchLinesColor = Rgb32Value.BlueColor;
            _searchEdgesColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
            _primaryEdgeOptions = new EdgeOptions();
            _secondaryEdgeOptions = new EdgeOptions();
            _primaryStraightEdgeOptions = new StraightEdgeOptions();
            _secondaryStraightEdgeOptions = new StraightEdgeOptions();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to fit a line in the secondary ROI.
        /// </summary>
        /// <value>
        /// </value>

        public StraightEdgeOptions SecondaryStraightEdgeOptions
        {
            get { return _secondaryStraightEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _secondaryStraightEdgeOptions = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the options used to fit a line in the primary ROI.
        /// </summary>
        /// <value>
        /// </value>

        public StraightEdgeOptions PrimaryStraightEdgeOptions
        {
            get { return _primaryStraightEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _primaryStraightEdgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the parameters used to compute the edge gradient information and detect the edges for the secondary ROI. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions SecondaryEdgeOptions
        {
            get { return _secondaryEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _secondaryEdgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the parameters used to compute the edge gradient information and detect the edges for the primary ROI. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgeOptions PrimaryEdgeOptions
        {
            get { return _primaryEdgeOptions; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _primaryEdgeOptions = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. 
        /// </summary>
        /// <value>The default value is blank.
        /// </value>
        /// <remarks>
        /// Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </remarks>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default RGB values are R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search edges. 
        /// </summary>
        /// <value>The default RGB values are R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchEdgesColor
        {
            get { return _searchEdgesColor; }
            set { _searchEdgesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search lines. 
        /// </summary>
        /// <value>The default RGB values are R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value SearchLinesColor
        {
            get { return _searchLinesColor; }
            set { _searchLinesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default RGB values are R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/> , the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method overlays the locations of the edges found on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/> the method overlays the locations of the edges found on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowEdgesFound
        {
            get { return _showEdgesFound; }
            set { _showEdgesFound = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search lines used to locate the edges on the image.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the search lines used to locate the edges on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowSearchLines
        {
            get { return _showSearchLines; }
            set { _showSearchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the search area on the image. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>. 
        /// </remarks>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the direction and orientation in which the function searches for the primary axis. 
        /// </summary>
        /// <value>The default value is LeftToRightDirect.
        /// </value>

        public FindReferenceDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformRectsOptions.
        /// </summary>
        /// <param name="other">
        /// A FindTransformRectsOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindTransformRectsOptions other)
        {
            return other != null && _direction == other._direction && _showSearchArea == other._showSearchArea && _showSearchLines == other._showSearchLines && _showEdgesFound == other._showEdgesFound && _showResult == other._showResult && _searchAreaColor == other._searchAreaColor && _searchLinesColor == other._searchLinesColor && _searchEdgesColor == other._searchEdgesColor && _resultColor == other._resultColor && _overlayGroupName == other._overlayGroupName && Object.Equals(_primaryEdgeOptions, other._primaryEdgeOptions) && Object.Equals(_secondaryEdgeOptions, other._secondaryEdgeOptions) && Object.Equals(_primaryStraightEdgeOptions, other._primaryStraightEdgeOptions) && Object.Equals(_secondaryStraightEdgeOptions, other._secondaryStraightEdgeOptions);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformRectsOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindTransformRectsOptions and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindTransformRectsOptions other = (FindTransformRectsOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _direction.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showSearchLines.GetHashCode() ^ _showEdgesFound.GetHashCode() ^ _showResult.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _searchLinesColor.GetHashCode() ^ _searchEdgesColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _overlayGroupName.GetHashCode() ^ _primaryEdgeOptions.GetHashCode() ^ _secondaryEdgeOptions.GetHashCode() ^ _primaryStraightEdgeOptions.GetHashCode() ^ _secondaryStraightEdgeOptions.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindTransformRectsOptions: Direction=" + _direction.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides information about a coordinate transform.
    /// </summary>

    [Serializable]
    public sealed class FindTransformReport
    {
        private CoordinateTransform _transform;
        private AxisReport _axisReport;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FindTransformReport class.
        /// </summary>

        public FindTransformReport()
        {
            _transform = new CoordinateTransform();
            _axisReport = new AxisReport();
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the axes detected.
        /// </summary>

        public AxisReport AxisReport
        {
            get { return _axisReport; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _axisReport = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the CoordinateTransform detected.
        /// </summary>

        public CoordinateTransform Transform
        {
            get { return _transform; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _transform = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformReport.
        /// </summary>
        /// <param name="other">
        /// A FindTransformReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FindTransformReport other)
        {
            return other != null && Object.Equals(_transform, other._transform) && Object.Equals(_axisReport, other._axisReport);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FindTransformReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FindTransformReport and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FindTransformReport other = (FindTransformReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _transform.GetHashCode() ^ _axisReport.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FindTransformReport: Transform=" + _transform.ToString() + ", AxisReport=" + _axisReport.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a search line used for finding a straight edge.
    /// </summary>

    [Serializable]
    public sealed class SearchLineInfo
    {
        private LineContour _line;
        private EdgeReport _edgeReport;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SearchLineInfo class.
        /// </summary>

        public SearchLineInfo()
        {
            _line = new LineContour();
            _edgeReport = new EdgeReport();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets information about the edges found in this search line. 
        /// </summary>

        public EdgeReport EdgeReport
        {
            get { return _edgeReport; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _edgeReport = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the search line.
        /// </summary>
        /// <value>
        /// </value>

        public LineContour Line
        {
            get { return _line; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _line = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SearchLineInfo.
        /// </summary>
        /// <param name="other">
        /// A SearchLineInfo instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SearchLineInfo other)
        {
            return other != null && Object.Equals(_line, other._line) && Object.Equals(_edgeReport, other._edgeReport);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SearchLineInfo.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SearchLineInfo
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SearchLineInfo other = (SearchLineInfo)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _line.GetHashCode() ^ _edgeReport.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SearchLineInfo: Line=" + _line.ToString() + ", EdgeReport=" + _edgeReport.ToString();
        }
    }
    [Serializable]
    public sealed class CVI_Array<T> 
    {
        private T[] _elementArray;
        private IntPtr _elementPtr;
        private UInt32 _count;
        //==========================================================================================
        /// <summary>
        /// Constructs a CVI_Array with no elements
        /// </summary>
        //==========================================================================================
        public CVI_Array()
        {
            _elementPtr = IntPtr.Zero;
            _count = 0;
            _elementArray = null;
        }
        //==========================================================================================
        /// <summary>
        /// Constructs a CVI_Array for accessing the cviPtr for count number of elements
        /// </summary>
        //==========================================================================================
        public CVI_Array(IntPtr cviPtr, UInt32 count)
        {
            _elementPtr = cviPtr;
            _count = count;
            _elementArray = new T[count];
            for (int i = 0; i < count; i++)
            {
                IntPtr ptrToIndex = Utilities.AdvanceIntPtr(_elementPtr, i * Marshal.SizeOf(typeof(T)));
                _elementArray[i] = ((T)Marshal.PtrToStructure(ptrToIndex, typeof(T)));
            }
        }

        //==========================================================================================
        /// <summary>
        /// Provides the number of elements available in this array
        /// </summary>
        //==========================================================================================
        public int Count
        {
            get { return (int)_count; }
        }

        //==========================================================================================
        /// <summary>
        /// Accesses an item in the array
        /// </summary>
        //==========================================================================================
        public T Item(int index)
        {
            if (_elementArray == null || index < 0 || index >= _count)
            {
                throw new IndexOutOfRangeException();
            }
            return _elementArray[index];        
        }

        //==========================================================================================
        /// <summary>
        /// Test equality with another cvi array
        /// </summary>
        //==========================================================================================
        public bool Equals(CVI_Array<T> other)
        {
            return other != null && other._elementPtr == _elementPtr;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides information describing the rake used by the method and the edges the method calculated with the rake.
    /// </summary>

    [Serializable]
    public sealed class FirstEdgeRakeReport
    {
        private CVI_Array<CVI_EdgeInfo> _firstEdges;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FirstEdgeRakeReport class.
        /// </summary>

        public FirstEdgeRakeReport(IntPtr firstEdgesPtr, UInt32 numFirstEdges)
        {
            _firstEdges = new CVI_Array<CVI_EdgeInfo>(firstEdgesPtr, numFirstEdges);
        }
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FirstEdgeRakeReport class.
        /// </summary>

        public FirstEdgeRakeReport()
        {
            _firstEdges = new CVI_Array<CVI_EdgeInfo>(IntPtr.Zero, 0);
        }
        //==========================================================================================
        /// <summary>
        /// Gets the first edges
        /// </summary>

        public CVI_Array<CVI_EdgeInfo> FirstEdges
        {
            get { return _firstEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_firstEdges = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FirstEdgeRakeReport.
        /// </summary>
        /// <param name="other">
        /// A FirstEdgeRakeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FirstEdgeRakeReport other)
        {
            return other != null && other._firstEdges.Equals(_firstEdges);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FirstEdgeRakeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RakeReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FirstEdgeRakeReport other = (FirstEdgeRakeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstEdges.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RakeReport: FirstEdges=" + _firstEdges.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides information describing the rake used by the method and the edges the method calculated with the rake.
    /// </summary>

    [Serializable]
    public sealed class RakeReport
    {
        private Collection<EdgeInfo> _firstEdges;
        private Collection<EdgeInfo> _lastEdges;
        private Collection<SearchLineInfo> _searchLines;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RakeReport class.
        /// </summary>

        public RakeReport()
        {
            _firstEdges = new Collection<EdgeInfo>();
            _lastEdges = new Collection<EdgeInfo>();
            _searchLines = new Collection<SearchLineInfo>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the search lines used for edge detection. 
        /// </summary>

        public Collection<SearchLineInfo> SearchLines
        {
            get { return _searchLines; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _searchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the last edge point detected along each search line in the ROI. 
        /// </summary>

        public Collection<EdgeInfo> LastEdges
        {
            get { return _lastEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _lastEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the first edge point detected along each search line in the ROI. 
        /// </summary>

        public Collection<EdgeInfo> FirstEdges
        {
            get { return _firstEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _firstEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RakeReport.
        /// </summary>
        /// <param name="other">
        /// A RakeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RakeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_firstEdges, other._firstEdges) && Utilities.CollectionsEqual(_lastEdges, other._lastEdges) && Utilities.CollectionsEqual(_searchLines, other._searchLines);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RakeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RakeReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RakeReport other = (RakeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstEdges.Count.GetHashCode() ^ _lastEdges.Count.GetHashCode() ^ _searchLines.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RakeReport: FirstEdges=" + _firstEdges.ToString() + ", LastEdges=" + _lastEdges.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Describes how the method finds edges. 
    /// </summary>

    [Serializable]
    public sealed class SimpleEdgeOptions
    {
        private LevelType _type;
        private Int32 _threshold;
        private Int32 _hysteresis;
        private EdgeProcess _process;
        private bool _subPixel;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleEdgeOptions class.
        /// </summary>

        public SimpleEdgeOptions()
            : this(EdgeProcess.All)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleEdgeOptions class.
        /// </summary>
        /// <param name="process">
        /// Determines which edges the method looks for.
        /// </param>

        public SimpleEdgeOptions(EdgeProcess process)
            : this(process, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SimpleEdgeOptions class.
        /// </summary>
        /// <param name="process">
        /// Determines which edges the method looks for.
        /// </param>
        /// <param name="subPixel">
        /// Set this element to <see langword="true"/> to find edges with subpixel accuracy by 
        /// interpolating between points to find the crossing of the given threshold. Set this 
        /// parameter to <see langword="false"/> to report an edge as the point nearest the threshold crossing. 
        /// </param>

        public SimpleEdgeOptions(EdgeProcess process, bool subPixel)
        {
            _process = process;
            _subPixel = subPixel;
            _threshold = 128;
            _hysteresis = 0;
            _type = LevelType.Absolute;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether to find edges with subpixel accuracy. Set this parameter to <see langword="true"/> to find edges by interpolating between points to find the crossing of the given threshold. Set this parameter to <see langword="true"/> to report an edge as the point nearest the threshold crossing. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SubPixel
        {
            get { return _subPixel; }
            set { _subPixel = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets which edges the method looks for. 
        /// </summary>
        /// <value>
        /// The default is All.
        /// </value>

        public EdgeProcess Process
        {
            get { return _process; }
            set { _process = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a value that helps determine edges in noisy images. If a pixel value crosses 
        /// the given threshold value but does not exceed the value by the value of hysteresis, the 
        /// method does not consider the pixel to be part of an edge. 
        /// </summary>
        /// <value>
        /// The default is 0.
        /// </value>

        public Int32 Hysteresis
        {
            get { return _hysteresis; }
            set { _hysteresis = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the pixel value at which an edge occurs. 
        /// </summary>
        /// <value>
        /// The default is 128.
        /// </value>

        public Int32 Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method evaluates the threshold and hysteresis values.
        /// </summary>
        /// <value>
        /// The default is Absolute.
        /// </value>

        public LevelType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SimpleEdgeOptions.
        /// </summary>
        /// <param name="other">
        /// A SimpleEdgeOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SimpleEdgeOptions other)
        {
            return other != null && _type == other._type && _threshold == other._threshold && _hysteresis == other._hysteresis && _subPixel == other._subPixel && _process == other._process;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SimpleEdgeOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SimpleEdgeOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SimpleEdgeOptions other = (SimpleEdgeOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _type.GetHashCode() ^ _threshold.GetHashCode() ^ _hysteresis.GetHashCode() ^ _process.GetHashCode() ^ _subPixel.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SimpleEdgeOptions: Process=" + _process.ToString() + ", SubPixel=" + _subPixel.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains information about the found straight edge(s).
    /// </summary>

    [Serializable]
    public sealed class StraightEdgeReport
    {
        private Collection<StraightEdgeReportItem> _straightEdges;
        private Collection<SearchLineInfo> _searchLines;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the StraightEdgeReport class.
        /// </summary>

        public StraightEdgeReport()
        {
            _straightEdges = new Collection<StraightEdgeReportItem>();
            _searchLines = new Collection<SearchLineInfo>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of all search lines used in the detection. 
        /// </summary>

        public Collection<SearchLineInfo> SearchLines
        {
            get { return _searchLines; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_searchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of found straight edges.
        /// </summary>

        public Collection<StraightEdgeReportItem> StraightEdges
        {
            get { return _straightEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_straightEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeReport.
        /// </summary>
        /// <param name="other">
        /// A StraightEdgeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(StraightEdgeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_straightEdges, other._straightEdges) && Utilities.CollectionsEqual(_searchLines, other._searchLines);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified StraightEdgeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of StraightEdgeReport and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            StraightEdgeReport other = (StraightEdgeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _straightEdges.Count.GetHashCode() ^ _searchLines.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "StraightEdgeReport: StraightEdges=" + _straightEdges.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Contains information about the edges the function calculated with the spoke.
    /// </summary>

    [Serializable]
    public sealed class SpokeReport
    {
        private Collection<EdgeInfo> _firstEdges;
        private Collection<EdgeInfo> _lastEdges;
        private Collection<SearchLineInfo> _searchLines;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SpokeReport class.
        /// </summary>

        public SpokeReport()
        {
            _firstEdges = new Collection<EdgeInfo>();
            _lastEdges = new Collection<EdgeInfo>();
            _searchLines = new Collection<SearchLineInfo>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate location of each of the spoke lines used by the method. 
        /// </summary>

        public Collection<SearchLineInfo> SearchLines
        {
            get { return _searchLines; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_searchLines = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate location of all edges detected as last edges. 
        /// </summary>

        public Collection<EdgeInfo> LastEdges
        {
            get { return _lastEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_lastEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate location of all edges detected as first edges.
        /// </summary>

        public Collection<EdgeInfo> FirstEdges
        {
            get { return _firstEdges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_firstEdges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SpokeReport.
        /// </summary>
        /// <param name="other">
        /// A SpokeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SpokeReport other)
        {
            return other != null && Utilities.CollectionsEqual(_firstEdges, other._firstEdges) && Utilities.CollectionsEqual(_lastEdges, other._lastEdges) && Utilities.CollectionsEqual(_searchLines, other._searchLines);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SpokeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SpokeReport and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SpokeReport other = (SpokeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _firstEdges.Count.GetHashCode() ^ _lastEdges.Count.GetHashCode() ^ _searchLines.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "SpokeReport: FirstEdges=" + _firstEdges.ToString() + ", LastEdges=" + _lastEdges.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about the color features contained in a region of an image.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ColorInformation
    {
        private Int32 _saturation;
        private Collection<double> _information;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a ColorInformation class.
        /// </summary>

        public ColorInformation()
        {
            _information = new Collection<double>();
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of a ColorInformation class.
        /// </summary>
        /// <param name="information">
        /// </param>

        public ColorInformation(Collection<double> information)
        {
            Information = information;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of color information that represents the color spectrum analysis of a region of an image in a compact form. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<double> Information
        {
            get { return _information; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_information = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the saturation level the method uses to learn the color information. 
        /// </summary>
        /// <value>
        /// </value>

        public Int32 Saturation
        {
            get { return _saturation; }
            set { _saturation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorInformation.
        /// </summary>
        /// <param name="other">
        /// A ColorInformation instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ColorInformation other)
        {
            return other != null && _saturation == other._saturation && Utilities.CollectionsEqual(_information, other._information);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorInformation.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ColorInformation and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ColorInformation other = (ColorInformation)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _saturation.GetHashCode() ^ _information.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ColorInformation: Saturation=" + _saturation.ToString(CultureInfo.CurrentCulture);
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Specifies how text is drawn.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class DrawTextOptions
    {
        private string _fontName;
        private Int32 _fontSize;
        private TextDecoration _textDecoration;
        private HorizontalTextAlignment _alignment;
        private FontColor _color;

        //==========================================================================================
        /// <summary>
        /// Gets or sets the color of the text.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.Analysis.FontColor.White" crefType="Unqualified"/>.
        /// </value>

        public FontColor Color
        {
            get { return _color; }
            set { _color = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the horizontal alignment of the text.
        /// </summary>
        /// <value>
        /// The default is <see cref="NationalInstruments.Vision.HorizontalTextAlignment.Left" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// You can use the following constants with this data type:
        /// <list type="bullet">
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.HorizontalTextAlignment.Center" crefType="Unqualified"/>Indicates that the origin point is in the center of the text. In other words, half of the text appears to the left of the origin and half is to the right of the origin.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.HorizontalTextAlignment.Left" crefType="Unqualified"/>Indicates that the text appears to the left of the origin point.
        /// </description>
        /// 		</item>
        /// 		<item>
        /// 			<description>
        /// 				<see cref="NationalInstruments.Vision.HorizontalTextAlignment.Right" crefType="Unqualified"/>Indicates that the text appears to the right of the origin point.
        /// </description>
        /// 		</item>
        /// 	</list>
        /// </remarks>

        public HorizontalTextAlignment Alignment
        {
            get { return _alignment; }
            set { _alignment = value; }
        }

        //==========================================================================================
        /// <summary>Gets or sets the formatting of the text.
        /// </summary>
        /// <value>The default value is false for bold, italic, underline, and strikeout.
        /// </value>

        public TextDecoration TextDecoration
        {
            get { return _textDecoration; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _textDecoration = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the font.
        /// </summary>
        /// <value>
        /// The default is 12.
        /// </value>

        public Int32 FontSize
        {
            get { return _fontSize; }
            set { _fontSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the name of the font face to use.
        /// </summary>
        /// <value>The default value is Arial.
        /// </value>

        public string FontName
        {
            get { return _fontName; }
            set { _fontName = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DrawTextOptions class.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public DrawTextOptions()
            : this("Arial", 12)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DrawTextOptions class.
        /// </summary>
        /// <param name="fontName">The name of the font face to use.
        /// </param>
        /// <param name="fontSize">The size of the font.
        /// </param>

        public DrawTextOptions(string fontName, Int32 fontSize)
            : this(fontName, fontSize, FontColor.White)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DrawTextOptions class.
        /// </summary>
        /// <param name="fontName">The name of the font face to use.
        /// </param>
        /// <param name="fontSize">The size of the font.
        /// </param>
        /// <param name="color">The color of the text.
        /// </param>

        public DrawTextOptions(string fontName, Int32 fontSize, FontColor color)
            : this(fontName, fontSize, color, HorizontalTextAlignment.Left)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DrawTextOptions class.
        /// </summary>
        /// <param name="fontName">The name of the font face to use.
        /// </param>
        /// <param name="fontSize">The size of the font.
        /// </param>
        /// <param name="color">The color of the text.
        /// </param>
        /// <param name="alignment">The horizontal alignment of the text.
        /// </param>

        public DrawTextOptions(string fontName, Int32 fontSize, FontColor color, HorizontalTextAlignment alignment)
        {
            _fontName = fontName;
            _fontSize = fontSize;
            _color = color;
            _alignment = alignment;
            _textDecoration = new TextDecoration();
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DrawTextOptions.
        /// </summary>
        /// <param name="other">
        /// A DrawTextOptions  instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DrawTextOptions other)
        {
            return other != null && _fontName == other._fontName && _fontSize == other._fontSize && _color == other._color && _alignment == other._alignment && Object.Equals(_textDecoration, other._textDecoration);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DrawTextOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DrawTextOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DrawTextOptions other = (DrawTextOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _fontName.GetHashCode() ^ _fontSize.GetHashCode() ^ _color.GetHashCode() ^ _alignment.GetHashCode() ^ _textDecoration.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DrawTextOptions: FontName=" + _fontName + ", FontSize=" + _fontSize.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>Gets or sets a description of filter parameters to use in the Canny algorithm.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CannyOptions
    {
        private double _sigma;
        private Range _thresholdRange;
        private int _windowSize;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CannyOptions class.
        /// </summary>

        public CannyOptions()
            : this(1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CannyOptions class.
        /// </summary>
        /// <param name="sigma">The sigma of the Gaussian smoothing filter that the method applies to the image before edge detection.
        /// </param>

        public CannyOptions(double sigma)
            : this(sigma, new Range(.2, .7))
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CannyOptions class.
        /// </summary>
        /// <param name="sigma">The sigma of the Gaussian smoothing filter that the method applies to the image before edge detection.
        /// </param>
        /// <param name="thresholdRange">The threshold range of the Gaussian filter that the method applies to the image. 
        /// </param>

        public CannyOptions(double sigma, Range thresholdRange)
            : this(sigma, thresholdRange, 9)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CannyOptions class.
        /// </summary>
        /// <param name="sigma">The sigma of the Gaussian smoothing filter that the method applies to the image before edge detection.
        /// </param>
        /// <param name="thresholdRange">The threshold range of the Gaussian filter that the method applies to the image. 
        /// </param>
        /// <param name="windowSize">The window size of the Gaussian filter that the method applies to the image. This value must be odd.
        /// </param>

        public CannyOptions(double sigma, Range thresholdRange, int windowSize)
        {
            if (thresholdRange == null) { throw new ArgumentNullException("thresholdRange"); }
            _sigma = sigma;
            _thresholdRange = thresholdRange;
            _windowSize = windowSize;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the window size of the Gaussian filter that the method applies to the image. This value must be odd.
        /// </summary>
        /// <value>
        /// The default value is 9.
        /// </value>

        public int WindowSize
        {
          get { return _windowSize; }
          set { _windowSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the threshold of pixel values in the image from which the edge detection algorithm chooses the seed or starting point of an edge segment.   
        /// </summary>
        /// <value>The minimum default value is 0.2. The maximum default value is 0.7. 
        /// </value>
        /// <remarks>
        /// The minimum property is multiplied by the maximum to define a lower threshold for all the pixels in an edge segment.  For the maximum property, you can choose values from 0 to 1.
        /// </remarks>

        public Range ThresholdRange
        {
            get { return _thresholdRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _thresholdRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the sigma of the Gaussian smoothing filter that the method applies to the image before edge detection.
        /// </summary>
        /// <value>
        /// The default value is 1.00.
        /// </value>

        public double Sigma
        {
            get { return _sigma; }
            set { _sigma = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CannyOptions.
        /// </summary>
        /// <param name="other">
        /// A CannyOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CannyOptions other)
        {
            return other != null && _sigma == other._sigma && Object.Equals(_thresholdRange, other._thresholdRange) && _windowSize == other._windowSize;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CannyOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CannyOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CannyOptions other = (CannyOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _sigma.GetHashCode() ^ _thresholdRange.GetHashCode() ^ _windowSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CannyOptions: Sigma=" + _sigma.ToString(CultureInfo.CurrentCulture) + ", ThresholdRange=" + _thresholdRange.ToString() + ", WindowSize=" + _windowSize.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes options for a non-linear filter.
    /// </summary>

    [Serializable]
    public sealed class LowPassOptions
    {
        private int _width;
        private int _height;
        private double _tolerance;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LowPassOptions class.
        /// </summary>

        public LowPassOptions()
            : this(3, 3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LowPassOptions class.
        /// </summary>
        /// <param name="width">
        /// The width of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </param>
        /// <param name="height">
        /// The height of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </param>

        public LowPassOptions(int width, int height)
            : this(width, height, 40)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LowPassOptions class.
        /// </summary>
        /// <param name="width">
        /// The width of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </param>
        /// <param name="height">
        /// The height of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </param>
        /// <param name="tolerance">
        /// The maximum percentage variation allowed. 
        /// </param>

        public LowPassOptions(int width, int height, double tolerance)
        {
            _width = width;
            _height = height;
            _tolerance = tolerance;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum percentage variation allowed. 
        /// </summary>
        /// <value>
        /// The default is 40.
        /// </value>

        public double Tolerance
        {
            get { return _tolerance; }
            set { _tolerance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public int Height
        {
            get { return _height; }
            set { _height = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the rectangular neighborhood around the pixel on which the method operates. This number must be odd. 
        /// </summary>
        /// <value>
        /// The default is 3.
        /// </value>

        public int Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LowPassOptions.
        /// </summary>
        /// <param name="other">
        /// A LowPassOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LowPassOptions other)
        {
            return other != null && _width == other._width && _height == other._height && _tolerance == other._tolerance;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LowPassOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LowPassOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LowPassOptions other = (LowPassOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _width.GetHashCode() ^ _height.GetHashCode() ^ _tolerance.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LowPassOptions: Width=" + _width.ToString(CultureInfo.CurrentCulture) + ", Height=" + _height.ToString(CultureInfo.CurrentCulture) + ", Tolerance=" + _tolerance.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes a match to a given template shape.
    /// </summary>

    [Serializable]
    public sealed class ShapeReport
    {
        private RectangleContour _boundingRectangle;
        private PointContour _centroid;
        private int _size;
        private double _score;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ShapeReport class.
        /// </summary>

        public ShapeReport()
        {
            _boundingRectangle = new RectangleContour();
            _centroid = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a value ranging between 1 and 1,000 that specifies how similar the object in the image is to the template. A score of 1,000 indicates a perfect match.
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the size of the object in pixels. 
        /// </summary>

        public int Size
        {
            get { return _size; }
            set { _size = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinate location of the centroid of the object.
        /// </summary>

        public PointContour Centroid
        {
            get { return _centroid; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _centroid = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the bounding rectangle of the object.
        /// </summary>

        public RectangleContour BoundingRectangle
        {
            get { return _boundingRectangle; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _boundingRectangle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ShapeReport.
        /// </summary>
        /// <param name="other">
        /// A ShapeReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ShapeReport other)
        {
            return other != null && Object.Equals(_boundingRectangle, other._boundingRectangle) && Object.Equals(_centroid, other._centroid) && _size == other._size && _score == other._score;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ShapeReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ShapeReport and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ShapeReport other = (ShapeReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _boundingRectangle.GetHashCode() ^ _centroid.GetHashCode() ^ _size.GetHashCode() ^ _score.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ShapeReport: Centroid=" + _centroid.ToString() + ", Score=" + _score.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how an LCD is examined.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class LcdOptions
    {
        private bool _litSegments;
        private double _threshold;
        private bool _sign;
        private bool _decimalPoint;

        //==========================================================================================
        /// <summary>
        /// </summary>

        public LcdOptions() :
            this (false)
        {
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the LcdOptions class.
        /// </summary>
        /// <param name="litSegments">A Boolean indicating whether the segments are brighter than the background.
        /// </param>

        public LcdOptions(bool litSegments) :
            this (litSegments, 8)
        {
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the LcdOptions class.
        /// </summary>
        /// <param name="litSegments">A Boolean indicating whether the segments are brighter than the background.
        /// </param>
        /// <param name="threshold">A threshold value for determining whether a segment is on or off.
        /// </param>

        public LcdOptions(bool litSegments, double threshold) :
            this (litSegments, threshold, false)
        {
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the LcdOptions class.
        /// </summary>
        /// <param name="litSegments">A Boolean indicating whether the segments are brighter than the background.
        /// </param>
        /// <param name="threshold">A threshold value for determining whether a segment is on or off.
        /// </param>
        /// <param name="sign">A Boolean indicating whether the function must read the sign of the indicator. 
        /// </param>

        public LcdOptions(bool litSegments, double threshold, bool sign) :
            this (litSegments, threshold, sign, false)
        {
        }
        //==========================================================================================
        /// <summary>Initializes a new instance of the LcdOptions class.
        /// </summary>
        /// <param name="litSegments">A Boolean indicating whether the segments are brighter than the background.
        /// </param>
        /// <param name="threshold">A threshold value for determining whether a segment is on or off.
        /// </param>
        /// <param name="sign">A Boolean indicating whether the function must read the sign of the indicator. 
        /// </param>
        /// <param name="decimalPoint">A Boolean indicating whether to look for a decimal separator after each digit.
        /// </param>

        public LcdOptions(bool litSegments, double threshold, bool sign, bool decimalPoint)
        {
            _litSegments = litSegments;
            _threshold = threshold;
            _sign = sign;
            _decimalPoint = decimalPoint;
        }

        //==========================================================================================
        /// <summary>Gets or sets whether to look for a decimal separator after each digit.
        /// </summary>
        /// <value>
        /// The default value is <see langword="false"/>.
        /// </value>

        public bool DecimalPoint
        {
            get { return _decimalPoint; }
            set { _decimalPoint = value; }
        }

        //==========================================================================================
        /// <summary>Gets or sets whether the function must read the sign of the indicator. 
        /// </summary>
        /// <value>
        /// The default value is <see langword="false"/>.
        /// </value>

        public bool Sign
        {
            get { return _sign; }
            set { _sign = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a threshold value for determining whether a segment is on or off.</summary>
        /// <value>The default value is 8.0.
        /// </value>
        /// <remarks>
        /// A segment is on if the standard deviation of the pixels along a line profile across the segment is greater than threshold.
        /// </remarks>

        public double Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the segments are brighter than the background.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool LitSegments
        {
            get { return _litSegments; }
            set { _litSegments = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdOptions.
        /// </summary>
        /// <param name="other">
        /// A LcdOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LcdOptions other)
        {
            return other != null && _litSegments == other._litSegments && _threshold == other._threshold && _sign == other._sign && _decimalPoint == other._decimalPoint;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LcdOptions and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LcdOptions other = (LcdOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _litSegments.GetHashCode() ^ _threshold.GetHashCode() ^ _sign.GetHashCode() ^ _decimalPoint.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LcdOptions: LitSegments=" + _litSegments.ToString() + ", Threshold=" + _threshold.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes which segments of an LCD digit are on. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class LcdSegments
    {
        private bool _a;
        private bool _b;
        private bool _c;
        private bool _d;
        private bool _e;
        private bool _f;
        private bool _g;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LcdSegements class.
        /// </summary>

        public LcdSegments() {
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">a</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool A
        {
            get { return _a; }
            set { _a = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">b</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool B
        {
            get { return _b; }
            set { _b = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">c</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool C
        {
            get { return _c; }
            set { _c = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">d</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool D
        {
            get { return _d; }
            set { _d = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">e</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool E
        {
            get { return _e; }
            set { _e = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">f</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool F
        {
            get { return _f; }
            set { _f = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the <format type="bold">g</format> segment is on.
        /// </summary>
        /// <remarks>
        /// The properties of the segments correspond to the actual position in the LCD, as shown in the following figure.
        /// <image src="segments.gif"/>
        /// </remarks>

        public bool G
        {
            get { return _g; }
            set { _g = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdSegments.
        /// </summary>
        /// <param name="other">
        /// A LcdSegments instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LcdSegments other)
        {
            return other != null && _a == other._a && _b == other._b && _c == other._c && _d == other._d && _e == other._e && _f == other._f && _g == other._g;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdSegments.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LcdSegments and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LcdSegments other = (LcdSegments)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _a.GetHashCode() ^ _b.GetHashCode() ^ _c.GetHashCode() ^ _d.GetHashCode() ^ _e.GetHashCode() ^ _f.GetHashCode() ^ _g.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LcdSegments: A=" + _a.ToString() + ", B=" + _b.ToString() + ", C=" + _c.ToString() + ", D=" + _d.ToString() + ", E=" + _e.ToString() + ", F=" + _f.ToString() + ", G=" + _g.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the state of an LCD.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class LcdReport
    {
        private string _text;
        private Collection<LcdSegments> _segmentInfo;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LcdReport option.
        /// </summary>

        public LcdReport()
        {
            _segmentInfo = new Collection<LcdSegments>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of LCDSegment structures describing which segments of each digit are on.
        /// </summary>
        /// <value>
        /// </value>

        public Collection<LcdSegments> SegmentInfo
        {
            get { return _segmentInfo; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_segmentInfo = value; }
        }

        //==========================================================================================
        /// <summary>The read LCD values as a string.
        /// </summary>
        /// <value>
        /// </value>

        public string Text
        {
            get { return _text; }
            set { _text = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdReport.
        /// </summary>
        /// <param name="other">
        /// A LcdReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this  instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LcdReport other)
        {
            return other != null && _text == other._text && Utilities.CollectionsEqual(_segmentInfo, other._segmentInfo);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LcdReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LcdReport and equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LcdReport other = (LcdReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _text.GetHashCode() ^ _segmentInfo.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LcdReport: Text=" + _text;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the arc across which a meter sweeps.
    /// </summary>

    [Serializable]
    public sealed class MeterArc : IDisposable
    {
        // We just hold a pointer to the underlying CVI_MeterArc
        private IntPtr _meterArc;
        private object _disposeLock = new object();

internal IntPtr MeterArcPtr
        {
            get { return _meterArc; }
            set { _meterArc = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MeterArc class.
        /// </summary>

        public MeterArc()
        {
        }

internal void ThrowIfDisposed()
        {
            if (_meterArc == IntPtr.Zero)
            {
                throw new ObjectDisposedException("NationalInstruments.Vision.Analysis.MeterArc");
            }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MeterArc.
        /// </summary>
        /// <param name="other">
        /// A MeterArc instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MeterArc other)
        {
            return other != null && _meterArc == other._meterArc;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MeterArc.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MeterArc
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MeterArc other = (MeterArc)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _meterArc.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MeterArc";
        }
        //==========================================================================================
        /// <summary>
        /// Releases all resources used by the MeterArc. 
        /// </summary>

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        
        private void Dispose(bool disposing) {
            lock (_disposeLock)
            {
                // Dispose the intptr.
                VisionDll.imaqDispose(_meterArc);
                _meterArc = IntPtr.Zero;
            }
        }

        
        ~MeterArc()
        {
            Dispose(false);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a meter.
    /// </summary>

    [Serializable]
    public sealed class MeterReport
    {
        private double _percentage;
        private PointContour _endOfNeedle;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MeterReport class.
        /// </summary>

        public MeterReport()
        {
            _endOfNeedle = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the endpoint of the needle.
        /// </summary>

        public PointContour EndOfNeedle
        {
            get { return _endOfNeedle; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _endOfNeedle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the current sweep position of the needle in comparison to the 
        /// maximum sweep position, expressed as a percentage. For example, a value of 
        /// 100 indicates the needle is at the maximum sweep position.
        /// </summary>
        /// <value>
        /// </value>

        public double Percentage
        {
            get { return _percentage; }
            set { _percentage = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MeterReport.
        /// </summary>
        /// <param name="other">
        /// A MeterReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MeterReport other)
        {
            return other != null && Object.Equals(_endOfNeedle, other._endOfNeedle) && _percentage == other._percentage;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MeterReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MeterReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MeterReport other = (MeterReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _endOfNeedle.GetHashCode() ^ _percentage.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MeterReport: Percentage=" + _percentage.ToString(CultureInfo.CurrentCulture) + ", EndOfNeedle=" + _endOfNeedle.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Contains parameters used by the 
    /// <see cref="NationalInstruments.Vision.Analysis.Algorithms.LearnColorPattern" crefType="Unqualified"/> 
    /// method to learn the template.
    /// </summary>

    [Serializable]
    public sealed class LearnColorPatternOptions
    {
        private LearnMode _learnMode;
        private ImageFeatureMode _featureMode;
        private int _threshold;
        private ColorIgnoreMode _ignoreMode;
        private Collection<ColorInformation> _colorsToIgnore;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnColorPatternOptions class.
        /// </summary>

        public LearnColorPatternOptions()
            : this(LearnMode.ShiftInformation)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnColorPatternOptions class.
        /// </summary>
        /// <param name="learnMode">
        /// The invariance mode to use when learning the pattern.
        /// </param>

        public LearnColorPatternOptions(LearnMode learnMode)
            : this(learnMode, ImageFeatureMode.ColorAndShape)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnColorPatternOptions class.
        /// </summary>
        /// <param name="learnMode">
        /// The invariance mode to use when learning the pattern.
        /// </param>
        /// <param name="featureMode">
        /// The color feature mode you want to use when setting up a color learn pattern. 
        /// </param>

        public LearnColorPatternOptions(LearnMode learnMode, ImageFeatureMode featureMode)
            : this(learnMode, featureMode, ColorIgnoreMode.None)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnColorPatternOptions class.
        /// </summary>
        /// <param name="learnMode">
        /// The invariance mode to use when learning the pattern.
        /// </param>
        /// <param name="featureMode">
        /// The color feature mode you want to use when setting up a color learn pattern. 
        /// </param>
        /// <param name="ignoreMode">
        /// Specifies whether black or white colors are excluded from the color features of the template image. Any color excluded during the learning process is also ignored from the template in the match phase. 
        /// </param>

        public LearnColorPatternOptions(LearnMode learnMode, ImageFeatureMode featureMode, ColorIgnoreMode ignoreMode)
            : this(learnMode, featureMode, ignoreMode, 80)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LearnColorPatternOptions class.
        /// </summary>
        /// <param name="learnMode">
        /// The invariance mode to use when learning the pattern.
        /// </param>
        /// <param name="featureMode">
        /// The color feature mode you want to use when setting up a color learn pattern. 
        /// </param>
        /// <param name="ignoreMode">
        /// Specifies whether black or white colors are excluded from the color features of the template image. Any color excluded during the learning process is also ignored from the template in the match phase. 
        /// </param>
        /// <param name="threshold">
        /// The threshold used to distinguish between two colors having the same hue values.
        /// </param>

        public LearnColorPatternOptions(LearnMode learnMode, ImageFeatureMode featureMode, ColorIgnoreMode ignoreMode, int threshold)
        {
            _learnMode = learnMode;
            _featureMode = featureMode;
            _ignoreMode = ignoreMode;
            _threshold = threshold;
            _colorsToIgnore = new Collection<ColorInformation>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets information about colors to ignore in the template during the learn phase.
        /// </summary>
        /// <value>
        /// The default is an empty set of spectrums, which indicates that nothing is ignored.
        /// </value>
        /// <remarks>
        /// Any color excluded during the learning process is also ignored from the template in the match phase. Use this property to exclude background colors from the learned template image.
        /// </remarks>

        public Collection<ColorInformation> ColorsToIgnore
        {
            get { return _colorsToIgnore; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_colorsToIgnore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether black or white colors are excluded from the color features of the template image. Any color excluded during the learning process is also ignored from the template in the match phase. 
        /// </summary>
        /// <value>
        /// The default is None.
        /// </value>

        public ColorIgnoreMode IgnoreMode
        {
            get { return _ignoreMode; }
            set { _ignoreMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the threshold used to distinguish between two colors having the same hue values.
        /// </summary>
        /// <value>
        /// The default is 80.
        /// </value>

        public int Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the color feature mode you want to use when setting up a color learn pattern. 
        /// </summary>
        /// <value>
        /// The default is ColorAndShape.
        /// </value>

        public ImageFeatureMode FeatureMode
        {
            get { return _featureMode; }
            set { _featureMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the invariance mode to use when learning the pattern.
        /// </summary>
        /// <value>
        /// The default is ShiftInformation.
        /// </value>

        public LearnMode LearnMode
        {
            get { return _learnMode; }
            set { _learnMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnColorPatternOptions.
        /// </summary>
        /// <param name="other">
        /// A LearnColorPatternOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LearnColorPatternOptions other)
        {
            return other != null && _learnMode == other._learnMode && _featureMode == other._featureMode && _threshold == other._threshold && _ignoreMode == other._ignoreMode && Utilities.CollectionsEqual(_colorsToIgnore, other._colorsToIgnore);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LearnColorPatternOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LearnColorPatternOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LearnColorPatternOptions other = (LearnColorPatternOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _learnMode.GetHashCode() ^ _featureMode.GetHashCode() ^ _threshold.GetHashCode() ^ _ignoreMode.GetHashCode() ^ _colorsToIgnore.Count.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LearnColorPatternOptions: LearnMode=" + _learnMode.ToString() + ", FeatureMode=" + _featureMode.ToString() + ", IgnoreMode=" + _ignoreMode.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes how you want the function to search for the color template image.
    /// </summary>

    [Serializable]
    public sealed class MatchColorPatternOptions
    {
        private MatchMode _matchMode;
        private ImageFeatureMode _featureMode;
        private Int32 _minContrast;
        private bool _subpixelAccuracy;
        private Collection<Range> _rotationAngleRanges;
        private Int32 _numMatchesRequested;
        private double _minMatchScore;
        private double _colorWeight;
        private ColorSensitivity _colorSensitivity;
        private SearchStrategy _searchStrategy;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchColorPatternOptions class.
        /// </summary>

        public MatchColorPatternOptions()
            : this(MatchMode.ShiftInvariant)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchColorPatternOptions class.
        /// </summary>
        /// <param name="matchMode">
        /// The method to use when looking for the color pattern in the image. 
        /// </param>

        public MatchColorPatternOptions(MatchMode matchMode)
            : this(matchMode, 1)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchColorPatternOptions class.
        /// </summary>
        /// <param name="matchMode">
        /// The method to use when looking for the color pattern in the image. 
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// The number of valid matches expected. 
        /// </param>

        public MatchColorPatternOptions(MatchMode matchMode, Int32 numberOfMatchesRequested)
            : this(matchMode, numberOfMatchesRequested, ImageFeatureMode.ColorAndShape)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchColorPatternOptions class.
        /// </summary>
        /// <param name="matchMode">
        /// The method to use when looking for the color pattern in the image. 
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// The number of valid matches expected. 
        /// </param>
        /// <param name="featureMode">
        /// The features to use when looking for the color pattern in the image. 
        /// </param>

        public MatchColorPatternOptions(MatchMode matchMode, Int32 numberOfMatchesRequested, ImageFeatureMode featureMode)
            : this(matchMode, numberOfMatchesRequested, featureMode, ColorSensitivity.Low)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MatchColorPatternOptions class.
        /// </summary>
        /// <param name="matchMode">
        /// The method to use when looking for the color pattern in the image. 
        /// </param>
        /// <param name="numberOfMatchesRequested">
        /// The number of valid matches expected. 
        /// </param>
        /// <param name="featureMode">
        /// The features to use when looking for the color pattern in the image. 
        /// </param>
        /// <param name="colorSensitivity">
        /// The sensitivity of the color information in the image. 
        /// </param>

        public MatchColorPatternOptions(MatchMode matchMode, Int32 numberOfMatchesRequested, ImageFeatureMode featureMode, ColorSensitivity colorSensitivity)
        {
            _matchMode = matchMode;
            _featureMode = featureMode;
            _minContrast = 10;
            _subpixelAccuracy = false;
            _rotationAngleRanges = new Collection<Range>();
            _numMatchesRequested = numberOfMatchesRequested;
            _minMatchScore = 800.0;
            _colorWeight = 500;
            _colorSensitivity = colorSensitivity;
            _searchStrategy = SearchStrategy.Conservative;
        }
        //==========================================================================================
        /// <summary>
        /// Gets a collection of angle ranges, where each range specifies how much you expect the color template pattern to rotate in the image. Each range is specified by a lower angle and an upper angle, both of which are expressed in degrees.
        /// </summary>

        public Collection<Range> RotationAngleRanges
        {
            get { return _rotationAngleRanges; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the smallest score a match must have to be considered valid.
        /// </summary>
        /// <value>
        /// The default is 800.
        /// </value>

        public double MinimumMatchScore
        {
            get { return _minMatchScore; }
            set { _minMatchScore = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the number of valid matches expected. 
        /// </summary>
        /// <value>
        /// The default is 1.
        /// </value>

        public Int32 NumberOfMatchesRequested
        {
            get { return _numMatchesRequested; }
            set { _numMatchesRequested = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the match results are returned with subpixel accuracy. This 
        /// option is ignored if FeatureMode is set to Color. Set this parameter to <see langword="true"/> 
        /// to return areas in the image that match the pattern area with subpixel accuracy. 
        /// </summary>
        /// <value>
        /// The default is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast expected in the shape features of the color image.
        /// </summary>
        /// <value>
        /// The default is 10.
        /// </value>

        public Int32 MinimumContrast
        {
            get { return _minContrast; }
            set { _minContrast = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the technique to use when looking for the color template pattern in the color image.
        /// </summary>
        /// <value>
        /// The default is ShiftInvariant.
        /// </value>

        public MatchMode MatchMode
        {
            get { return _matchMode; }
            set { _matchMode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the features to use when looking for the color template pattern in the color image. 
        /// </summary>
        /// <value>
        /// The default is ColorAndShape.
        /// </value>

        public ImageFeatureMode FeatureMode
        {
            get { return _featureMode; }
            set { _featureMode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the percent contribution of the color score to the final color pattern matching score. Acceptable values range from 0 to 1000.
        /// </summary>
        /// <value>
        /// The default is 500, indicating that the match score uses an equal combination of the color and shape scores.
        /// </value>
        /// <remarks>
        /// The algorithm uses the color score weight for the final match ranking. For example, if you use a weight of 1000, the algorithm finds each match by using both color and shape information and then ranks the matches based on their color scores. If the weight is 0, the matches are ranked based on their shape scores. 
        /// </remarks>

        public double ColorWeight
        {
            get { return _colorWeight; }
            set { _colorWeight = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the level of sensitivity used to describe the color features in the image. 
        /// </summary>
        /// <value>
        /// The default is Low.
        /// </value>

        public ColorSensitivity ColorSensitivity
        {
            get { return _colorSensitivity; }
            set { _colorSensitivity = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the search strategy.
        /// </summary>
        /// <value>
        /// The default is Conservative.
        /// </value>

        public SearchStrategy SearchStrategy
        {
            get { return _searchStrategy; }
            set { _searchStrategy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchColorPatternOptions.
        /// </summary>
        /// <param name="other">
        /// A MatchColorPatternOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(MatchColorPatternOptions other)
        {
            return other != null && _searchStrategy == other._searchStrategy && _colorSensitivity == other._colorSensitivity && _colorWeight == other._colorWeight && _featureMode == other._featureMode && _matchMode == other._matchMode && _minContrast == other._minContrast && _subpixelAccuracy == other._subpixelAccuracy && Utilities.CollectionsEqual(_rotationAngleRanges, other._rotationAngleRanges) && _numMatchesRequested == other._numMatchesRequested && _minMatchScore == other._minMatchScore;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified MatchColorPatternOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of MatchColorPatternOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchColorPatternOptions other = (MatchColorPatternOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _searchStrategy.GetHashCode() ^ _colorSensitivity.GetHashCode() ^ _colorWeight.GetHashCode() ^ _featureMode.GetHashCode() ^ _matchMode.GetHashCode() ^ _minContrast.GetHashCode() ^ _subpixelAccuracy.GetHashCode() ^ _rotationAngleRanges.Count.GetHashCode() ^ _numMatchesRequested.GetHashCode() ^ _minMatchScore.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "MatchColorPatternOptions: MatchMode=" + _matchMode.ToString() + ", NumberOfMatchesRequested=" + _numMatchesRequested.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides properties that specify the set of circles to detect.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CircleDescriptor
    {
        private Range _radiusRange;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CircleDescriptor
        /// class.
        /// </summary>
        /// <param name="radiusRange">
        /// The range of radius allowed for a detected circle. 
        /// </param>
        /// <remarks>
        /// Use this method in application development environments where object creation may not be straightforward.
        /// </remarks>

        public CircleDescriptor(Range radiusRange)
        {
            if (radiusRange == null) { throw new ArgumentNullException("radiusRange"); }
            _radiusRange = radiusRange;
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CircleDescriptor
        /// class.
        /// </summary>
        /// <param name="minimumRadius">
        /// Minimum radius allowed for a detected circle.
        /// </param>
        /// <param name="maximumRadius">
        /// Maximum radius allowed for a detected circle.
        /// </param>
        /// <remarks>
        /// </remarks>

        public CircleDescriptor(double minimumRadius, double maximumRadius)
        {
            _radiusRange = new Range(minimumRadius, maximumRadius);
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of radius allowed for a detected circle.
        /// </summary>
        /// <value>
        /// </value>

        public Range RadiusRange
        {
            get { return _radiusRange; }
            set { _radiusRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleDescriptor.
        /// </summary>
        /// <param name="other">
        /// A CircleDescriptor instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CircleDescriptor other)
        {
            return other != null && Object.Equals(_radiusRange, other._radiusRange);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleDescriptor.</summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CircleDescriptor and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CircleDescriptor other = (CircleDescriptor)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _radiusRange.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CircleDescriptor: RadiusRange=" + _radiusRange.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the requirements for shapes that the function detects.
    /// </summary>

    [Serializable]
    public sealed class ShapeDetectionOptions
    {
        private GeometricMatchModes _mode;
        private Collection<Range> _rotationAngleRanges;
        private Range _scaleRange;
        private double _minimumMatchScore;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ShapeDetectionOptions class.
        /// </summary>

        public ShapeDetectionOptions()
            : this(GeometricMatchModes.ShiftInvariant)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ShapeDetectionOptions class.
        /// </summary>
        /// <param name="mode">
        /// The method to use when looking for the shape in the image.
        /// </param>

        public ShapeDetectionOptions(GeometricMatchModes mode)
            : this(mode, 800)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ShapeDetectionOptions class.
        /// </summary>
        /// <param name="mode">
        /// The method to use when looking for the shape in the image.
        /// </param>
        /// <param name="minimumMatchScore">
        /// The minimum score a match can have for the function to consider the match valid. 
        /// Acceptable values range from 0 to 1,000.
        /// </param>

        public ShapeDetectionOptions(GeometricMatchModes mode, double minimumMatchScore)
        {
            _mode = mode;
            _minimumMatchScore = minimumMatchScore;
            _rotationAngleRanges = new Collection<Range>();
            _scaleRange = new Range(75, 125);
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum score a match can have for the function to consider the match valid. Acceptable values range from 0 to 1,000.
        /// </summary>
        /// <value>
        /// The default is 800.
        /// </value>

        public double MinimumMatchScore
        {
            get { return _minimumMatchScore; }
            set { _minimumMatchScore = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets a range that specifies the sizes of the shapes you expect to be in 
        /// the image, expressed as a ratio percentage representing the size of the pattern 
        /// in the image divided by size of the original pattern multiplied by 100. The 
        /// method ignores this range if the Mode does not include ScaleInvariant.
        /// </summary>
        /// <value>
        /// The default is (75, 125).
        /// </value>

        public Range ScaleRange
        {
            get { return _scaleRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _scaleRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets an array of angle ranges, in degrees, where each range specifies how much you expect 
        /// the shape to be rotated in the image. To decrease the search time, limit the degrees of rotation 
        /// in which you expect to find the shape in the image. Pass null or Nothing for this element to allow all angles. 
        /// The ranges are ignored if the Mode does not include RotationInvariant. 
        /// </summary>

        public Collection<Range> RotationAngleRanges
        {
            get { return _rotationAngleRanges; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_rotationAngleRanges = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the method to use when looking for the shape in the image.
        /// </summary>
        /// <value>
        /// The default is ShiftInvariant.
        /// </value>

        public GeometricMatchModes Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ShapeDetectionOptions.
        /// </summary>
        /// <param name="other">
        /// A ShapeDetectionOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ShapeDetectionOptions other)
        {
            return other != null && _mode == other._mode && Utilities.CollectionsEqual(_rotationAngleRanges, other._rotationAngleRanges) && Object.Equals(_scaleRange, other._scaleRange) && _minimumMatchScore == other._minimumMatchScore;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ShapeDetectionOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ShapeDetectionOptions and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ShapeDetectionOptions other = (ShapeDetectionOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _mode.GetHashCode() ^ _rotationAngleRanges.Count.GetHashCode() ^ _scaleRange.GetHashCode() ^ _minimumMatchScore.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ShapeDetectionOptions: Mode=" + _mode.ToString() + ", MinimumMatchScore=" + _minimumMatchScore.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing a matched circle.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class CircleMatch
    {
        private PointContour _center;
        private double _radius;
        private double _score;
        private OvalContour _circle;

        //==========================================================================================
        /// <summary>
        /// Initializes an instance of the CircleMatch class.
        /// </summary>

        public CircleMatch()
        {
            _center = new PointContour();
            _circle = new OvalContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the circle detected.
        /// </summary>
        /// <value>
        /// </value>
        /// <remarks>
        /// This property is useful for passing directly to <see cref="NationalInstruments.Vision.Overlay.AddOval" crefType="PartiallyQualified"/>.
        /// </remarks>

        public OvalContour Circle
        {
            get { return _circle; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _circle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the score of the matched score from 0 to 1000, where 1000 represents a perfect match.
        /// </summary>
        /// <value>
        /// </value>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the radius of the matched circle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the location of the center of the matched circle.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleMatch.
        /// </summary>
        /// <param name="other">
        /// A CircleMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CircleMatch other)
        {
            return other != null && Object.Equals(_center, other._center) && _radius == other._radius && _score == other._score && Object.Equals(_circle, other._circle);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CircleMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CircleMatch
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CircleMatch other = (CircleMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _radius.GetHashCode() ^ _score.GetHashCode() ^ _circle.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CircleMatch: Center=" + _center.ToString() + ", Radius=" + _radius.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides properties that specify the ellipses to detect.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class EllipseDescriptor
    {
        private Range _minorRadiusRange;
        private Range _majorRadiusRange;

        //==========================================================================================
        /// <summary>
        /// Creates and returns an EllipseDescriptor object.
        /// </summary>
        /// <param name="majorRadiusRange">The range of the length of the semi-major axis allowed for a detected elilpse.
        /// </param>
        /// <param name="minorRadiusRange">The range of the length of the semi-minor axis allowed for a detected elilpse.
        /// </param>
        /// <remarks>
        /// </remarks>

        public EllipseDescriptor(Range majorRadiusRange, Range minorRadiusRange)
        {
            if (minorRadiusRange == null) { throw new ArgumentNullException("minorRadiusRange"); }
            if (majorRadiusRange == null) { throw new ArgumentNullException("majorRadiusRange"); }
            _minorRadiusRange = minorRadiusRange;
            _majorRadiusRange = majorRadiusRange;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the  range of the length of the semi-minor axis allowed for a detected elilpse.
        /// </summary>
        /// <value>
        /// </value>

        public Range MinorRadiusRange
        {
            get { return _minorRadiusRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _minorRadiusRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the range of the length of the semi-major axis allowed for a detected elilpse.
        /// </summary>
        /// <value>
        /// </value>

        public Range MajorRadiusRange
        {
            get { return _majorRadiusRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _majorRadiusRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseDescriptor.
        /// </summary>
        /// <param name="other">
        /// An EllipseDescriptor instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EllipseDescriptor other)
        {
            return other != null && Object.Equals(_minorRadiusRange, other._minorRadiusRange) && Object.Equals(_majorRadiusRange, other._majorRadiusRange);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseDescriptor.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EllipseDescriptor and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EllipseDescriptor other = (EllipseDescriptor)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _minorRadiusRange.GetHashCode() ^ _majorRadiusRange.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EllipseDescriptor: MinorRadiusRange=" + _minorRadiusRange.ToString() + ", MajorRadiusRange=" + _majorRadiusRange.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about a particular detected ellipse.
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class EllipseMatch
    {
        private PointContour _center;
        private double _majorRadius;
        private double _minorRadius;
        private double _rotation;
        private double _score;

        //==========================================================================================
        /// <summary>
        /// Creates and returns a EllipseMatch object.
        /// </summary>
        /// <remarks>
        /// </remarks>

        public EllipseMatch()
        {
            _center = new PointContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the score of the detected ellipse. Scores range from 01000.
        /// </summary>
        /// <value>
        /// </value>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the measure of the angle between the major axis of the detected ellipse and the horizontal axis.
        /// </summary>
        /// <value>
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the semi-minor axis of the detected ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public double MinorRadius
        {
            get { return _minorRadius; }
            set { _minorRadius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the semi-major axis of the detected ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public double MajorRadius
        {
            get { return _majorRadius; }
            set { _majorRadius = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the position of the center of the detected ellipse.
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _center = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseMatch.
        /// </summary>
        /// <param name="other">
        /// An EllipseMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EllipseMatch other)
        {
            return other != null && Object.Equals(_center, other._center) && _minorRadius == other._minorRadius && _majorRadius == other._majorRadius && _rotation == other._rotation && _score == other._score;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EllipseMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EllipseMatch and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EllipseMatch other = (EllipseMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _minorRadius.GetHashCode() ^ _majorRadius.GetHashCode() ^ _rotation.GetHashCode() ^ _score.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EllipseMatch: Center=" + _center.ToString() + ", MinorRadius=" + _minorRadius.ToString(CultureInfo.CurrentCulture) + ", MajorRadius=" + _majorRadius.ToString(CultureInfo.CurrentCulture);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Describes the lines the method searches for.
    /// </summary>

    [Serializable]
    public sealed class LineDescriptor
    {
        private Range _lengthRange;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineDescriptor class.
        /// </summary>
        /// <param name="lengthRange">
        /// The minimum and maximum length of a line the function will return. 
        /// </param>

        public LineDescriptor(Range lengthRange)
        {
            if (lengthRange == null) { throw new ArgumentNullException("lengthRange"); }
            _lengthRange = lengthRange;
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineDescriptor class.
        /// </summary>
        /// <param name="minimumLength">
        /// The minimum length of a line the function will return. 
        /// </param>
        /// <param name="maximumLength">
        /// The maximum length of a line the function will return. 
        /// </param>

        public LineDescriptor(double minimumLength, double maximumLength)
        {
            _lengthRange = new Range(minimumLength, maximumLength);
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum length of a line the method will return.
        /// </summary>

        public Range LengthRange
        {
            get { return _lengthRange; }
            set { _lengthRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineDescriptor.
        /// </summary>
        /// <param name="other">
        /// A LineDescriptor instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LineDescriptor other)
        {
            return other != null && Object.Equals(_lengthRange, other._lengthRange);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineDescriptor.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LineDescriptor
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LineDescriptor other = (LineDescriptor)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _lengthRange.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LineDescriptor: LengthRange=" + _lengthRange.ToString();
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Provides information describing a matched line.
    /// </summary>

    [Serializable]
    public sealed class LineMatch
    {
        private LineContour _line;
        private double _length;
        private double _rotation;
        private double _score;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LineMatch class.
        /// </summary>

        public LineMatch()
        {
            _line = new LineContour();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the score of the matched line. Scores range from 01000, where a score of 1000 indicates a perfect match.
        /// </summary>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the matched line. 
        /// </summary>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the length of the line measured in pixels from the start point to the end point. 
        /// </summary>

        public double Length
        {
            get { return _length; }
            set { _length = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the detected line.
        /// </summary>

        public LineContour Line
        {
            get { return _line; }
            set { if (value == null) { throw new ArgumentNullException("value"); } _line = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineMatch.
        /// </summary>
        /// <param name="other">
        /// A LineMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LineMatch other)
        {
            return other != null && Object.Equals(_line, other._line) && _length == other._length && _rotation == other._rotation && _score == other._score;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LineMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LineMatch
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LineMatch other = (LineMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _line.GetHashCode() ^ _length.GetHashCode() ^ _rotation.GetHashCode() ^ _score.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LineMatch: Line=" + _line.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information about the rectangles the method searches for.
    /// </summary>
    /// <remarks>
    /// Width is defined as the length of the shorter side of a rectangle and height is defined as the longer side of the rectangle you want to search for.
    /// </remarks>

    [Serializable]
    public sealed class RectangleDescriptor
    {
        private Range _widthRange;
        private Range _heightRange;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RectangleDescriptor class.
        /// </summary>
        /// <param name="widthRange">
        /// Specifies the minimum and maximum width allowed for a detected rectangle.
        /// </param>
        /// <param name="heightRange">
        /// Specifies the minimum and maximum height allowed for a detected rectangle.
        /// </param>

        public RectangleDescriptor(Range widthRange, Range heightRange)
        {
            if (widthRange == null) { throw new ArgumentNullException("widthRange"); }
            if (heightRange == null) { throw new ArgumentNullException("heightRange"); }
            _widthRange = widthRange;
            _heightRange = heightRange;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum width allowed for a detected rectangle.
        /// </summary>
        /// <value>
        /// </value>

        public Range WidthRange
        {
            get { return _widthRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _widthRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum and maximum height allowed for a detected rectangle.
        /// </summary>
        /// <value>
        /// </value>

        public Range HeightRange
        {
            get { return _heightRange; }
            set { if (value == null) { throw new ArgumentNullException("value"); }  _heightRange = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleDescriptor.
        /// </summary>
        /// <param name="other">
        /// A RectangleDescriptor instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RectangleDescriptor other)
        {
            return other != null && Object.Equals(_widthRange, other._widthRange) && Object.Equals(_heightRange, other._heightRange);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleDescriptor.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RectangleDescriptor
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RectangleDescriptor other = (RectangleDescriptor)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _widthRange.GetHashCode() ^ _heightRange.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RectangleDescriptor: WidthRange=" + _widthRange.ToString() + ", HeightRange=" + _heightRange.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides information describing a matched rectangle.
    /// </summary>
    /// <remarks>
    /// Width is defined as the length of the shorter side of a rectangle and height is defined as the longer side of the rectangle. 
    /// </remarks>

    [Serializable]
    public sealed class RectangleMatch
    {
        private Collection<PointContour> _corners;
        private double _rotation;
        private double _width;
        private double _height;
        private double _score;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RectangleMatch class.
        /// </summary>

        public RectangleMatch()
        {
            _corners = new Collection<PointContour>();
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the score of the matched rectangle. Scores range from 0 to 1000, where a score of 1000 indicates a perfect match. 
        /// </summary>
        /// <value>
        /// </value>

        public double Score
        {
            get { return _score; }
            set { _score = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the height of the matched rectangle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Height
        {
            get { return _height; }
            set { _height = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the matched rectangle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the orientation of the matched rectangle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the corners of the matched rectangle. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Corners
        {
            get { return _corners; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); }_corners = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleMatch.
        /// </summary>
        /// <param name="other">
        /// A RectangleMatch instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RectangleMatch other)
        {
            return other != null && Utilities.CollectionsEqual(_corners, other._corners) && _rotation == other._rotation && _width == other._width && _height == other._height && _score == other._score;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RectangleMatch.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RectangleMatch
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RectangleMatch other = (RectangleMatch)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _corners.Count.GetHashCode() ^ _rotation.GetHashCode() ^ _width.GetHashCode() ^ _height.GetHashCode() ^ _score.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RectangleMatch: Corners=" + _corners.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the measurements on particles in an image.
    /// </summary>

    [Serializable]
    public sealed class ParticleMeasurementsReport
    {
        private double[,] _pixelMeasurements;
        private double[,] _calibratedMeasurements;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleMeasurementsReport class.
        /// </summary>

        public ParticleMeasurementsReport() : this(new double[0,0])
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleMeasurementsReport class.
        /// </summary>
        /// <param name="pixelMeasurements">
        /// The measurements on the particles in the image, in pixel coordinates. 
        /// </param>

        public ParticleMeasurementsReport(double[,] pixelMeasurements) : this (pixelMeasurements, new double[0,0])
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ParticleMeasurementsReport class.
        /// </summary>
        /// <param name="pixelMeasurements">
        /// The measurements on the particles in the image, in pixel coordinates. 
        /// </param>
        /// <param name="calibratedMeasurements">
        /// The measurements on the particles in the image, in real-world coordinates. 
        /// </param>

        public ParticleMeasurementsReport(double[,] pixelMeasurements, double[,] calibratedMeasurements)
        {
            _pixelMeasurements = pixelMeasurements;
            _calibratedMeasurements = calibratedMeasurements;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the measurements on the particles in the image, in real-world coordinates. 
        /// </summary>

        public double[,] CalibratedMeasurements
        {
            get { return _calibratedMeasurements; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the measurements on the particles in the image, in pixel coordinates. 
        /// </summary>

        public double[,] PixelMeasurements
        {
            get { return _pixelMeasurements; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleMeasurementsReport.
        /// </summary>
        /// <param name="other">
        /// A ParticleMeasurementsReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ParticleMeasurementsReport other)
        {
            return other != null && Utilities.ArraysEqual(_pixelMeasurements, other._calibratedMeasurements) && Utilities.ArraysEqual(_calibratedMeasurements, other._calibratedMeasurements);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ParticleMeasurementsReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ParticleMeasurementsReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ParticleMeasurementsReport other = (ParticleMeasurementsReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_pixelMeasurements != null) ? _pixelMeasurements.GetHashCode() : 0) ^ ((_calibratedMeasurements != null) ? _calibratedMeasurements.GetHashCode() : 0);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ParticleMeasurementsReport: " +
                ((_pixelMeasurements != null) ? ("PixelMeasurements: " + _pixelMeasurements.ToString()) : "") +
                ((_calibratedMeasurements != null) ? ("CalibratedMeasurements: " + _calibratedMeasurements.ToString()) : "");
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the Texture Features Extracted from the wavelets after the wavelet transformation.
    /// </summary>

    [Serializable]
    public sealed class TextureFeaturesReport
    {
        private Collection<int> _waveletBands;
        private double[,] _textureFeatures;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the TextureFeaturesReport class.
        /// </summary>

        public TextureFeaturesReport()
            : this(new double[0, 0])
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the TextureFeaturesReport class.
        /// </summary>
        /// <param name="textureFeatures">
        /// The texture features extracted from wavelets. 
        /// </param>

        public TextureFeaturesReport(double[,] textureFeatures)
            : this(textureFeatures, new Collection<int>())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the TextureFeaturesReport class.
        /// </summary>
        /// <param name="textureFeatures">
        /// The texture features extracted from wavelets. 
        /// </param>
        /// <param name="waveletBands">
        /// The wavelet bands used for Texture Feature extraction. 
        /// </param>

        public TextureFeaturesReport(double[,] textureFeatures, Collection<int> waveletBands)
        {
            _textureFeatures = textureFeatures;
            _waveletBands = waveletBands;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the texture features extracted. 
        /// </summary>

        public double[,] TextureFeatures
        {
            get { return _textureFeatures; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the wavelet bands used. 
        /// </summary>

        public Collection<int> WaveletBands
        {
            get { return _waveletBands; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified TextureFeaturesReport.
        /// </summary>
        /// <param name="other">
        /// A TextureFeaturesReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(TextureFeaturesReport other)
        {
            return other != null && _waveletBands.Equals(other._waveletBands) && Utilities.ArraysEqual(_textureFeatures, other._textureFeatures);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified TextureFeaturesReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of TextureFeaturesReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            TextureFeaturesReport other = (TextureFeaturesReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_textureFeatures != null) ? _textureFeatures.GetHashCode() : 0) ^ _waveletBands.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "TextureFeaturesReport: " +
                ((_textureFeatures != null) ? ("TextureFeatures: " + _textureFeatures.ToString()) : "") +
                ((_waveletBands.Count != 0) ? ("WaveletBands: " + _waveletBands.ToString()) : "");
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Wavelet Banks extracted from the wavelets after the wavelet transformation.
    /// </summary>

    [Serializable]
    public sealed class WaveletBandsReport
    {
        private float[,] _LLBand, _LHBand, _HLBand, _HHBand, _LLLBand, _LLHBand, _LHLBand, _LHHBand;
        private Int32 _rows, _cols;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the WaveletBandsReport class.
        /// </summary>

        public WaveletBandsReport()
            : this(new float[0, 0], new float[0, 0], new float[0, 0], new float[0, 0], new float[0, 0], new float[0, 0], new float[0, 0], new float[0, 0], 0, 0)
        {
        }
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the WaveletBandsReport class.
        /// </summary>
        /// <param name="LL">
        /// 2-D Array for LL band
        /// </param>
        /// <param name="LH">
        /// 2-D Array for LH band
        /// </param>
        /// <param name="HL">
        /// 2-D Array for HL band
        /// </param>
        /// <param name="HH">
        /// 2-D Array for HH band
        /// </param>
        /// <param name="LLL">
        /// 2-D Array for LLL band
        /// </param>
        /// <param name="LLH">
        /// 2-D Array for LLH band
        /// </param>
        /// <param name="LHL">
        /// 2-D Array for LHL band
        /// </param>
        /// <param name="LHH">
        /// 2-D Array for LHH band
        /// </param>
        /// <param name="rows">
        /// Number of Rows in each Band retrieved
        /// </param>
        /// <param name="cols">
        /// Number of Columns in each Band retrieved
        /// </param>

        public WaveletBandsReport(float[,] LL, float[,] LH, float[,] HL, float[,] HH, float[,] LLL, float[,] LLH, float[,] LHL, float[,] LHH, int rows, int cols)
        {
            _LLBand = LL;
            _LHBand = LH;
            _HLBand = HL;
            _HHBand = HH;
            _LLLBand = LLL;
            _LLHBand = LLH;
            _LHLBand = LHL;
            _LHHBand = LHH;
            _rows = rows;
            _cols = cols;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the LL Band. 
        /// </summary>

        public float[,] LL
        {
            get { return _LLBand; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets the LH Band. 
        /// </summary>

        public float[,] LH
        {
            get { return _LHBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the HL Band. 
        /// </summary>

        public float[,] HL
        {
            get { return _HLBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the HH Band. 
        /// </summary>

        public float[,] HH
        {
            get { return _HHBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the LLL Band. 
        /// </summary>

        public float[,] LLL
        {
            get { return _LLLBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the LLH Band. 
        /// </summary>

        public float[,] LLH
        {
            get { return _LLHBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the LHL Band. 
        /// </summary>

        public float[,] LHL
        {
            get { return _LHLBand; }
        }//==========================================================================================
        /// <summary>
        /// Gets the LHH Band. 
        /// </summary>

        public float[,] LHH
        {
            get { return _LHHBand; }
        }
        /// <summary>
        /// Gets the number of Rows of Bands retrieved. 
        /// </summary>

        public int Rows
        {
            get { return _rows; }
        }
        /// <summary>
        /// Gets the number of Columns of Bands retrieved. 
        /// </summary>

        public int Cols
        {
            get { return _cols; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WaveletBandsReport.
        /// </summary>
        /// <param name="other">
        /// A WaveletBandsReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(WaveletBandsReport other)
        {
            return other != null && Utilities.ArraysEqual(_LLBand, other._LLBand) && Utilities.ArraysEqual(_LHBand, other._LHBand) && Utilities.ArraysEqual(_HLBand, other._HLBand) && Utilities.ArraysEqual(_HHBand, other._HHBand) && Utilities.ArraysEqual(_LLLBand, other._LLLBand) && Utilities.ArraysEqual(_LLHBand, other._LLHBand) && Utilities.ArraysEqual(_LHLBand, other._LHLBand) && Utilities.ArraysEqual(_LHHBand, other._LHHBand) && _rows == other._rows && _cols == other._cols;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified WaveletBandsReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of WaveletBandsReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            WaveletBandsReport other = (WaveletBandsReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_LLBand != null) ? _LLBand.GetHashCode() : 0) ^ ((_LHBand != null) ? _LHBand.GetHashCode() : 0) ^ ((_HLBand != null) ? _HLBand.GetHashCode() : 0) ^ ((_HHBand != null) ? _HHBand.GetHashCode() : 0) ^ ((_LLLBand != null) ? _LLLBand.GetHashCode() : 0) ^ ((_LLHBand != null) ? _LLHBand.GetHashCode() : 0) ^ ((_LHLBand != null) ? _LHLBand.GetHashCode() : 0) ^ ((_LHHBand != null) ? _LHHBand.GetHashCode() : 0) ^ (_rows.GetHashCode()) ^ (_cols.GetHashCode());
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "WaveletBandssReport: " +
                ((_LLBand != null) ? ("LL Band: " + _LLBand.ToString()) : "") +
                ((_LHBand != null) ? ("LH Band: " + _LLBand.ToString()) : "") +
                ((_HLBand != null) ? ("HL Band: " + _LLBand.ToString()) : "") +
                ((_HHBand != null) ? ("HH Band: " + _LLBand.ToString()) : "") +
                ((_LLLBand != null) ? ("LLL Band: " + _LLBand.ToString()) : "") +
                ((_LLHBand != null) ? ("LLH Band: " + _LLBand.ToString()) : "") +
                ((_LHLBand != null) ? ("LHL Band: " + _LLBand.ToString()) : "") +
                ((_LHHBand != null) ? ("LHH Band: " + _LLBand.ToString()) : "") +
                (" Rows : " + _rows) + ("Cols : " + _cols);
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Cooccurrence Matrix Report.
    /// </summary>

    [Serializable]
    public sealed class CooccurrenceMatrixReport
    {
        private double[,] _cooccurrenceMatrix;
        private double[] _featureVector;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CooccurrenceMatrixReport class.
        /// </summary>

        public CooccurrenceMatrixReport()
            : this(new double[0, 0], new double[0])
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CooccurrenceMatrixReport class.
        /// </summary>
        /// <param name="cooccurrenceMatrix">
        /// 2-D Array for CooccurrenceMatrix
        /// </param>
        /// <param name="featureVector">
        /// 2-D Array for FeatureVector
        /// </param>

        public CooccurrenceMatrixReport(double[,] cooccurrenceMatrix, double[] featureVector)
        {
            _cooccurrenceMatrix = cooccurrenceMatrix;
            _featureVector = featureVector;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the CooccurrenceMatrix. 
        /// </summary>

        public double[,] CooccurrenceMatrix
        {
            get { return _cooccurrenceMatrix; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets the featureVector. 
        /// </summary>

        public double[] FeatureVector
        {
            get { return _featureVector; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CooccurrenceMatrixReport.
        /// </summary>
        /// <param name="other">
        /// A CooccurrenceMatrixReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CooccurrenceMatrixReport other)
        {
            return other != null && Utilities.ArraysEqual(_cooccurrenceMatrix, other._cooccurrenceMatrix) && Utilities.ArraysEqual(_featureVector, other._featureVector);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CooccurrenceMatrixReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CooccurrenceMatrixReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CooccurrenceMatrixReport other = (CooccurrenceMatrixReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_cooccurrenceMatrix != null) ? _cooccurrenceMatrix.GetHashCode() : 0) ^ ((_featureVector != null) ? _featureVector.GetHashCode() : 0);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CooccurrenceMatrixReport: " +
                ((_cooccurrenceMatrix != null) ? ("Cooccurrence Matrix: " + _cooccurrenceMatrix.ToString()) : "") +
                ((_featureVector != null) ? ("Feature Vector: " + _featureVector.ToString()) : "");
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the Curve Parameters used in contour extraction.
    /// </summary>

    [Serializable]
    public sealed class CurveParameters
    {
        private ExtractionMode _extractionMode;
        private Int32 _threshold;
        private EdgeFilterSize _filterSize;
        private Int32 _minimumLength;
        private Int32 _searchStepSize;
        private Int32 _maximumEndPointGap;
        private bool _subpixelAccuracy;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveParameters class.
        /// </summary>

        public CurveParameters()
            : this(ExtractionMode.NormalImage)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveParameters class.
        /// </summary>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>

        public CurveParameters(ExtractionMode extractionMode)
            : this(extractionMode, EdgeFilterSize.Normal)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveParameters class.
        /// </summary>        
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>
        /// <param name="filterSize">The width of the edge filter the method uses to identify curves in the image.
        /// </param>

        public CurveParameters(ExtractionMode extractionMode, EdgeFilterSize filterSize)
            : this(extractionMode, filterSize, true)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveParameters class.
        /// </summary>        
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>
        /// <param name="filterSize">The width of the edge filter the method uses to identify curves in the image.
        /// </param>

        public CurveParameters(ExtractionMode extractionMode, EdgeFilterSize filterSize, bool subpixelAccuracy)
            : this(extractionMode, 75, filterSize, 25, 15, 10, subpixelAccuracy)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CurveParamter class.
        /// </summary>
        /// <param name="extractionMode">How the method identifies curves in the image.
        /// </param>

        public CurveParameters(ExtractionMode extractionMode, Int32 threshold, EdgeFilterSize filterSize, Int32 minimumLength, Int32 searchStepSize, Int32 maximumEndPointGap, bool subpixelAccuracy)
        {
            _subpixelAccuracy = subpixelAccuracy;
            _extractionMode = extractionMode;
            _filterSize = filterSize;
            _threshold = threshold;
            _searchStepSize = searchStepSize;
            _maximumEndPointGap = maximumEndPointGap;
            _minimumLength = minimumLength;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the method identifies the location of curves with subpixel accuracy by interpolating between points to find the crossing of the threshold.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool SubpixelAccuracy
        {
            get { return _subpixelAccuracy; }
            set { _subpixelAccuracy = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve.
        /// </summary>
        /// <value>The default value is 10.
        /// </value>

        public int MaximumEndPointGap
        {
            get { return _maximumEndPointGap; }
            set { _maximumEndPointGap = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the distance, in the y direction, between rows of pixels in the image that the method inspects for curve seed points.
        /// </summary>
        /// <value>
        /// Valid values for this property range from 1 to 255. The default value is 15.
        /// </value>
        /// <remarks>
        /// Set this value to be smaller than the minimum width of the object you want to detect in the image.
        /// </remarks>

        public int SearchStepSize
        {
            get { return _searchStepSize; }
            set { _searchStepSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the length, in pixels, of the smallest curve the method will extract.
        /// </summary>
        /// <value>The default value is 25.
        /// </value>
        /// <remarks>
        /// This property ignores curves that have a length less than MinimumLength pixels.
        /// </remarks>

        public int MinimumLength
        {
            get { return _minimumLength; }
            set { _minimumLength = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the width of the edge filter the method uses to identify curves in the image.
        /// </summary>
        /// <value>The default value for this property is <see cref="NationalInstruments.Vision.Analysis.EdgeFilterSize.Normal" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// </remarks>

        public EdgeFilterSize FilterSize
        {
            get { return _filterSize; }
            set { _filterSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the minimum contrast a seed point must have for the method to begin a curve.
        /// </summary>
        /// <value>The default value is 75. Valid values for this property range from 1 to 360. 
        /// </value>

        public int Threshold
        {
            get { return _threshold; }
            set { _threshold = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets how the method identifies curves in the image.
        /// </summary>
        /// <value>The default value is <see cref="NationalInstruments.Vision.Analysis.ExtractionMode.NormalImage" crefType="Unqualified"/>.
        /// </value>
        /// <remarks>
        /// </remarks>

        public ExtractionMode ExtractionMode
        {
            get { return _extractionMode; }
            set { _extractionMode = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveParameters.
        /// </summary>
        /// <param name="other">
        /// A CurveOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CurveParameters other)
        {
            return other != null && _extractionMode == other._extractionMode && _threshold == other._threshold && _filterSize == other._filterSize && _minimumLength == other._minimumLength && _searchStepSize == other._searchStepSize && _maximumEndPointGap == other._maximumEndPointGap && _subpixelAccuracy == other._subpixelAccuracy;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CurveParameters.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CurveParameters and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CurveParameters other = (CurveParameters)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _extractionMode.GetHashCode() ^ _threshold.GetHashCode() ^ _filterSize.GetHashCode() ^ _minimumLength.GetHashCode() ^ _searchStepSize.GetHashCode() ^ _maximumEndPointGap.GetHashCode() ^ _subpixelAccuracy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CurveParameters: ExtractionMode=" + _extractionMode.ToString() + ", FilterSize=" + _filterSize.ToString() +
                ", Minimum Length="+_minimumLength +", Search Step Size="+ _searchStepSize+", Maximum End Point Gap="+_maximumEndPointGap+
                ", Subpixel Accuracy"+_subpixelAccuracy;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the Connection constraints of the contour.
    /// </summary>

    [Serializable]
    public sealed class ConnectionConstraint
    {
        private ConnectionConstraintType _constraintType;
        private Range _range;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConnectionConstraint class.
        /// </summary>

        public ConnectionConstraint()
            : this(ConnectionConstraintType.Angle)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConnectionConstraint class.
        /// </summary>
        /// <param name="constraintType">specifies what criteria to use to consider two curves part of a contour.
        /// </param>

        public ConnectionConstraint(ConnectionConstraintType constraintType)
            : this(constraintType, new Range(0, 0))
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ConnectionConstraint class.
        /// </summary>
        /// <param name="constraintType">specifies what criteria to use to consider two curves part of a contour.
        /// </param>
        /// <param name="range">specifies the range for a given Match Constraint.
        /// </param>

        public ConnectionConstraint(ConnectionConstraintType constraintType, Range range)
        {
            _constraintType = constraintType;
            _range = range;
        }

        //==========================================================================================
        /// <summary>
        /// Constraint Type specifies what criteria to use to consider two curves part of a contour
        /// </summary>

        public ConnectionConstraintType ConstraintType
        {
            get { return _constraintType; }
            set { _constraintType = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies range for a given Match Constraint
        /// </summary>
        /// <remarks>
        /// Make sure max value is greater than the min value.
        /// </remarks>

        public Range Range
        {
            get { return _range; }
            set { _range = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConnectionConstraint.
        /// </summary>
        /// <param name="other">
        /// A ConnectionConstraint instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ConnectionConstraint other)
        {
            return other != null && _constraintType == other._constraintType && _range == other._range;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ConnectionConstraint.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ConnectionConstraint and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ConnectionConstraint other = (ConnectionConstraint)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _constraintType.GetHashCode() ^ _range.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ConnectionConstraint: ContraintType=" + _constraintType.ToString() + ", Range=" + _range.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies the Connection constraints of the contour.
    /// </summary>

    [Serializable]
    public sealed class ContourOverlaySettings
    {
        private bool _overlay;
        private Rgb32Value _color;
        private UInt32 _width;
        private bool _maintainWidth;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourOverlaySettings class.
        /// </summary>

        public ContourOverlaySettings()
            : this(false)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourOverlaySettings class.
        /// </summary>

        public ContourOverlaySettings(bool overlay)
            : this(overlay, new Rgb32Value())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourOverlaySettings class.
        /// </summary>

        public ContourOverlaySettings(bool overlay, Rgb32Value color)
            : this(overlay, color, 0, true)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourOverlaySettings class.
        /// </summary>

        public ContourOverlaySettings(bool overlay, Rgb32Value color, UInt32 width, bool maintainWidth)
        {
            _overlay = overlay;
            _color = color;
            _width = width;
            _maintainWidth = maintainWidth;
        }

        //==========================================================================================
        /// <summary>
        /// Overlay specifies whether to display the overlay on the image.
        /// </summary>

        public bool Overlay
        {
            get { return _overlay; }
            set { _overlay = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Color is the color of the overlay.
        /// </summary>

        public Rgb32Value Color
        {
            get { return _color; }
            set { _color = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Width specifies the width of the overlay in pixels.
        /// </summary>

        public UInt32 Width
        {
            get { return _width; }
            set { _width = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Maintain Width specifies whether you want the overlay measured in screen pixels or image pixels.
        /// </summary>

        public bool MaintainWidth
        {
            get { return _maintainWidth; }
            set { _maintainWidth = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourOverlaySettings.
        /// </summary>
        /// <param name="other">
        /// A ContourOverlaySettings instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourOverlaySettings other)
        {
            return other != null && _maintainWidth == other._maintainWidth && _width == other._width && _color.Equals(other._color) && _overlay == other._overlay;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourOverlaySettings.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourOverlaySettings and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourOverlaySettings other = (ContourOverlaySettings)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _overlay.GetHashCode() ^ _color.GetHashCode() ^ _width.GetHashCode() ^ _maintainWidth.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourOverlaySettings: overlay=" + _overlay.ToString() + ", Color=" + _color.ToString() + ", Width=" + _width + ", MaintainWidth=" + _maintainWidth.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Parameters to classify curvature.
    /// </summary>

    [Serializable]
    public sealed class RangeLabel
    {
        private Range _range;
        private UInt32 _label;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RangeLabel class.
        /// </summary>

        public RangeLabel(Range range, UInt32 label)
        {
            _range = range;
            _label = label;
        }

        //==========================================================================================
        /// <summary>
        /// Range of values.
        /// </summary>

        public Range Range
        {
            get { return _range; }
            set { _range = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Label of the range.
        /// </summary>

        public UInt32 Label
        {
            get { return _label; }
            set { _label = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RangeLabel.
        /// </summary>
        /// <param name="other">
        /// A RangeLabel instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RangeLabel other)
        {
            return other != null && _range == other._range && _label == other._label;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RangeLabel.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RangeLabel and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RangeLabel other = (RangeLabel)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _range.GetHashCode() ^ _label.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RangeLabel: range=" + _range.ToString() + ", Label=" + _label;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Setup Match pattern data.
    /// </summary>

    [Serializable]
    public sealed class SetupMatchPatternData
    {
        private Collection<char> _matchPatternData;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SetupMatchPatternData class.
        /// </summary>

        public SetupMatchPatternData()
            : this(new Collection<char>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the SetupMatchPatternData class.
        /// </summary>

        public SetupMatchPatternData(Collection<char> matchPatternData)
        {
            _matchPatternData = matchPatternData;
        }

        //==========================================================================================
        /// <summary>
        /// Match pattern Data.
        /// </summary>

        public Collection<char> MatchPatternData
        {
            get { return _matchPatternData; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _matchPatternData = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SetupMatchPatternData.
        /// </summary>
        /// <param name="other">
        /// A SetupMatchPatternData instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(SetupMatchPatternData other)
        {
            return other != null && _matchPatternData == other._matchPatternData;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified SetupMatchPatternData.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of SetupMatchPatternData and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            SetupMatchPatternData other = (SetupMatchPatternData)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _matchPatternData.GetHashCode();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Curvature Analysis Report data.
    /// </summary>

    [Serializable]
    public sealed class ClassifiedCurve
    {
        private double _length; // Pixel
        private double _lengthReal;
        private double _maxCurvature; // Pixel
        private double _maxCurvatureReal;
        private UInt32 _label;
        private Collection<PointContour> _curvePoints;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedCurve class.
        /// </summary>

        public ClassifiedCurve()
            : this(0, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedCurve class.
        /// </summary>

        public ClassifiedCurve(double length, double lengthReal)
            : this(length, lengthReal, 0, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedCurve class.
        /// </summary>

        public ClassifiedCurve(double length, double lengthReal, double maxCurvature, double maxCurvatureReal)
            : this(length, lengthReal, maxCurvature, maxCurvatureReal, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedCurve class.
        /// </summary>

        public ClassifiedCurve(double length, double lengthReal, double maxCurvature, double maxCurvatureReal, UInt32 label)
            : this(length, lengthReal, maxCurvature, maxCurvatureReal, label, new Collection<PointContour>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedCurve class.
        /// </summary>

        public ClassifiedCurve(double length, double lengthReal, double maxCurvature, double maxCurvatureReal, UInt32 label, Collection<PointContour> curvePoints)
        {
            _length = length;
            _lengthReal = lengthReal;
            _maxCurvature = maxCurvature;
            _maxCurvatureReal = maxCurvatureReal;
            _label = label;
            _curvePoints = curvePoints;
        }            //==========================================================================================
        /// <summary>
        /// Specifies the length, in pixels, of the curves within the curvature range.
        /// </summary>

        public double Length
        {
            get { return _length; }
            set { _length = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the length, in calibrated units, of the curves within the curvature range
        /// </summary>

        public double LengthReal
        {
            get { return _lengthReal; }
            set { _lengthReal = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the maximum curvature, in pixels, for the selected curvature range
        /// </summary>

        public double MaxCurvature
        {
            get { return _maxCurvature; }
            set { _maxCurvature = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the maximum curvature, in calibrated units, for the selected curvature range
        /// </summary>

        public double MaxCurvatureReal
        {
            get { return _maxCurvatureReal; }
            set { _maxCurvatureReal = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the class to which the the sample belongs
        /// </summary>

        public UInt32 Label
        {
            get { return _label; }
            set { _label = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Curve Points is a point-coordinate cluster that defines the points of the curve
        /// </summary>

        public Collection<PointContour> CurvePoints
        {
            get { return _curvePoints; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _curvePoints = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifiedCurve.
        /// </summary>
        /// <param name="other">
        /// A ClassifiedCurve instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifiedCurve other)
        {
            return other != null && _length == other._length && _lengthReal == other._lengthReal && _maxCurvature == other._maxCurvature && _maxCurvatureReal == other._maxCurvatureReal && _label == other._label && _curvePoints.Equals(other._curvePoints);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifiedCurve.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassifiedCurve and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifiedCurve other = (ClassifiedCurve)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _length.GetHashCode() ^ _lengthReal.GetHashCode() ^ _maxCurvature.GetHashCode() ^ _maxCurvatureReal.GetHashCode() ^ _label.GetHashCode() ^ ((_curvePoints != null) ? _curvePoints.GetHashCode() : 0);
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifiedCurve: Length =" + _length + ", Length Real =" + _lengthReal
                + ", MaxCurvature=" + _maxCurvature + ", MaxcurvatureReal=" + _maxCurvatureReal + ", Label=" + _label
                + ", CurvePoints=" + _curvePoints;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Curvature Analysis Report data.
    /// </summary>

    [Serializable]
    public sealed class Disparity
    {
        private PointContour _currentPoint;
        private PointContour _referencePoint;
        private double _distance;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the Disparity class.
        /// </summary>

        public Disparity()
            : this(new PointContour())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the Disparity class.
        /// </summary>

        public Disparity(PointContour currentPoint)
            : this(currentPoint, new PointContour())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the Disparity class.
        /// </summary>

        public Disparity(PointContour currentPoint, PointContour referencePoint)
            : this(currentPoint, referencePoint, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the Disparity class.
        /// </summary>

        public Disparity(PointContour currentPoint, PointContour referencePoint, double distance)
        {
            _currentPoint = currentPoint;
            _referencePoint = referencePoint;
            _distance = distance;
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the current point.
        /// </summary>

        public PointContour CurrentPoint
        {
            get { return _currentPoint; }
            set { _currentPoint = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the reference point.
        /// </summary>

        public PointContour ReferencePoint
        {
            get { return _referencePoint; }
            set { _referencePoint = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the current point.
        /// </summary>

        public double Distance
        {
            get { return _distance; }
            set { _distance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Disparity.
        /// </summary>
        /// <param name="other">
        /// A Disparity instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(Disparity other)
        {
            return other != null && _currentPoint.Equals(other._currentPoint) && _referencePoint.Equals(other._referencePoint) && _distance == other._distance;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified Disparity.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of Disparity and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            Disparity other = (Disparity)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _currentPoint.GetHashCode() ^ _referencePoint.GetHashCode() ^ _distance.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "Disparity: CurrentPoint=" + _currentPoint.ToString() + ", ReferencePoint=" + _referencePoint.ToString()
                + ", Distance=" + _distance;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Classify Distances Report data.
    /// </summary>

    [Serializable]
    public sealed class ClassifiedDisparity
    {
        private double _length;
        private double _lengthReal;
        private double _maxDistance;
        private double _maxDistanceReal;
        private UInt32 _label;
        private Collection<PointContour> _templateSubsectionPoints;
        private Collection<PointContour> _targetSubsectionPoints;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedDisparity class.
        /// </summary>

        public ClassifiedDisparity()
            : this(0, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedDisparity class.
        /// </summary>

        public ClassifiedDisparity(double length, double lengthReal)
            : this(length, lengthReal, 0, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedDisparity class.
        /// </summary>

        public ClassifiedDisparity(double length, double lengthReal, double maxDistance, double maxDistanceReal)
            : this(length, lengthReal, maxDistance, maxDistanceReal, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedDisparity class.
        /// </summary>

        public ClassifiedDisparity(double length, double lengthReal, double maxDistance, double maxDistanceReal, UInt32 label)
            : this(length, lengthReal, maxDistance, maxDistanceReal, label, new Collection<PointContour>(), new Collection<PointContour>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifiedDisparity class.
        /// </summary>

        public ClassifiedDisparity(double length, double lengthReal, double maxDistance, double maxDistanceReal, UInt32 label, Collection<PointContour> templateSubsectionPoints, Collection<PointContour> targetSubsectionPoints)
        {
            _length = length;
            _lengthReal = lengthReal;
            _maxDistance = maxDistance;
            _maxDistanceReal = maxDistanceReal;
            _label = label;
            _templateSubsectionPoints = templateSubsectionPoints;
            _targetSubsectionPoints = targetSubsectionPoints;
        }        //==========================================================================================
        /// <summary>
        /// Length (pixel) specifies the length, in pixels, of the curves within the curvature range.
        /// </summary>

        public double Length
        {
            get { return _length; }
            set { _length = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Length (real) specifies the length, in calibrated units, of the curves within the curvature range.
        /// </summary>

        public double LengthReal
        {
            get { return _lengthReal; }
            set { _lengthReal = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Maximum Distance (pixel) specifies the maximum distance, in pixels, between points along the selected contour and the template contour.
        /// </summary>

        public double MaximumDistance
        {
            get { return _maxDistance; }
            set { _maxDistance = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Maximum Distance (pixel) specifies the maximum distance, in calibrated units, between points along the selected contour and the template contour.
        /// </summary>

        public double MaximumDistanceReal
        {
            get { return _maxDistanceReal; }
            set { _maxDistanceReal = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Class Label specifies the class to which the the sample belongs.
        /// </summary>

        public UInt32 Label
        {
            get { return _label; }
            set { _label = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Template subsection points is an array of points that defines the boundary of the template.
        /// </summary>

        public Collection<PointContour> TemplateSubsectionPoints
        {
            get { return _templateSubsectionPoints; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _templateSubsectionPoints = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Target subsection points is an array of points that defines the boundary of the target.
        /// </summary>

        public Collection<PointContour> TargetSubsectionPoints
        {
            get { return _targetSubsectionPoints; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _targetSubsectionPoints = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifiedDisparity.
        /// </summary>
        /// <param name="other">
        /// A ClassifiedDisparity instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifiedDisparity other)
        {
            return other != null && _length == other._length && _lengthReal == other._lengthReal && _maxDistance == other._maxDistance && _maxDistanceReal == other._maxDistanceReal && _label == other._label && _templateSubsectionPoints.Equals(other._templateSubsectionPoints) && _targetSubsectionPoints.Equals(other._targetSubsectionPoints);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifiedDisparity.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassifiedDisparity and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifiedDisparity other = (ClassifiedDisparity)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _length.GetHashCode() ^ _lengthReal.GetHashCode() ^ _maxDistance.GetHashCode() ^ _maxDistanceReal.GetHashCode() ^ _label.GetHashCode() ^ ((_templateSubsectionPoints != null) ? _templateSubsectionPoints.GetHashCode() : 0) ^ ((_targetSubsectionPoints != null) ? _targetSubsectionPoints.GetHashCode() : 0);
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifiedDisparity: Length=" + _length + ", LengthReal=" + _lengthReal
                + ", MaxDistance=" + _maxDistance + ", MaxDistanceReal=" + _maxDistanceReal + ", Label=" + _label
                + ", TemplateSubsectionPoints=" + _templateSubsectionPoints + ", TargetSubsectionPoints=" + _targetSubsectionPoints;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Identifies the conditions under which you want to find template matches.
    /// </summary>

    [Serializable]
    public sealed class ContourMatchMode
    {
        private bool _rotation;
        private bool _scale;
        private bool _occlusion;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricMatchMode class.
        /// </summary>

        public ContourMatchMode()
            : this(true, false, false)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricMatchMode class.
        /// </summary>

        public ContourMatchMode(bool rotation, bool scale, bool occlusion)
        {
            _rotation = rotation;
            _scale = scale;
            _occlusion = occlusion;
        }        //==========================================================================================
        /// <summary>
        ///  When enabled, the function searches for occurrences of the template in the inspection image, allowing for template matches to be rotated.
        /// </summary>

        public bool Rotation
        {
            get { return _rotation; }
            set { _rotation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// When enabled, the function searches for occurrences of the template in the inspection image regardless of whether possible matches are of a different size in the inspection image.
        /// </summary>

        public bool Scale
        {
            get { return _scale; }
            set { _scale = value; }
        }

        //==========================================================================================
        /// <summary>
        /// specifies whether or not to search for occluded versions of the shape.
        /// </summary>

        public bool Occlusion
        {
            get { return _occlusion; }
            set { _occlusion = value; }
        }        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricMatchMode.
        /// </summary>
        /// <param name="other">
        /// A GeometricMatchMode instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourMatchMode other)
        {
            return other != null && _scale == other._scale && _rotation == other._rotation && _occlusion == other._occlusion;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricMatchMode.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GeometricMatchMode and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MatchMode other = (MatchMode)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _scale.GetHashCode() ^ _rotation.GetHashCode() ^ _occlusion.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GeometricMatchMode Scale=" + _scale.ToString() + ", Rotation=" + _rotation.ToString()
                + ", Occlusion=" + _occlusion;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Specifies acceptable ranges for each Match Constraints option
    /// </summary>

    [Serializable]
    public sealed class RangeSettings
    {
        private SettingType _type;
        private double _minimum;
        private double _maximum;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RangeSettings class.
        /// </summary>

        public RangeSettings()
            : this(SettingType.RotationAngle)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RangeSettings class.
        /// </summary>

        public RangeSettings(SettingType settingType)
            : this(settingType, 0, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the RangeSettings class.
        /// </summary>

        public RangeSettings(SettingType type, double minimum, double maximum)
        {
            _type = type;
            _maximum = maximum;
            _minimum = minimum;
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the match option whose values you want to constrain by the given range.
        /// </summary>

        public SettingType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the minimum value of the range for a given Match Constraint.
        /// </summary>

        public double Minimum
        {
            get { return _minimum; }
            set { _minimum = value; }
        }

        //==========================================================================================
        /// <summary>
        /// specifies the maximum value of the range for a given Match Constraint.
        /// </summary>

        public double Maximum
        {
            get { return _maximum; }
            set { _maximum = value; }
        }        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RangeSettings.
        /// </summary>
        /// <param name="other">
        /// A RangeSettings instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(RangeSettings other)
        {
            return other != null && _type == other._type && _maximum == other._maximum && _minimum == other._minimum;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified RangeSettings.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of RangeSettings and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            RangeSettings other = (RangeSettings)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _type.GetHashCode() ^ _minimum.GetHashCode() ^ _maximum.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "RangeSettings SettingType=" + _type.ToString() + ", Minimum=" + _minimum
                + ", Maximum=" + _maximum;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Specifies options to use during the matching phase
    /// </summary>

    [Serializable]
    public sealed class GeometricAdvancedSetupDataOption
    {
        private GeometricSetupData _type;
        private double _value;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricAdvancedSetupDataOption class.
        /// </summary>

        public GeometricAdvancedSetupDataOption()
            : this(GeometricSetupData.CurveExtractionMode)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricAdvancedSetupDataOption class.
        /// </summary>

        public GeometricAdvancedSetupDataOption(GeometricSetupData type)
            : this(type, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GeometricAdvancedSetupDataOption class.
        /// </summary>

        public GeometricAdvancedSetupDataOption(GeometricSetupData type, double value)
        {
            _type = type;
            _value = value;
        }

        //==========================================================================================
        /// <summary>
        /// Determines the option you want to use during the matching phase
        /// </summary>

        public GeometricSetupData Type
        {
            get { return _type; }
            set { _type = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the value for the option you want to use during the matching phase.
        /// </summary>

        public double Value
        {
            get { return _value; }
            set { _value = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricAdvancedSetupDataOption.
        /// </summary>
        /// <param name="other">
        /// A GeometricAdvancedSetupDataOption instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the  value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(GeometricAdvancedSetupDataOption other)
        {
            return other != null && _type == other._type && _value == other._value;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GeometricAdvancedSetupDataOption.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GeometricAdvancedSetupDataOption and equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            GeometricAdvancedSetupDataOption other = (GeometricAdvancedSetupDataOption)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _type.GetHashCode() ^ _value.GetHashCode();
        }

        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GeometricAdvancedSetupDataOption Type=" + _type.ToString() + ", Value=" + _value;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Contour Extracted from the image.
    /// </summary>

    [Serializable]
    public sealed class ExtractContourReport
    {
        private Collection<PointContour> _contourPoints;
        private Collection<PointContour> _sourcePoints;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ExtractContourReport class.
        /// </summary>

        public ExtractContourReport()
            : this(new Collection<PointContour>(), new Collection<PointContour>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ExtractContourReport class.
        /// </summary>
        /// <param name="textureFeatures">
        /// The texture features extracted from wavelets. 
        /// </param>

        public ExtractContourReport(Collection<PointContour> contourPoints, Collection<PointContour> sourcePoints)
        {
            _contourPoints = contourPoints;
            _sourcePoints = sourcePoints;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the contour points extracted. 
        /// </summary>

        public Collection<PointContour> ContourPoints
        {
            get { return _contourPoints; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the source points extracted. 
        /// </summary>

        public Collection<PointContour> SourcePoints
        {
            get { return _sourcePoints; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ExtractContourReport.
        /// </summary>
        /// <param name="other">
        /// A ExtractContourReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ExtractContourReport other)
        {
            return other != null && _contourPoints.Equals(other._contourPoints) && _sourcePoints.Equals(other._sourcePoints);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ExtractContourReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of TextureFeaturesReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ExtractContourReport other = (ExtractContourReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_contourPoints != null) ? _contourPoints.GetHashCode() : 0) ^ ((_sourcePoints != null) ? _sourcePoints.GetHashCode() : 0);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ExtractContourReport: " +
                ((_contourPoints != null) ? ("ContourPoints: " + _contourPoints.ToString()) : "") +
                ((_sourcePoints != null) ? ("SourcePoints: " + _sourcePoints.ToString()) : "");
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Contour Info of the image.
    /// </summary>

    [Serializable]
    public sealed class ContourInfoReport
    {
        private Collection<PointContour> _contourPoints;
        private Collection<PointContour> _sourcePoints;
        private Collection<double> _curvaturePixel;
        private Collection<double> _curvatureReal;
        private double _length;
        private double _lengthReal;
        private bool _hasEquation;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourInfoReport class.
        /// </summary>

        public ContourInfoReport()
            : this(new Collection<PointContour>(), new Collection<PointContour>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourInfoReport class.
        /// </summary>

        public ContourInfoReport(Collection<PointContour> contourPoints, Collection<PointContour> sourcePoints)
            : this(contourPoints, sourcePoints, new Collection<double>(), new Collection<double>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourInfoReport class.
        /// </summary>

        public ContourInfoReport(Collection<PointContour> contourPoints, Collection<PointContour> sourcePoints, Collection<double> curvaturePixel, Collection<double> curvatureReal)
            : this(contourPoints, sourcePoints, curvaturePixel, curvatureReal, 0, 0, false)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourInfoReport class.
        /// </summary>

        public ContourInfoReport(Collection<PointContour> contourPoints, Collection<PointContour> sourcePoints, Collection<double> curvaturePixel, Collection<double> curvatureReal, double length, double lengthReal, bool hasEquation)
        {
            _contourPoints = contourPoints;
            _sourcePoints = sourcePoints;
            _curvaturePixel = curvaturePixel;
            _curvatureReal = curvatureReal;
            _length = length;
            _lengthReal = lengthReal;
            _hasEquation = hasEquation;
        }

        //==========================================================================================
        /// <summary>
        /// Gets the contour points extracted. 
        /// </summary>

        public Collection<PointContour> ContourPoints
        {
            get { return _contourPoints; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets the source points extracted. 
        /// </summary>

        public Collection<PointContour> SourcePoints
        {
            get { return _sourcePoints; }
        }

        //==========================================================================================
        /// <summary>
        /// Displays the curvature profile for the selected contour, in pixels. 
        /// </summary>

        public Collection<double> CurvaturePixel
        {
            get { return _curvaturePixel; }
        }

        //==========================================================================================
        /// <summary>
        /// Displays the curvature profile for the selected contour, in pixels. 
        /// </summary>

        public Collection<double> CurvatureReal
        {
            get { return _curvatureReal; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the length, in pixels, of the curves in the image. 
        /// </summary>

        public double Length
        {
            get { return _length; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the length, in calibrated units, of the curves within the curvature range. 
        /// </summary>

        public double LengthReal
        {
            get { return _lengthReal; }
        }

        //==========================================================================================
        /// <summary>
        /// Specifies the length, in calibrated units, of the curves within the curvature range. 
        /// </summary>

        public bool HasEquation
        {
            get { return _hasEquation; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourInfoReport.
        /// </summary>
        /// <param name="other">
        /// A ContourInfoReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourInfoReport other)
        {
            return other != null && _hasEquation.Equals(other._hasEquation) && _lengthReal == other._lengthReal && _length == other._length && _curvatureReal.Equals(other._curvatureReal) && _curvaturePixel.Equals(other._curvaturePixel) && _contourPoints.Equals(other._contourPoints) && _sourcePoints.Equals(other._sourcePoints);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourInfoReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourInfoReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourInfoReport other = (ContourInfoReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _hasEquation.GetHashCode() ^ _lengthReal.GetHashCode() ^ _length.GetHashCode() ^ ((_curvatureReal != null) ? _curvatureReal.GetHashCode() : 0) ^ ((_curvaturePixel != null) ? _curvaturePixel.GetHashCode() : 0) ^ ((_contourPoints != null) ? _contourPoints.GetHashCode() : 0) ^ ((_sourcePoints != null) ? _sourcePoints.GetHashCode() : 0);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourInfoReport: " +
                ((_contourPoints != null) ? ("ContourPoints: " + _contourPoints.ToString()) : "") +
                ((_sourcePoints != null) ? ("SourcePoints: " + _sourcePoints.ToString()) : "") +
                ((_curvaturePixel != null) ? ("Curvature Pixel: " + _curvaturePixel.ToString()) : "") +
                ((_curvatureReal != null) ? ("Curvature Real: " + _curvatureReal.ToString()) : "") +
                ((_curvatureReal != null) ? ("Curvature Real: " + _curvatureReal.ToString()) : "") +
                "Length : " + _length + "Length Real: " + _lengthReal + "Has Equation : " + _hasEquation;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Curvature Report of the image.
    /// </summary>

    [Serializable]
    public sealed class ComputeCurvatureReport
    {
        private Collection<double> _curvaturePixel;
        private Collection<double> _curvatureReal;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ComputeCurvatureReport class.
        /// </summary>

        public ComputeCurvatureReport()
            : this(new Collection<double>(), new Collection<double>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ComputeCurvatureReport class.
        /// </summary>

        public ComputeCurvatureReport(Collection<double> curvaturePixel, Collection<double> curvatureReal)
        {
            _curvaturePixel = curvaturePixel;
            _curvatureReal = curvatureReal;
        }

        //==========================================================================================
        /// <summary>
        /// Displays the curvature profile for the selected contour, in pixels. 
        /// </summary>

        public Collection<double> CurvaturePixel
        {
            get { return _curvaturePixel; }
        }

        //==========================================================================================
        /// <summary>
        /// Displays the curvature profile for the selected contour, in pixels. 
        /// </summary>

        public Collection<double> CurvatureReal
        {
            get { return _curvatureReal; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ComputeCurvatureReport.
        /// </summary>
        /// <param name="other">
        /// A ComputeCurvatureReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ComputeCurvatureReport other)
        {
            return other != null && _curvatureReal.Equals(other._curvatureReal) && _curvaturePixel.Equals(other._curvaturePixel);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ComputeCurvatureReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ComputeCurvatureReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ComputeCurvatureReport other = (ComputeCurvatureReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_curvatureReal != null) ? _curvatureReal.GetHashCode() : 0) ^ ((_curvaturePixel != null) ? _curvaturePixel.GetHashCode() : 0);
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ComputeCurvatureReport: " +
                ((_curvaturePixel != null) ? ("Curvature Pixel: " + _curvaturePixel.ToString()) : "") +
                ((_curvatureReal != null) ? ("Curvature Real: " + _curvatureReal.ToString()) : "");
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the Curvature Analysis Report.
    /// </summary>

    [Serializable]
    public sealed class ClassifyCurvatureReport
    {
        private Collection<ClassifiedCurve> _curves;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifyCurvatureReport class.
        /// </summary>

        public ClassifyCurvatureReport()
            : this(new Collection<ClassifiedCurve>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifyCurvatureReport class.
        /// </summary>

        public ClassifyCurvatureReport(Collection<ClassifiedCurve> curves)
        {
            _curves = curves;
        }

        //==========================================================================================
        /// <summary>
        /// Displays the classifies curves report. 
        /// </summary>

        public Collection<ClassifiedCurve> Curves
        {
            get { return _curves; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifyCurvatureReport.
        /// </summary>
        /// <param name="other">
        /// A ClassifyCurvatureReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifyCurvatureReport other)
        {
            return other != null && _curves.Equals(other._curves);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifyCurvatureReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassifyCurvatureReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifyCurvatureReport other = (ClassifyCurvatureReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _curves.GetHashCode(); ;
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifyCurvatureReport: " + _curves.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Compute Distance Report.
    /// </summary>

    [Serializable]
    public sealed class ComputeDistanceReport
    {
        private Collection<Disparity> _distances;
        private Collection<Disparity> _distancesReal;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ComputeDistanceReport class.
        /// </summary>

        public ComputeDistanceReport()
            : this(new Collection<Disparity>(), new Collection<Disparity>())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ComputeDistanceReport class.
        /// </summary>

        public ComputeDistanceReport(Collection<Disparity> distance, Collection<Disparity> distanceReal)
        {
            _distances = distance;
            _distancesReal = distanceReal;
        }

        //==========================================================================================
        /// <summary>
        /// Collection containing the computed distances 
        /// </summary>

        public Collection<Disparity> Distances
        {
            get { return _distances; }
        }

        //==========================================================================================
        /// <summary>
        ///  Collection containing the computed distances in calibrated units 
        /// </summary>

        public Collection<Disparity> DistancesReal
        {
            get { return _distancesReal; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ComputeDistanceReport.
        /// </summary>
        /// <param name="other">
        /// A ComputeDistanceReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ComputeDistanceReport other)
        {
            return other != null && _distances.Equals(other._distances) && _distancesReal.Equals(other._distancesReal);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ComputeDistanceReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ComputeDistanceReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ComputeDistanceReport other = (ComputeDistanceReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _distances.GetHashCode() ^ _distancesReal.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ComputeDistanceReport: Distances:" + _distances.ToString() + ", DistancesReal : " + _distancesReal;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the Curvature Analysis Report.
    /// </summary>

    [Serializable]
    public sealed class ClassifyDistancesReport
    {
        private Collection<ClassifiedDisparity> _classifiedDistances;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifyDistancesReport class.
        /// </summary>

        public ClassifyDistancesReport()
            : this(new Collection<ClassifiedDisparity>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClassifyDistancesReport class.
        /// </summary>

        public ClassifyDistancesReport(Collection<ClassifiedDisparity> classifiedDistances)
        {
            _classifiedDistances = classifiedDistances;
        }

        //==========================================================================================
        /// <summary>
        /// Displays the classifies distances report. 
        /// </summary>

        public Collection<ClassifiedDisparity> ClassifiedDistances
        {
            get { return _classifiedDistances; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifyDistancesReport.
        /// </summary>
        /// <param name="other">
        /// A ClassifyDistancesReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClassifyDistancesReport other)
        {
            return other != null && _classifiedDistances.Equals(other._classifiedDistances);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClassifyDistancesReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClassifyDistancesReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClassifyDistancesReport other = (ClassifyDistancesReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _classifiedDistances.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClassifyDistancesReport: " + _classifiedDistances.ToString();
        }
    }  

    //==============================================================================================
    /// <summary>
    /// Provides the ROILabel.
    /// </summary>

    [Serializable]
    public sealed class ROILabel
    {
        private string _className;
        private UInt32 _label;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ROILabel class.
        /// </summary>

        public ROILabel()
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ROILabel class.
        /// </summary>
        /// <param name="className">
        /// String specifying the class name for the label.
        /// </param>
        /// <param name="label">
        /// The label index for the Roi label.
        /// </param>

        public ROILabel(string className, UInt32 label)
        {
            _className = className;
            _label = label;
        }

        //==========================================================================================
        /// <summary>
        /// Gets/Sets the ClassName. 
        /// </summary>

        public string ClassName
        {
            get { return _className; }
            set { _className = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets/Sets the Label. 
        /// </summary>

        public UInt32 Label
        {
            get { return _label; }
            set { _label = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ROILabel.
        /// </summary>
        /// <param name="other">
        /// A ROILabel instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ROILabel other)
        {
            return other != null && other.Label == _label && other.ClassName.Equals(_className);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ROILabel.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ROILabel
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ROILabel other = (ROILabel)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _className.GetHashCode() ^ _label.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ROILabel: " +
                "ClassName : " + _className.ToString() +
                "Label : " + _label;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the ColorSegmentationOptions.
    /// </summary>

    [Serializable]
    public sealed class ColorSegmentationOptions
    {
        private UInt32 _windowX;
        private UInt32 _windowY;
        private UInt32 _stepSize;
        private UInt32 _minParticleArea;
        private UInt32 _maxParticleArea;
        private bool _isFineSegment;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ColorSegmentationOptions class.
        /// </summary>

        public ColorSegmentationOptions()
            : this(32, 32, 4, 0, 0xffffffff, false)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ColorSegmentationOptions class.
        /// </summary>
        /// <param name="windowX">
        /// Specifies the Window lenght on X direction.
        /// </param>
        /// <param name="windowY">
        /// Specifies the Window lenght on Y direction.
        /// </param>
        /// <param name="stepSize">
        /// Specifies the Distance between windows.
        /// </param>
        /// <param name="minParticleArea">
        /// Specifies the Minimum Cluster/Particle area to be allowed.
        /// </param>
        /// <param name="maxParticleArea">
        /// Specifies the Maximum Cluster/Particle area to be allowed.
        /// </param>
        /// <param name="isFineSegment">
        /// When true, the step processes the boundary pixels of each segmentation cluster using a step size of 1.
        /// </param>

        public ColorSegmentationOptions(UInt32 windowX, UInt32 windowY, UInt32 stepSize, UInt32 minParticleArea, UInt32 maxParticleArea, bool isFineSegment)
        {
            _windowX = windowX;
            _windowY = windowY;
            _stepSize = stepSize;
            _minParticleArea = minParticleArea;
            _maxParticleArea = maxParticleArea;
            _isFineSegment = isFineSegment;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the WindowX. 
        /// </summary>
        /// <value>
        /// </value>

        public UInt32 WindowX
        {
            get { return _windowX; }
            set { _windowX = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the WindowY. 
        /// </summary>
        /// <value>
        /// </value>

        public UInt32 WindowY
        {
            get { return _windowY; }
            set { _windowY = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the StepSize. 
        /// </summary>
        /// <value>
        /// </value>

        public UInt32 StepSize
        {
            get { return _stepSize; }
            set { _stepSize = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the MinParticleArea. 
        /// </summary>
        /// <value>
        /// </value>

        public UInt32 MinParticleArea
        {
            get { return _minParticleArea; }
            set { _minParticleArea = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the MaxParticleArea. 
        /// </summary>
        /// <value>
        /// </value>

        public UInt32 MaxParticleArea
        {
            get { return _maxParticleArea; }
            set { _maxParticleArea = value; }
        } 
        //==========================================================================================
        /// <summary>
        /// Gets or sets the IsFineSegment. 
        /// </summary>
        /// <value>
        /// </value>

        public bool IsFineSegment
        {
            get { return _isFineSegment; }
            set { _isFineSegment = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorSegmentationOptions.
        /// </summary>
        /// <param name="other">
        /// A ColorSegmentationOptions instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ColorSegmentationOptions other)
        {
            return other != null && other.WindowX == _windowX && other.WindowY == _windowY && other.MaxParticleArea == _maxParticleArea && other.MinParticleArea == _minParticleArea && other.IsFineSegment == _isFineSegment;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ColorSegmentationOptions.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ColorSegmentationOptions
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ColorSegmentationOptions other = (ColorSegmentationOptions)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _windowX.GetHashCode() ^ _windowY.GetHashCode() ^ _stepSize.GetHashCode() ^ _minParticleArea.GetHashCode() ^ _maxParticleArea.GetHashCode() ^ _isFineSegment.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ColorSegmentationOptions: " +
                " WindowX : " + _windowX + " WindowY : " + _windowY +
                " StepSize : " + _stepSize + " MinParticleArea : " + _minParticleArea +
                " MaxParticleArea : " + _maxParticleArea + " IsFineSegment : " + _isFineSegment.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the LabelToROIReport.
    /// </summary>

    [Serializable]
    public sealed class LabelToROIReport
    {
        private Collection<Roi> _rois;
        private Collection<UInt32> _labelsOut;
        private Collection<bool> _isTooManyVectors;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LabelToROIReport class.
        /// </summary>

        public LabelToROIReport()
            : this(new Collection<Roi>(), new Collection<UInt32>(), new Collection<bool>())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the LabelToROIReport class.
        /// </summary>
        /// <param name="rois">
        /// Collection of Rois.
        /// </param>
        /// <param name="labelsOut">
        /// Collection of label indexes of ROI Labels.
        /// </param>
        /// <param name="isTooManyVectors">
        /// Collection of bool specifying whether there are too many vectors. It is to indicate 
        /// specific cases where number of points in a contour exceeded the maximum limit.
        /// </param>

        public LabelToROIReport(Collection<Roi> rois, Collection<UInt32> labelsOut, Collection<bool> isTooManyVectors)
        {
            _rois = rois;
            _labelsOut = labelsOut;
            _isTooManyVectors = isTooManyVectors;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Rois. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<Roi> Rois
        {
            get { return _rois; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _rois = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the LabelsOut. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<UInt32> LabelsOut
        {
            get { return _labelsOut; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _labelsOut = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the IsTooManyVectors. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<bool> IsTooManyVectors
        {
            get { return _isTooManyVectors; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _isTooManyVectors = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LabelToROIReport.
        /// </summary>
        /// <param name="other">
        /// A LabelToROIReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(LabelToROIReport other)
        {
            return other != null && other.IsTooManyVectors.Equals(_isTooManyVectors) && other.Rois.Equals(_rois) && other.LabelsOut.Equals(_labelsOut);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified LabelToROIReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of LabelToROIReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            LabelToROIReport other = (LabelToROIReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _labelsOut.GetHashCode() ^ _isTooManyVectors.GetHashCode() ^ _rois.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "LabelToROIReport: " +
                " Rois : " + _rois.ToString() + " LabelsOut : " + _labelsOut.ToString() +
                " IsTooManyVectors : " + _isTooManyVectors.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the ContourFitLineReport.
    /// </summary>

    [Serializable]
    public sealed class ContourFitLineReport
    {
        private LineContour _lineSegment;
        private LineEquation _equation;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitLineReport class.
        /// </summary>

        public ContourFitLineReport()
            : this(new LineContour(), new LineEquation())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitLineReport class.
        /// </summary>
        /// <param name="lineSegment">
        /// Defines the initial and the end point of the line.
        /// </param>
        /// <param name="equation">
        /// Defines the constants for the equation of a line.
        /// </param>

        public ContourFitLineReport(LineContour lineSegment, LineEquation equation)
        {
            _lineSegment = lineSegment;
            _equation = equation;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the lineSegment. 
        /// </summary>
        /// <value>
        /// </value>

        public LineContour lineSegment
        {
            get { return _lineSegment; }
            set { _lineSegment = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the equation. 
        /// </summary>
        /// <value>
        /// </value>

        public LineEquation equation
        {
            get { return _equation; }
            set { _equation = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitLineReport.
        /// </summary>
        /// <param name="other">
        /// A ContourFitLineReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourFitLineReport other)
        {
            return other != null && other.equation.Equals(_equation) && other.lineSegment.Equals(_lineSegment);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitLineReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourFitLineReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourFitLineReport other = (ContourFitLineReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _equation.GetHashCode() ^ _lineSegment.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourFitLineReport: " +
                " Equation : " +_equation.ToString() + " LineSegment : " + _lineSegment.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the PartialCircle.
    /// </summary>

    [Serializable]
    public sealed class PartialCircle
    {
        private PointContour _center;
        private double _radius;
        private double _startAngle;
        private double _endAngle;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PartialCircle class.
        /// </summary>

        public PartialCircle()
            : this(new PointContour(), 0, 0 ,0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PartialCircle class.
        /// </summary>
        /// <param name="center">
        /// Defines the coordinates of the center of the circle.
        /// </param>
        /// <param name="radius">
        /// Defines the radius.
        /// </param>
        /// <param name="startAngle">
        /// Defines the start angle of the partial circle from the horizontal in anticlockwise direction.
        /// </param>
        /// <param name="endAngle">
        /// Defines the end angle of the partial circle from the horizontal in anticlockwise direction.
        /// </param>

        public PartialCircle(PointContour center, double radius, double startAngle, double endAngle)
        {
            _center = center;
            _radius = radius;
            _startAngle = startAngle;
            _endAngle = endAngle;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Center. 
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { _center = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Radius. 
        /// </summary>
        /// <value>
        /// </value>

        public double Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the StartAngle. 
        /// </summary>
        /// <value>
        /// </value>

        public double StartAngle
        {
            get { return _startAngle; }
            set { _startAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the EndAngle. 
        /// </summary>
        /// <value>
        /// </value>

        public double EndAngle
        {
            get { return _endAngle; }
            set { _endAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PartialCircle.
        /// </summary>
        /// <param name="other">
        /// A PartialCircle instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PartialCircle other)
        {
            return other != null && other.StartAngle.Equals(_startAngle) && other.EndAngle.Equals(_endAngle) && other.Center.Equals(_center) && other.Radius.Equals(_radius);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PartialCircle.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PartialCircle
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PartialCircle other = (PartialCircle)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _radius.GetHashCode() ^ _startAngle.GetHashCode() ^ _endAngle.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PartialCircle: " +
                " Center : " + _center.ToString() + " Radius : " + _radius +
                " Start Angle : " + _startAngle + " End Angle : " + _endAngle;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the PartialEllipse.
    /// </summary>

    [Serializable]
    public sealed class PartialEllipse
    {
        private PointContour _center;
        private double _angle;
        private double _majorRadius;
        private double _minorRadius;
        private double _startAngle;
        private double _endAngle;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PartialEllipse class.
        /// </summary>

        public PartialEllipse()
            : this(new PointContour(), 0, 0, 0, 0, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PartialEllipse class.
        /// </summary>
        /// <param name="center">
        /// Defines the coordinates of the center of the ellipse.
        /// </param>
        /// <param name="angle">
        /// Defines the angle.
        /// </param>
        /// <param name="majorRadius">
        /// Defines the major radius of the ellipse.
        /// </param>
        /// <param name="minorRadius">
        /// Defines the minor radius of the ellipse.
        /// </param>
        /// <param name="startAngle">
        /// Defines the start angle of the partial circle from the horizontal in anticlockwise direction.
        /// </param>
        /// <param name="endAngle">
        /// Defines the end angle of the partial circle from the horizontal in anticlockwise direction.
        /// </param>

        public PartialEllipse(PointContour center, double angle, double majorRadius, double minorRadius, double startAngle, double endAngle)
        {
            _center = center;
            _angle = angle;
            _majorRadius = majorRadius;
            _minorRadius = minorRadius;
            _startAngle = startAngle;
            _endAngle = endAngle;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Center. 
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Center
        {
            get { return _center; }
            set { _center = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Angle. 
        /// </summary>
        /// <value>
        /// </value>

        public double Angle
        {
            get { return _angle; }
            set { _angle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the MajorRadius. 
        /// </summary>
        /// <value>
        /// </value>

        public double MajorRadius
        {
            get { return _majorRadius; }
            set { _majorRadius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the MinorRadius. 
        /// </summary>
        /// <value>
        /// </value>

        public double MinorRadius
        {
            get { return _minorRadius; }
            set { _minorRadius = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the StartAngle. 
        /// </summary>
        /// <value>
        /// </value>

        public double StartAngle
        {
            get { return _startAngle; }
            set { _startAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the EndAngle. 
        /// </summary>
        /// <value>
        /// </value>

        public double EndAngle
        {
            get { return _endAngle; }
            set { _endAngle = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PartialEllipse.
        /// </summary>
        /// <param name="other">
        /// A PartialEllipse instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PartialEllipse other)
        {
            return other != null && other.StartAngle.Equals(_startAngle) && other.EndAngle.Equals(_endAngle) && other.Center.Equals(_center) && other.Angle.Equals(_angle) && other.MajorRadius.Equals(_majorRadius) && other.MinorRadius.Equals(_minorRadius);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PartialEllipse.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PartialEllipse
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PartialEllipse other = (PartialEllipse)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^ _angle.GetHashCode() ^ _startAngle.GetHashCode() ^ _endAngle.GetHashCode() ^ _minorRadius.GetHashCode() ^ _majorRadius.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PartialEllipse: " +
                " Center : " + _center.ToString() + " Angle : " + _angle +
                " Major Radius : " + _majorRadius + " Minor Radius : " + _minorRadius +
                " Start Angle : " + _startAngle + " End Angle : " + _endAngle;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the ContourFitSplineReport.
    /// </summary>

    [Serializable]
    public sealed class ContourFitSplineReport
    {
        private Collection<PointContour> _points;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitSplineReport class.
        /// </summary>

        public ContourFitSplineReport()
            : this(new Collection<PointContour>())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitSplineReport class.
        /// </summary>
        /// <param name="points">
        /// Defines the collection of points returned yb ContourFit Spline. It has all the points which
        /// represents the contour fitted by the function.
        /// </param>

        public ContourFitSplineReport(Collection<PointContour> points)
        {
            _points = points;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Points. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Points
        {
            get { return _points; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _points = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitSplineReport.
        /// </summary>
        /// <param name="other">
        /// A ContourFitSplineReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourFitSplineReport other)
        {
            return other != null && other.Points.Equals(_points);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitSplineReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourFitSplineReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourFitSplineReport other = (ContourFitSplineReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _points.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourFitSplineReport: " +
                " BestFit Points : " +_points.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the ContourFitPolynomialReport.
    /// </summary>

    [Serializable]
    public sealed class ContourFitPolynomialReport
    {
        private Collection<PointContour> _points;
        private Collection<double> _polynomialCoefficients;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitPolynomialReport class.
        /// </summary>

        public ContourFitPolynomialReport()
            : this(new Collection<PointContour>(), new Collection<double>())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ContourFitPolynomialReport class.
        /// </summary>
        /// <param name="points">
        /// Defines the collection of points returned yb ContourFit Spline. It has all the points which
        /// represents the contour fitted by the function.
        /// </param>
        /// <param name="polynomialCoefficients">
        /// Defines the polynomial coefficients of the equation.
        /// </param>

        public ContourFitPolynomialReport(Collection<PointContour> points, Collection<double> polynomialCoefficients)
        {
            _points = points;
            _polynomialCoefficients = polynomialCoefficients;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Points. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<PointContour> Points
        {
            get { return _points; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _points = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the PolynomialCoefficients. 
        /// </summary>
        /// <value>
        /// </value>

        public Collection<double> PolynomialCoefficients
        {
            get { return _polynomialCoefficients; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _polynomialCoefficients = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitPolynomialReport.
        /// </summary>
        /// <param name="other">
        /// A ContourFitPolynomialReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ContourFitPolynomialReport other)
        {
            return other != null && other.Points.Equals(_points) && other.PolynomialCoefficients.Equals(_polynomialCoefficients);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ContourFitPolynomialReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ContourFitPolynomialReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ContourFitPolynomialReport other = (ContourFitPolynomialReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _points.GetHashCode() ^ _polynomialCoefficients.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ContourFitSplineReport: " +
                " BestFit Points : " + _points.ToString() + " Polynomial Coefficients : " + _polynomialCoefficients.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the EdgePolarityClamp.
    /// </summary>

    [Serializable]
    public sealed class EdgePolarityClamp
    {
        private EdgePolaritySearchMode _start;
        private EdgePolaritySearchMode _end;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgePolarityClamp class.
        /// </summary>

        public EdgePolarityClamp()
            : this(EdgePolaritySearchMode.All, EdgePolaritySearchMode.All)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the EdgePolarityClamp class.
        /// </summary>
        /// <param name="start">
        /// Defines the start polarity.
        /// </param>
        /// <param name="end">
        /// Defines the end polarity.
        /// </param>

        public EdgePolarityClamp(EdgePolaritySearchMode start, EdgePolaritySearchMode end)
        {
            _start = start;
            _end = end;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Start polarity. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgePolaritySearchMode Start
        {
            get { return _start; }
            set { _start = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the End polarity. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgePolaritySearchMode End
        {
            get { return _end; }
            set { _end = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgePolarityClamp.
        /// </summary>
        /// <param name="other">
        /// A EdgePolarityClamp instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(EdgePolarityClamp other)
        {
            return other != null && other.End == _end && other.Start == _start;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified EdgePolarityClamp.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of EdgePolarityClamp
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            EdgePolarityClamp other = (EdgePolarityClamp)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _start.GetHashCode() ^ _end.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "EdgePolarityClamp: " + " Start: " + _start.ToString() + ", End: " + _end.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// The ClampSettings is used to control the behavior of the clamp.
    /// </summary>

    [Serializable]
    public sealed class ClampSettings
    {
        private EdgePolarityClamp _edgePolarity;
        private double _angleRange;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampSettings class.
        /// </summary>

        public ClampSettings()
            : this(new EdgePolarityClamp(), 5.0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampSettings class.
        /// </summary>
        /// <param name="edgePolarity">
        /// Defines the start polarity.
        /// </param>
        /// <param name="angleRange">
        /// Defines the end polarity.
        /// </param>

        public ClampSettings(EdgePolarityClamp edgePolarity, double angleRange)
        {
            _edgePolarity = edgePolarity;
            _angleRange = angleRange;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the EdgePolarity. 
        /// </summary>
        /// <value>
        /// </value>

        public EdgePolarityClamp EdgePolarity
        {
            get { return _edgePolarity; }
            set { _edgePolarity = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the AngleRange. 
        /// </summary>
        /// <value>
        /// </value>

        public double AngleRange
        {
            get { return _angleRange; }
            set { _angleRange = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampSettings.
        /// </summary>
        /// <param name="other">
        /// A ClampSettings instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClampSettings other)
        {
            return other != null && other.EdgePolarity.Equals(_edgePolarity) && other.AngleRange.Equals(_angleRange);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampSettings.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClampSettings
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClampSettings other = (ClampSettings)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _edgePolarity.GetHashCode() ^ _angleRange.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClampSettings: " + _edgePolarity.ToString() + ", AngleRange: " + _angleRange;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the information that is to be overlaid on the result image.
    /// </summary>

    [Serializable]
    public sealed class ClampOverlaySettings
    {
        private bool _showSearchArea;
        private bool _showCurves;
        private bool _showClampLocations;
        private bool _showResult;
        private Rgb32Value _searchAreaColor;
        private Rgb32Value _curvesColor;
        private Rgb32Value _clampLocationsColor;
        private Rgb32Value _resultColor;
        private string _overlayGroupName;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampOverlaySettings class.
        /// </summary>

        public ClampOverlaySettings()
            : this(false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampOverlaySettings class.
        /// </summary>
        /// <param name="showSearchArea">
        /// Defines the start polarity.
        /// </param>

        public ClampOverlaySettings(bool showSearchArea)
            : this(showSearchArea, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampOverlaySettings class.
        /// </summary>
        /// <param name="showSearchArea">
        /// Defines the start polarity.
        /// </param>
        /// <param name="showCurves">
        /// Defines the end polarity.
        /// </param>

        public ClampOverlaySettings(bool showSearchArea, bool showCurves)
            : this(showSearchArea, showCurves, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampOverlaySettings class.
        /// </summary>
        /// <param name="showSearchArea">
        /// Defines the start polarity.
        /// </param>
        /// <param name="showCurves">
        /// Defines the end polarity.
        /// </param>
        /// <param name="showClampLocations">
        /// Defines the end polarity.
        /// </param>

        public ClampOverlaySettings(bool showSearchArea, bool showCurves, bool showClampLocations)
            : this(showSearchArea, showCurves, showClampLocations, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampOverlaySettings class.
        /// </summary>
        /// <param name="showSearchArea">
        /// Defines the start polarity.
        /// </param>
        /// <param name="showCurves">
        /// Defines the end polarity.
        /// </param>
        /// <param name="showClampLocations">
        /// Defines the end polarity.
        /// </param>
        /// <param name="showResult">
        /// Defines the end polarity.
        /// </param>

        public ClampOverlaySettings(bool showSearchArea, bool showCurves, bool showClampLocations, bool showResult)
        {
            _showSearchArea = showSearchArea;
            _showCurves = showCurves;
            _showClampLocations = showClampLocations;
            _showResult = showResult;
            _searchAreaColor = Rgb32Value.BlueColor;
            _curvesColor = Rgb32Value.GreenColor;
            _clampLocationsColor = Rgb32Value.YellowColor;
            _resultColor = Rgb32Value.RedColor;
            _overlayGroupName = "";
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the results. 
        /// </summary>
        /// <value>The default value is R = 255, G = 0, and B = 0.
        /// </value>

        public Rgb32Value ResultColor
        {
            get { return _resultColor; }
            set { _resultColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the clamp locations. 
        /// </summary>
        /// <value>The default value is R = 255, G = 255, and B = 0.
        /// </value>

        public Rgb32Value ClampLocationsColor
        {
            get { return _clampLocationsColor; }
            set { _clampLocationsColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the curves. 
        /// </summary>
        /// <value>The default value is R = 0, G = 0, and B = 255.
        /// </value>

        public Rgb32Value CurvesColor
        {
            get { return _curvesColor; }
            set { _curvesColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the RGB color value to use to overlay the search area. 
        /// </summary>
        /// <value>The default value is R = 0, G = 255, and B = 0.
        /// </value>

        public Rgb32Value SearchAreaColor
        {
            get { return _searchAreaColor; }
            set { _searchAreaColor = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. 
        /// </summary>
        /// <value>The default value is <see langword="true"/>.
        /// </value>
        /// <remarks>
        /// If <see langword="true"/>, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image. When applicable, the function also overlays the location of any measurements made by the function. If you do not want this information overlaid onto the image, set this element to <see langword="false"/>.
        /// </remarks>

        public bool ShowResult
        {
            get { return _showResult; }
            set { _showResult = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the locations of the curves on the image.
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowCurves
        {
            get { return _showCurves; }
            set { _showCurves = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the clamp locations on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowClampLocations
        {
            get { return _showClampLocations; }
            set { _showClampLocations = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets whether the function overlays the search area on the image. 
        /// </summary>
        /// <value>The default value is <see langword="false"/>.
        /// </value>

        public bool ShowSearchArea
        {
            get { return _showSearchArea; }
            set { _showSearchArea = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the overlay group name to assign to the overlays. 
        /// </summary>
        /// <value>
        /// The default value is blank.
        /// Set this element to <see langword="null"/> to add overlays to the default group. 
        /// </value>

        public string OverlayGroupName
        {
            get { return _overlayGroupName; }
            set { _overlayGroupName = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampOverlaySettings.
        /// </summary>
        /// <param name="other">
        /// A ClampOverlaySettings instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClampOverlaySettings other)
        {
            return other != null && other.ShowClampLocations == _showClampLocations && other.ShowCurves == _showCurves && other.ShowResult == _showResult && other.ShowSearchArea == _showSearchArea && other.ClampLocationsColor == _clampLocationsColor && other.CurvesColor == _curvesColor && other.ResultColor == _resultColor && other.SearchAreaColor == _searchAreaColor && _overlayGroupName == other._overlayGroupName;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampOverlaySettings.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClampOverlaySettings
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClampOverlaySettings other = (ClampOverlaySettings)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _showResult.GetHashCode() ^ _showSearchArea.GetHashCode() ^ _showCurves.GetHashCode() ^ _showClampLocations.GetHashCode() ^ _searchAreaColor.GetHashCode() ^ _resultColor.GetHashCode() ^ _clampLocationsColor.GetHashCode() ^ _curvesColor.GetHashCode() ^ _overlayGroupName.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClampOverlaySettings: " +
                "Show Search Area: " + _showSearchArea.ToString() + ", Search Area color: " + _searchAreaColor.ToString() +
                "Show Curves: " + _showCurves.ToString() + ", Curves color: " + _curvesColor.ToString() +
                "Show Clamp locations: " + _showClampLocations.ToString() + ", Clamp Locations color: " + _clampLocationsColor.ToString() +
                "Show Result: " + _showResult.ToString() + ", Result color: " + _resultColor.ToString() +
                "OverlayGroupName: " + _overlayGroupName;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the ClampResults.
    /// </summary>

    [Serializable]
    public sealed class ClampResults
    {
        private double _distancePix;
        private double _distanceRealWorld;
        private double _angleAbs;
        private double _angleRelative;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampResults class.
        /// </summary>

        public ClampResults()
            : this(0.0, 0.0, 0.0, 0.0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampResults class.
        /// </summary>
        /// <param name="distancePix">
        /// Defines the distance in Pixels.
        /// </param>
        /// <param name="distanceRealWorld">
        /// Defines the distance in Real world coordinates.
        /// </param>
        /// <param name="angleAbs">
        /// Defines the absolute angle.
        /// </param>
        /// <param name="angleRelative">
        /// Defines the relative angle.
        /// </param>

        public ClampResults(double distancePix, double distanceRealWorld, double angleAbs, double angleRelative)
        {
            _distancePix = distancePix;
            _distanceRealWorld = distanceRealWorld;
            _angleAbs = angleAbs;
            _angleRelative = angleRelative;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the DistancePix 
        /// </summary>
        /// <value>
        /// </value>

        public double DistancePix
        {
            get { return _distancePix; }
            set { _distancePix = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the DistanceRealWorld 
        /// </summary>
        /// <value>
        /// </value>

        public double DistanceRealWorld
        {
            get { return _distanceRealWorld; }
            set { _distanceRealWorld = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the AngleAbs 
        /// </summary>
        /// <value>
        /// </value>

        public double AngleAbs
        {
            get { return _angleAbs; }
            set { _angleAbs = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the AngleRelative 
        /// </summary>
        /// <value>
        /// </value>

        public double AngleRelative
        {
            get { return _angleRelative; }
            set { _angleRelative = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampResults.
        /// </summary>
        /// <param name="other">
        /// A ClampResults instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClampResults other)
        {
            return other != null && other.AngleAbs.Equals(_angleAbs) && other.AngleRelative.Equals(_angleRelative) && other.DistancePix.Equals(_distancePix) && other.DistanceRealWorld.Equals(_distanceRealWorld);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampResults.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClampResults
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClampResults other = (ClampResults)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _angleRelative.GetHashCode() ^ _angleAbs.GetHashCode() ^ _distanceRealWorld.GetHashCode() ^ _distancePix.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "Clamp Results: " + " DistancePix: " + _distancePix + ", DistanceRealWorld: " + _distanceRealWorld +
                ", AngleAbs: " + _angleAbs + ", AngleRelative: " + _angleRelative;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the PointPairDouble.
    /// </summary>

    [Serializable]
    public sealed class PointPairDouble
    {
        private PointContour _start;
        private PointContour _end;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PointPairDouble class.
        /// </summary>

        public PointPairDouble()
            : this(new PointContour(), new PointContour())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PointPairDouble class.
        /// </summary>
        /// <param name="start">
        /// Defines the start coordinates.
        /// </param>
        /// <param name="end">
        /// Defines the end coordinates.
        /// </param>

        public PointPairDouble(PointContour start, PointContour end)
        {
            _start = start;
            _end = end;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the start coordinate 
        /// </summary>
        /// <value>
        /// </value>

        public PointContour Start
        {
            get { return _start; }
            set { _start = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the end coordinate 
        /// </summary>
        /// <value>
        /// </value>

        public PointContour End
        {
            get { return _end; }
            set { _end = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PointPairDouble.
        /// </summary>
        /// <param name="other">
        /// A PointPairDouble instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PointPairDouble other)
        {
            return other != null && other.Start.Equals(_start) && other.End.Equals(_end);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PointPairDouble.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PointPairDouble
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PointPairDouble other = (PointPairDouble)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _end.GetHashCode() ^ _start.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PointPairDouble: " + " Start: " + _start.ToString() + ", End: " + _end.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the ClampPoints.
    /// </summary>

    [Serializable]
    public sealed class ClampPoints
    {
        private PointPairDouble _pixels;
        private PointPairDouble _realWorld;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampPoints class.
        /// </summary>

        public ClampPoints()
            : this(new PointPairDouble(), new PointPairDouble())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampPoints class.
        /// </summary>
        /// <param name="pixels">
        /// Defines the start coordinates.
        /// </param>
        /// <param name="realWorld">
        /// Defines the end coordinates.
        /// </param>

        public ClampPoints(PointPairDouble pixels, PointPairDouble realWorld)
        {
            _pixels = pixels;
            _realWorld = realWorld;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the pixel coordinates 
        /// </summary>
        /// <value>
        /// </value>

        public PointPairDouble Pixels
        {
            get { return _pixels; }
            set { _pixels = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the real world coordinates 
        /// </summary>
        /// <value>
        /// </value>

        public PointPairDouble RealWorld
        {
            get { return _realWorld; }
            set { _realWorld = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampPoints.
        /// </summary>
        /// <param name="other">
        /// A ClampPoints instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClampPoints other)
        {
            return other != null && other.Pixels.Equals(_pixels) && other.RealWorld.Equals(_realWorld);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampPoints.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClampPoints
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClampPoints other = (ClampPoints)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _realWorld.GetHashCode() ^ _pixels.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClampPoints: " + " Pixels: (" + _pixels.ToString() + "), RealWorld: (" + _realWorld.ToString() + ")";
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the ClampMaxReport.
    /// </summary>

    [Serializable]
    public sealed class ClampMaxReport
    {
        private ClampResults _clampResults;
        private ClampPoints _clampPoints;
        private bool _calibrationValid;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampMaxReport class.
        /// </summary>

        public ClampMaxReport()
            : this(new ClampResults(), new ClampPoints(), false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ClampMaxReport class.
        /// </summary>
        /// <param name="clampResults">
        /// Defines the clamp results.
        /// </param>
        /// <param name="clampPoints">
        /// Defines the clamp points.
        /// </param>
        /// <param name="calibrationValid">
        /// Defines whether the calibration is valid or not.
        /// </param>

        public ClampMaxReport(ClampResults clampResults, ClampPoints clampPoints, bool calibrationValid)
        {
            _clampResults = clampResults;
            _clampPoints = clampPoints;
            _calibrationValid = calibrationValid;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the clamp results 
        /// </summary>
        /// <value>
        /// </value>

        public ClampResults ClampResults
        {
            get { return _clampResults; }
            set { _clampResults = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the clamp points
        /// </summary>
        /// <value>
        /// </value>

        public ClampPoints ClampPoints
        {
            get { return _clampPoints; }
            set { _clampPoints = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the calibrationValid
        /// </summary>
        /// <value>
        /// </value>

        public bool CalibrationValid
        {
            get { return _calibrationValid; }
            set { _calibrationValid = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampMaxReport.
        /// </summary>
        /// <param name="other">
        /// A ClampMaxReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ClampMaxReport other)
        {
            return other != null && other.CalibrationValid == _calibrationValid && other.ClampPoints.Equals(_clampPoints) && other.ClampResults.Equals(_clampResults);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ClampMaxReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of ClampMaxReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ClampMaxReport other = (ClampMaxReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _clampResults.GetHashCode() ^ _clampPoints.GetHashCode() ^ _calibrationValid.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "ClampMaxReport: " + _clampResults.ToString() + _clampPoints.ToString() + ", CalibrationValid: " + _calibrationValid.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Specifies the Maximum limit of grid size to be used for pixel and real world points. 
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class MaxGridSize
    {
        private UInt32 _xMax;
        private UInt32 _yMax;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaxGridSize class.
        /// </summary>

        public MaxGridSize()
            : this(0,0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaxGridSize class.
        /// </summary>
        /// <param name="xMax">
        /// Defines xMax.
        /// </param>
        /// <param name="yMax">
        /// Defines yMax.
        /// </param>

        public MaxGridSize(UInt32 xMax, UInt32 yMax)
        {
            _xMax = xMax;
            _yMax = yMax;
        }
        //==========================================================================================
        /// <summary>
        /// maximum x value.
        /// </summary>        

        public UInt32 XMax
        {
            get { return _xMax; }
            set { _xMax = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Maximum Y value.
        /// </summary>        

        public UInt32 YMax
        {
            get { return _yMax; }
            set { _yMax = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified instance. 
        /// </summary>
        /// <param name="other">
        /// An ImagePreviewFileDialog instance to compare to this instance.
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the other parameter equals the value of this instance; otherwise, <see langword="false"/>. 
        /// </returns>

        public bool Equals(MaxGridSize other)
        {
            return other != null && _xMax == other._xMax && _yMax == other._yMax;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object. 
        /// </summary>
        /// <param name="obj">
        /// An object to compare with this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is a object that represents the same as the current; otherwise, <see langword="false"/>. 
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            MaxGridSize other = (MaxGridSize)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for this object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>

        public override int GetHashCode()
        {
            return _xMax.GetHashCode() ^ _yMax.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation. 
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance. 
        /// </returns>

        public override string ToString()
        {
            return "MaxGridSize: XMax=" + _xMax + ", YMax=" + _yMax;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Maximum grid size
    /// </summary>
    /// <remarks>
    /// </remarks>

    [Serializable]
    public sealed class ImageSize
    {
        private UInt32 _xRes;
        private UInt32 _yRes;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaxGridSize class.
        /// </summary>

        public ImageSize()
            : this(0,0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the MaxGridSize class.
        /// </summary>
        /// <param name="xRes">
        /// Defines x resolution.
        /// </param>
        /// <param name="yRes">
        /// Defines y resolution.
        /// </param>

        public ImageSize(UInt32 xRes, UInt32 yRes)
        {
            _xRes = xRes;
            _yRes = yRes;
        }
        //==========================================================================================
        /// <summary>
        /// X resolution of the image
        /// </summary>        

        public UInt32 XRes
        {
            get { return _xRes; }
            set { _xRes = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Y resolution of the image
        /// </summary>        

        public UInt32 YRes
        {
            get { return _yRes; }
            set { _yRes = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified instance. 
        /// </summary>
        /// <param name="other">
        /// An ImagePreviewFileDialog instance to compare to this instance.
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the other parameter equals the value of this instance; otherwise, <see langword="false"/>. 
        /// </returns>

        public bool Equals(ImageSize other)
        {
            return other != null && _xRes == other._xRes && _yRes == other._yRes;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object. 
        /// </summary>
        /// <param name="obj">
        /// An object to compare with this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is a object that represents the same as the current; otherwise, <see langword="false"/>. 
        /// </returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            ImageSize other = (ImageSize)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for this object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>

        public override int GetHashCode()
        {
            return _xRes.GetHashCode() ^ _yRes.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation. 
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance. 
        /// </returns>

        public override string ToString()
        {
            return "Image Size: xRes=" + _xRes + ", yRes=" + _yRes;
        }
    }
 
    //==============================================================================================
    /// <summary>
    /// The set of reference points to use in learning a calibration transformation.
    /// </summary>

    [Serializable]
    public sealed class CalibrationReferencePoints
    {
        private Collection<PointContour> _pixelCoords;    
        private Collection<PointContour> _realCoords;
        private CalibrationUnit _calibrationUnit;
        private ImageSize _imageSize; 
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationReferencePoints class.
        /// </summary>

        public CalibrationReferencePoints()
            : this(new Collection<PointContour>(), new Collection<PointContour>())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationReferencePoints class.
        /// </summary>       

        public CalibrationReferencePoints(Collection<PointContour> pixelCoords, Collection<PointContour> realCoords)
            : this(pixelCoords, realCoords, CalibrationUnit.Undefined)
        {            
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationReferencePoints class.
        /// </summary>       

        public CalibrationReferencePoints(Collection<PointContour> pixelCoords, Collection<PointContour> realCoords, CalibrationUnit calibrationUnit)
            : this(pixelCoords, realCoords, calibrationUnit, new ImageSize())
        {            
        }

         //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationReferencePoints class.
        /// </summary>       

        public CalibrationReferencePoints(Collection<PointContour> pixelCoords, Collection<PointContour> realCoords, CalibrationUnit calibrationUnit, ImageSize imageSize)
        {
            _pixelCoords = pixelCoords;
            _realCoords = realCoords;
            _calibrationUnit = calibrationUnit;
            _imageSize = imageSize;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the coordinates of the pixel reference points. 
        /// </summary>

        public Collection<PointContour> PixelCoords
        {
            get { return _pixelCoords; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _pixelCoords = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the measuring unit associated with the image.
        /// </summary>

        public Collection<PointContour> RealCoords
        {
            get { return _realCoords; }
            internal set { if (value == null) { throw new ArgumentNullException("value"); } _realCoords = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or Sets the Calibration Unit. 
        /// </summary>

        public CalibrationUnit CalibrationUnit
        {
            get { return _calibrationUnit; }
            set { _calibrationUnit = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Gets or Sets the ImageSize.
        /// </summary>

        public ImageSize ImageSize
        {
            get { return _imageSize; }
            set { _imageSize = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationReferencePoints.
        /// </summary>
        /// <param name="other">
        /// A CalibrationReferencePoints instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CalibrationReferencePoints other)
        {
            return other != null && _pixelCoords.Equals(other._pixelCoords) && _realCoords.Equals(other._realCoords) && _calibrationUnit.Equals(other._calibrationUnit) && _imageSize.Equals(other._imageSize);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationReferencePoints.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationReferencePoints
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationReferencePoints other = (CalibrationReferencePoints)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return ((_pixelCoords != null) ? _pixelCoords.GetHashCode() : 0) ^ ((_realCoords != null) ? _realCoords.GetHashCode() : 0) ^ _calibrationUnit.GetHashCode() ^ _imageSize.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationReferencePoints: " +
                ((_pixelCoords != null) ? ("Pixel Coords: " + _pixelCoords.ToString()) : "") +
                ((_realCoords != null) ? ("Real Coords: " + _realCoords.ToString()) : "") +
                "Calibration Unit: "+ _calibrationUnit.ToString() +
                "Image Size: "+ _imageSize.ToString();
        }
    }

    //==============================================================================================
    /// <summary>
    /// Defines a Reference Coordinate System for the real-world coordinates.
    /// </summary>

    [Serializable]
    public sealed class CalibrationAxisInfo
    {
        private PointContour _center;        
        private float        _rotationAngle; //
        private AxisOrientation    _axisDirection; //Axis direction of the calibration axis.
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationAxisInfo class.
        /// </summary>

        public CalibrationAxisInfo()
            : this(new PointContour())
        {            
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationAxisInfo class.
        /// </summary>

        public CalibrationAxisInfo(PointContour center)
            : this(center, 0)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationAxisInfo class.
        /// </summary>

        public CalibrationAxisInfo(PointContour center, float rotationAngle)
            : this(center, rotationAngle, AxisOrientation.Indirect)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationAxisInfo class.
        /// </summary>

        public CalibrationAxisInfo(PointContour center, float rotationAngle, AxisOrientation axisDirection)           
        {
            _center = center;
            _rotationAngle = rotationAngle;
            _axisDirection = axisDirection;
        }

        //==========================================================================================
        /// <summary>
        /// The origin of the reference coordinate system, expressed in pixel units.
        /// </summary>        

        public PointContour Center
        {
            get { return _center; }
            set { _center = value; }
        }

        //==========================================================================================
        /// <summary>
        /// The angle of the x-axis of the real-world coordinate system, in relation to the horizontal.
        /// </summary>        

        public float RotationAngle
        {
            get { return _rotationAngle; }
            set { _rotationAngle = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Direction of the calibraiton axis which is either Direct or Indirect. 
        /// </summary>        

        public AxisOrientation AxisDirection
        {
            get { return _axisDirection; }
            set { _axisDirection = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationAxisInfo.
        /// </summary>
        /// <param name="other">
        /// A CalibrationAxisInfo instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CalibrationAxisInfo other)
        {
            return other != null && _center.Equals(other._center) && _rotationAngle == other._rotationAngle && _axisDirection == other._axisDirection;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationAxisInfo.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationAxisInfo
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationAxisInfo other = (CalibrationAxisInfo)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _center.GetHashCode() ^  _axisDirection.GetHashCode() ^ _rotationAngle.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationAxisInfo: Center=" + _center.ToString() +
                ", Axis direction=" + _axisDirection+
                ", Rotation Angle="+ _rotationAngle;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides calibration learn setup information.
    /// </summary>

    [Serializable]
    public sealed class CalibrationLearnSetupInfoAll
    {
        private CalibrationMethod2 _calibrationMethod;    
        private DistortionModel _distortionModel;      
        private ScalingMethod   _scaleMode;            
        private CalibrationCorrectionMode  _calibrationCorrectionMode;              
        private bool _learnCorrectionTable; 

        //==========================================================================================
        /// <summary>
        /// The type of calibration method used.
        /// </summary>        

        public CalibrationMethod2 CalibrationMethod
        {
            get { return _calibrationMethod; }
            set { _calibrationMethod = value; }
        }

        //==========================================================================================
        /// <summary>
        /// The type of distortion you can correct when correcting an image.
        /// </summary>        

        public DistortionModel DistortionModel
        {
            get { return _distortionModel; }
            set { _distortionModel = value; }
        }

        //==========================================================================================
        /// <summary>
        /// The aspect scaling to use when correcting an image.
        /// </summary>        

        public ScalingMethod ScaleMode
        {
            get { return _scaleMode; }
            set { _scaleMode = value; }
        }                

        //==========================================================================================
        /// <summary>
        /// The ROI to use when correcting an image.
        /// </summary>        

        public CalibrationCorrectionMode CalibrationCorrectionMode
        {
            get { return _calibrationCorrectionMode; }
            set { _calibrationCorrectionMode = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Set this input to true value if you want the correction table to be determined and stored. The correction table accelerates the process of correcting an image. It is useful if several images are going to be corrected.
        /// </summary>        

        public bool LearnCorrectionTable
        {
            get { return _learnCorrectionTable; }
            set { _learnCorrectionTable = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll()
            : this(CalibrationMethod2.Perspective)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll(CalibrationMethod2 calibrationMethod)
            : this(calibrationMethod, DistortionModel.NoDistortionModel)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll(CalibrationMethod2 calibrationMethod, DistortionModel distortionModel)
            : this(calibrationMethod, distortionModel, ScalingMethod.ScaleToPreserveArea)
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll(CalibrationMethod2 calibrationMethod, DistortionModel distortionModel,ScalingMethod scaleMode)
            : this(calibrationMethod, distortionModel, scaleMode, CalibrationCorrectionMode.FullImage)
        {                 
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll(CalibrationMethod2 calibrationMethod, DistortionModel distortionModel,ScalingMethod scaleMode, CalibrationCorrectionMode calibrationCorrectionMode)
            : this(calibrationMethod, distortionModel, scaleMode, calibrationCorrectionMode, false)
        {            
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfoAll class.
        /// </summary>

        public CalibrationLearnSetupInfoAll(CalibrationMethod2 calibrationMethod, DistortionModel distortionModel, ScalingMethod scaleMode, CalibrationCorrectionMode calibrationCorrectionMode, bool learnCorrectionTable)            
        {    
            _calibrationMethod = calibrationMethod;
            _distortionModel = distortionModel;
            _scaleMode = scaleMode;
            _calibrationCorrectionMode = calibrationCorrectionMode;
            _learnCorrectionTable = learnCorrectionTable;
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationLearnSetupInfoAll.
        /// </summary>
        /// <param name="other">
        /// A CalibrationLearnSetupInfoAll instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CalibrationLearnSetupInfoAll other)
        {
            return other != null && _calibrationMethod.Equals(other._calibrationMethod) && _distortionModel == other._distortionModel && _scaleMode == other._scaleMode && _calibrationCorrectionMode == other._calibrationCorrectionMode && _learnCorrectionTable == other._learnCorrectionTable;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationLearnSetupInfoAll.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationLearnSetupInfoAll
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationLearnSetupInfoAll other = (CalibrationLearnSetupInfoAll)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _calibrationMethod.GetHashCode() ^  _distortionModel.GetHashCode() ^ _scaleMode.GetHashCode() ^ _calibrationCorrectionMode.GetHashCode() ^ _learnCorrectionTable.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationLearnSetupInfoAll: CalibrationMethod=" + _calibrationMethod.ToString() +
                ", Distortion Model=" + _distortionModel.ToString()+
                ", ScaleMode="+ _scaleMode.ToString()+
                ", CalibrationCorrectionMode=" + _calibrationCorrectionMode.ToString() +
                ", LearnCorrectionTable="+_learnCorrectionTable.ToString();
        }
    }
    
    //==============================================================================================
    /// <summary>
    /// Error statistics Information.
    /// </summary>

    [Serializable]
    public sealed class ErrorStatistics
    {
        private double _mean;
        private double _maximum;
        private double _standardDeviation;
        private double _distortion;

        //==========================================================================================
        /// <summary>
        /// Mean value of error.
        /// </summary>        

        public double Mean
        {
            get { return _mean; }
            set { _mean = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Maximum value of error.
        /// </summary>        

        public double Maximum
        {
            get { return _maximum; }
            set { _maximum = value; }
        }

        //==========================================================================================
        /// <summary>
        /// StandardDeviation value of error.
        /// </summary>        

        public double StandardDeviation
        {
            get { return _standardDeviation; }
            set { _standardDeviation = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Distortion value of error.
        /// </summary>        

        public double Distortion
        {
            get { return _distortion; }
            set { _distortion = value; }
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ErrorStatistics class.
        /// </summary>

        public ErrorStatistics()
            : this(0.0, 0.0, 0.0, 0.0)
        {            
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the ErrorStatistics class.
        /// </summary>

        public ErrorStatistics(double mean, double maximum, double standardDeviation, double distortion)            
        {     
            _mean = mean;
            _maximum = maximum;
            _standardDeviation = standardDeviation;
            _distortion = distortion;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified ErrorStatistics.
        /// </summary>
        /// <param name="other">
        /// A ErrorStatistics instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(ErrorStatistics other)
        {
            return other != null && _mean == other.Mean && _maximum == other.Maximum && _standardDeviation == other.StandardDeviation && _distortion == other.Distortion;
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationLearnSetupInfoAll.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationLearnSetupInfoAll
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationLearnSetupInfoAll other = (CalibrationLearnSetupInfoAll)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _mean.GetHashCode() ^ _maximum.GetHashCode() ^ _distortion.GetHashCode() ^ _standardDeviation.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationLearnSetupInfoAll: Mean=" + _mean +
                ", Maximum=" + _maximum +
                ", Standard Deviation=" + _standardDeviation +
                ", Distortion=" + _distortion;
        }
    }

    //==============================================================================================
    /// <summary>
    /// Provides the calibration information associated with an image.
    /// </summary>

    [Serializable]
    public sealed class GetCalibrationInfoReport
    {
        [NonSerialized] private Roi _userROI;
        [NonSerialized] private Roi _calibrationROI;        
        private CalibrationAxisInfo _axisInfo;
        private CalibrationLearnSetupInfoAll _learnSetupInfo;
        private GridDescriptor _simpleGridDescriptor;
        private float[,] _errorMap;
        private ErrorStatistics _errorStatistics;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>

        public GetCalibrationInfoReport()
            : this(new Roi(), new Roi(), new CalibrationAxisInfo(), new CalibrationLearnSetupInfoAll(), new GridDescriptor(), new float[0, 0], new ErrorStatistics())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>

        public GetCalibrationInfoReport(Roi userROI, Roi calibrationROI)
            : this(userROI, calibrationROI, new CalibrationAxisInfo(), new CalibrationLearnSetupInfoAll(), new GridDescriptor(), new float[0, 0], new ErrorStatistics())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>

        public GetCalibrationInfoReport(Roi userROI, Roi calibrationROI, CalibrationAxisInfo axisInfo)
            : this(userROI, calibrationROI, axisInfo, new CalibrationLearnSetupInfoAll(), new GridDescriptor(), new float[0, 0], new ErrorStatistics())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>

        public GetCalibrationInfoReport(Roi userROI, Roi calibrationROI, CalibrationAxisInfo axisInfo, CalibrationLearnSetupInfoAll learnSetupInfo)
            : this(userROI, calibrationROI, axisInfo, learnSetupInfo, new GridDescriptor(), new float[0, 0], new ErrorStatistics())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>       

        public GetCalibrationInfoReport(Roi userROI, Roi calibrationROI, CalibrationAxisInfo axisInfo, CalibrationLearnSetupInfoAll learnSetupInfo, GridDescriptor simpleGridDescriptor)
            : this(userROI, calibrationROI, axisInfo, learnSetupInfo, simpleGridDescriptor, new float[0,0], new ErrorStatistics())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>       

        public GetCalibrationInfoReport(Roi userROI, Roi calibrationROI, CalibrationAxisInfo axisInfo, CalibrationLearnSetupInfoAll learnSetupInfo, GridDescriptor simpleGridDescriptor, float[,]  errorMap)
            : this(userROI, calibrationROI, axisInfo, learnSetupInfo, simpleGridDescriptor, errorMap, new ErrorStatistics())
        {
        }

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the GetCalibrationInfoReport class.
        /// </summary>       

        public GetCalibrationInfoReport( Roi userROI, Roi calibrationROI, CalibrationAxisInfo axisInfo, CalibrationLearnSetupInfoAll learnSetupInfo, GridDescriptor simpleGridDescriptor, float[,]  errorMap, ErrorStatistics errorStatistics)
        {
            _userROI = userROI;
            _calibrationROI = calibrationROI;
            _axisInfo = axisInfo;
            _learnSetupInfo = learnSetupInfo;
            _simpleGridDescriptor = simpleGridDescriptor;
            _errorMap = errorMap;
            _errorStatistics = errorStatistics;
        }

        //==========================================================================================
        /// <summary>
        /// Gets or sets the region you specified at the time of calibration.
        /// </summary>

        public Roi UserROI
        {
            get { return _userROI; }
            set { _userROI = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the ROI that corresponds to the region of the image where the calibration information is accurate. 
        /// </summary>

        public Roi CalibrationROI
        {
            get { return _calibrationROI; }
            set { _calibrationROI = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the reference Coordinate System for the real-world coordinates. 
        /// </summary>

        public CalibrationAxisInfo AxisInfo
        {
            get { return _axisInfo; }
            set { _axisInfo = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learnSetupInfo. 
        /// </summary>

        public CalibrationLearnSetupInfoAll LearnSetupInfo
        {
            get { return _learnSetupInfo; }
            set { _learnSetupInfo = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets scaling constants used to calibrate the image. 
        /// </summary>

        public GridDescriptor SimpleGridDescriptor
        {
            get { return _simpleGridDescriptor; }
            set { _simpleGridDescriptor = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the error map of calibration template image. 
        /// </summary>

        public float[,] ErrorMap
        {
            get { return _errorMap; }
            set { _errorMap = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the errorStatistics. 
        /// </summary>

        public ErrorStatistics ErrorStatistics
        {
            get { return _errorStatistics; }
            set { _errorStatistics = value; }
        }
//==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GetCalibrationInfoReport.
        /// </summary>
        /// <param name="other">
        /// A GetCalibrationInfoReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(GetCalibrationInfoReport other)
        {
            return other != null && _userROI.Equals(other.UserROI) && _calibrationROI.Equals(other.CalibrationROI) && _axisInfo.Equals(other.AxisInfo) && _learnSetupInfo.Equals(other.LearnSetupInfo) && _simpleGridDescriptor.Equals(other.SimpleGridDescriptor) && _errorMap.Equals(other.ErrorMap) && _errorStatistics.Equals(other.ErrorStatistics);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified GetCalibrationInfoReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of GetCalibrationInfoReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            GetCalibrationInfoReport other = (GetCalibrationInfoReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _userROI.GetHashCode() ^ _calibrationROI.GetHashCode() ^ _learnSetupInfo.GetHashCode() ^ _axisInfo.GetHashCode() ^ _simpleGridDescriptor.GetHashCode() ^ _errorMap.GetHashCode() ^ _errorStatistics.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "GetCalibrationInfoReport: " +
                "User ROI: " + _userROI.ToString() +
                ", Calibration ROI: " + _calibrationROI.ToString() +
                ", Learn Setup Info: " + _learnSetupInfo.ToString() +
                ", Axis Info: " + _axisInfo.ToString() +
                ", Simple Grid Descriptor: " + _simpleGridDescriptor.ToString() +
                ", Error map: " + _errorMap.ToString() +
                ", Error Statistics: " + _errorStatistics.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the learned coefficients of polynomial model.
    /// </summary>

    [Serializable]
    public sealed class PolyModel
    {
        private Collection<float> _kCoefficients;   
        private float _p1;
        private float _p2;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PolyModel class.
        /// </summary>

        public PolyModel()
            :this(new Collection<float>(), 0, 0)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the PolyModel class.
        /// </summary>       

        public PolyModel(Collection<float> kCoefficients, float p1, float p2)
        {
            _kCoefficients = kCoefficients;            
            _p1 = p1;
            _p2 = p2;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learned radial coefficients of polynomial model.
        /// </summary>

        public Collection<float> KCoefficients
        {
            get { return _kCoefficients; }
            set { _kCoefficients = value; }
        }
        
        //==========================================================================================
        /// <summary>
        /// Gets or sets the P1(learned tangential coefficients of polynomial model). 
        /// </summary>

        public float P1
        {
            get { return _p1; }
            set { _p1 = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the P2(learned tangential coefficients of polynomial model).
        /// </summary>

        public float P2
        {
            get { return _p2; }
            set { _p2 = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PolyModel.
        /// </summary>
        /// <param name="other">
        /// A PolyModel instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(PolyModel other)
        {
            return other != null && _kCoefficients.Equals(other._kCoefficients) && _p1.Equals(other.P1) && _p2.Equals(other.P2);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified PolyModel.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of PolyModel
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            PolyModel other = (PolyModel)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _kCoefficients.GetHashCode() ^ _p1.GetHashCode() ^ _p2.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "PolyModel: " +
                "kCoefficients:" + _kCoefficients.ToString() +                
                ", P1: " + _p1 +
                ", P2: " + _p2;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the learned coefficient of division model.
    /// </summary>

    [Serializable]
    public sealed class DivModel
    {
        private float _kappa;
        
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DivModel class.
        /// </summary>

        public DivModel()
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DivModel class.
        /// </summary>       

        public DivModel(float kappa)
        {
            _kappa = kappa;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learned kappa coefficient of division model. 
        /// </summary>

        public float Kappa
        {
            get { return _kappa; }
            set { _kappa = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DivModel.
        /// </summary>
        /// <param name="other">
        /// A DivModel instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DivModel other)
        {
            return other != null && _kappa.Equals(other.Kappa);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DivModel.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DivModel
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DivModel other = (DivModel)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _kappa.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DivModel: " +
                "Kappa: " + _kappa;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides Distortion Model Coefficients.
    /// </summary>

    [Serializable]
    public sealed class DistortionModelParams
    {
        private DistortionModel _distortionModel;
        private PolyModel _polyModel;
        private DivModel _divModel;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DistortionModelParams class.
        /// </summary>       

        public DistortionModelParams()
            : this(DistortionModel.DivisionModel)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DistortionModelParams class.
        /// </summary>       

        public DistortionModelParams(DistortionModel distortionModel)
            : this(distortionModel, new PolyModel())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DistortionModelParams class.
        /// </summary>       

        public DistortionModelParams(DistortionModel distortionModel, PolyModel polyModel)
            : this(distortionModel, polyModel, new DivModel())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the DistortionModelParams class.
        /// </summary>       

        public DistortionModelParams(DistortionModel distortionModel, PolyModel polyModel, DivModel divModel)
        {
            _distortionModel = distortionModel;
            _polyModel = polyModel;
            _divModel = divModel;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the type of learned distortion model. 
        /// </summary>

        public DistortionModel DistortionModel
        {
            get { return _distortionModel; }
            set { _distortionModel = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learned coefficients of polynomial model.
        /// </summary>

        public PolyModel PolyModel
        {
            get { return _polyModel; }
            set { _polyModel = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learned coefficient of division model. 
        /// </summary>

        public DivModel DivModel
        {
            get { return _divModel; }
            set { _divModel = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DistortionModelParams.
        /// </summary>
        /// <param name="other">
        /// A DistortionModelParams instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(DistortionModelParams other)
        {
            return other != null && _distortionModel.Equals(other.DistortionModel) && _divModel.Equals(other.DivModel) && _polyModel.Equals(other.PolyModel);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified DistortionModelParams.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of DistortionModelParams
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            DistortionModelParams other = (DistortionModelParams)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _polyModel.GetHashCode() ^ _distortionModel.GetHashCode() ^ _divModel.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "DistortionModelParameters: " +
                "Distortion model: " + _distortionModel.ToString() +
                ", " + _divModel.ToString() +
                ", " + _polyModel.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the focal length in pixel units.
    /// </summary>

    [Serializable]
    public sealed class FocalLength
    {
        private float _fx;
        private float _fy;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FocalLength class.
        /// </summary>

        public FocalLength()
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the FocalLength class.
        /// </summary>       

        public FocalLength(float fx, float fy)
        {
            _fx = fx;
            _fy = fy;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets focal length in x direction.
        /// </summary>

        public float Fx
        {
            get { return _fx; }
            set { _fx = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets focal length in y direction.
        /// </summary>

        public float Fy
        {
            get { return _fy; }
            set { _fy = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FocalLength.
        /// </summary>
        /// <param name="other">
        /// A FocalLength instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(FocalLength other)
        {
            return other != null && _fx.Equals(other.Fx) && _fy.Equals(other.Fy);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified FocalLength.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of FocalLength
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            FocalLength other = (FocalLength)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _fx.GetHashCode() ^ _fy.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "FocalLength: " +
                "Fx: " + _fx + ", Fy: " + _fy;
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides Internal Parameters.
    /// </summary>

    [Serializable]
    public sealed class InternalParameters
    {
        private bool _isInsufficientData;
        private FocalLength _focalLength;
        private PointContour _opticalCenter;

        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InternalParameters class.
        /// </summary>       

        public InternalParameters()
            : this(false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InternalParameters class.
        /// </summary>       

        public InternalParameters(bool isInsufficientData)
            : this(isInsufficientData, new FocalLength())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InternalParameters class.
        /// </summary>       

        public InternalParameters(bool isInsufficientData, FocalLength focalLength)
            : this(isInsufficientData, focalLength, new PointContour())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the InternalParameters class.
        /// </summary>       

        public InternalParameters(bool isInsufficientData, FocalLength focalLength, PointContour opticalCenter)
        {
            _isInsufficientData = isInsufficientData;
            _focalLength = focalLength;
            _opticalCenter = opticalCenter;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the IsInsufficientData. IsInsufficientData is set to true, if number of different projection planes or the angle difference of projection planes are less than required.
        /// </summary>

        public bool IsInsufficientData
        {
            get { return _isInsufficientData; }
            set { _isInsufficientData = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the the focal length in pixel units.
        /// </summary>

        public FocalLength FocalLength
        {
            get { return _focalLength; }
            set { _focalLength = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the optical center in image. 
        /// </summary>

        public PointContour OpticalCenter
        {
            get { return _opticalCenter; }
            set { _opticalCenter = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InternalParameters.
        /// </summary>
        /// <param name="other">
        /// A InternalParameters instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(InternalParameters other)
        {
            return other != null && _isInsufficientData.Equals(other.IsInsufficientData) && _focalLength.Equals(other.FocalLength) && _opticalCenter.Equals(other.OpticalCenter);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified InternalParameters.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of InternalParameters
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            InternalParameters other = (InternalParameters)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _isInsufficientData.GetHashCode() ^ _focalLength.GetHashCode() ^ _opticalCenter.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "InternalParameters: " +
                "Is insufficient data: " + _isInsufficientData.ToString() +
                ", " + _focalLength.ToString() +
                ", Optical Center: " + _opticalCenter.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the internal and external paramters of learned camera model.
    /// </summary>

    [Serializable]
    public sealed class CameraParametersReport
    {
        private double[,] _projectionMatrix;
        private DistortionModelParams _distortion;
        private InternalParameters _internalParams;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CameraParametersReport class.
        /// </summary>       

        public CameraParametersReport()
            : this(new double[0,0])
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CameraParametersReport class.
        /// </summary>       

        public CameraParametersReport(double[,] projectionMatrix)
            : this(projectionMatrix, new DistortionModelParams())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CameraParametersReport class.
        /// </summary>       

        public CameraParametersReport(double[,] projectionMatrix, DistortionModelParams distortion)
            : this(projectionMatrix, distortion, new InternalParameters())
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CameraParametersReport class.
        /// </summary>       

        public CameraParametersReport(double[,] projectionMatrix, DistortionModelParams distortion, InternalParameters internalParams)
        {
            _projectionMatrix = projectionMatrix;
            _distortion = distortion;
            _internalParams = internalParams;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the projection(homography) matrix of working plane.
        /// </summary>

        public double[,] ProjectionMatrix
        {
            get { return _projectionMatrix; }
            set { _projectionMatrix = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Distortion Model Coeffiecients. 
        /// </summary>

        public DistortionModelParams Distortion
        {
            get { return _distortion; }
            set { _distortion = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the learned internal paramters of camera model such as focal length and optical center.
        /// </summary>

        public InternalParameters InternalParams
        {
            get { return _internalParams; }
            set { _internalParams = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CameraParametersReport.
        /// </summary>
        /// <param name="other">
        /// A CameraParametersReport instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CameraParametersReport other)
        {
            return other != null && _distortion.Equals(other.Distortion) && _projectionMatrix.Equals(other.ProjectionMatrix) && _internalParams.Equals(other.ProjectionMatrix);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CameraParametersReport.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CameraParametersReport
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CameraParametersReport other = (CameraParametersReport)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _projectionMatrix.GetHashCode() ^ _distortion.GetHashCode() ^ _internalParams.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CameraParametersReport: " +
                "Projection Matrix: " + _projectionMatrix.ToString() +
                ", " + _distortion.ToString() +
                ", " + _internalParams.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the setup parameters for Camera Model and Distortion Model.
    /// </summary>

    [Serializable]
    public sealed class CalibrationModelSetup
    {
        private DistortionModel _distortionModel;
        private RadialCoefficients _radialCoefficients;
        private bool _tangentialCoefficients;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationModelSetup()
            : this(DistortionModel.PolynomialModel)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationModelSetup(DistortionModel distortionModel)
            : this(distortionModel, RadialCoefficients.CoeffK1K2K3)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationModelSetup(DistortionModel distortionModel, RadialCoefficients radialCoefficients)
            : this(distortionModel, radialCoefficients, true)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationModelSetup(DistortionModel distortionModel, RadialCoefficients radialCoefficients, bool tangentialCoefficients)
        {
            _distortionModel = distortionModel;
            _radialCoefficients = radialCoefficients;
            _tangentialCoefficients = tangentialCoefficients;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Distortion Model value
        /// </summary>

        public DistortionModel DistortionModel
        {
            get { return _distortionModel; }
            set { _distortionModel = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Radial Coefficients. 
        /// </summary>

        public RadialCoefficients RadialCoefficients
        {
            get { return _radialCoefficients; }
            set { _radialCoefficients = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Int32 Tangential Coefficients.
        /// </summary>

        public bool TangentialCoefficients
        {
            get { return _tangentialCoefficients; }
            set { _tangentialCoefficients = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationModelSetup.
        /// </summary>
        /// <param name="other">
        /// A CalibrationModelSetup instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CalibrationModelSetup other)
        {
            return other != null && _distortionModel.Equals(other.DistortionModel) && _radialCoefficients.Equals(other.RadialCoefficients) && _tangentialCoefficients.Equals(other.TangentialCoefficients);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationModelSetup.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationModelSetup
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationModelSetup other = (CalibrationModelSetup)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _distortionModel.GetHashCode() ^ _radialCoefficients.GetHashCode() ^ _tangentialCoefficients.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationModelSetup: " +
                "Distortion Model: " + _distortionModel.ToString() +
                ", Radial Coefficients: " +_radialCoefficients.ToString() +
                ", Tangential Coefficients" + _tangentialCoefficients.ToString();
        }
    }
    //==============================================================================================
    /// <summary>
    /// Provides the Calibration learn setup information.
    /// </summary>

    [Serializable]
    public sealed class CalibrationLearnSetupInfo
    {
        private ScalingMethod _scalingMethod;
        private CalibrationCorrectionMode _calibrationCorrectionMode;
        private bool _learnCorrectionTable;
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationLearnSetupInfo()
            : this(ScalingMethod.ScaleToPreserveArea)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationLearnSetupInfo class.
        /// </summary>       

        public CalibrationLearnSetupInfo(ScalingMethod scalingMethod)
            : this(scalingMethod, CalibrationCorrectionMode.FullImage)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationLearnSetupInfo(ScalingMethod scalingMethod, CalibrationCorrectionMode calibrationCorrectionMode)
            : this(scalingMethod, calibrationCorrectionMode, false)
        {
        }
        //==========================================================================================
        /// <summary>
        /// Initializes a new instance of the CalibrationModelSetup class.
        /// </summary>       

        public CalibrationLearnSetupInfo(ScalingMethod scalingMethod, CalibrationCorrectionMode calibrationCorrectionMode, bool learnCorrectionTable )
        {
            _scalingMethod = scalingMethod;
            _calibrationCorrectionMode = calibrationCorrectionMode;
            _learnCorrectionTable = learnCorrectionTable;
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the scaling method
        /// </summary>

        public ScalingMethod ScalingMethod
        {
            get { return _scalingMethod; }
            set { _scalingMethod = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Calibration correction mode.
        /// </summary>

        public CalibrationCorrectionMode CalibrationCorrectionMode
        {
            get { return _calibrationCorrectionMode; }
            set { _calibrationCorrectionMode = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Gets or sets the Learn correction table.
        /// </summary>

        public bool LearnCorrectionTable
        {
            get { return _learnCorrectionTable; }
            set { _learnCorrectionTable = value; }
        }
        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationLearnSetupInfo.
        /// </summary>
        /// <param name="other">
        /// A CalibrationLearnSetupInfo instance to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if the <paramref name="other"/> parameter equals the value of this instance; otherwise, <see langword="false"/>.
        /// </returns>

        public bool Equals(CalibrationLearnSetupInfo other)
        {
            return other != null && _learnCorrectionTable.Equals(other.LearnCorrectionTable) && _calibrationCorrectionMode.Equals(other.CalibrationCorrectionMode) && _scalingMethod.Equals(other.ScalingMethod);
        }

        //==========================================================================================
        /// <summary>
        /// Returns a value indicating whether this instance is equal to the specified CalibrationLearnSetupInfo.
        /// </summary>
        /// <param name="obj">
        /// An object to compare to this instance. 
        /// </param>
        /// <returns>
        /// 	<see langword="true"/> if <paramref name="obj"/> is an instance of CalibrationLearnSetupInfo
        ///  and equals the value of this instance; otherwise, <see langword="false"/>.</returns>

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj.GetType() != this.GetType()) return false;
            CalibrationLearnSetupInfo other = (CalibrationLearnSetupInfo)obj;
            return Equals(other);
        }
        //==========================================================================================
        /// <summary>
        /// Returns a hash code for the object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code. 
        /// </returns>

        public override int GetHashCode()
        {
            return _scalingMethod.GetHashCode() ^ _calibrationCorrectionMode.GetHashCode() ^ _learnCorrectionTable.GetHashCode();
        }
        //==========================================================================================
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string representation of the value of this instance.
        /// </returns>

        public override string ToString()
        {
            return "CalibrationLearnSetupInfo: " +
                "Scaling Method: " + _scalingMethod.ToString() +
                ", Calibration Correction mode: " + _calibrationCorrectionMode.ToString() +
                ", Learn Correction table" + _learnCorrectionTable.ToString();
        }
    }
}
